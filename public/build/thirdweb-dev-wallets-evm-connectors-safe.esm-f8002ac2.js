import { B as BigNumber, bK as formatFixed, bL as FixedFormat, bM as FixedNumber, bN as parseFixed, bO as _base16To36, bP as _base36To16, bQ as getAugmentedNamespace, bR as form_data, aB as commonjsGlobal, bS as lib_esm$1, bT as require$$0$9, bU as require$$0$a, bV as bnExports$2, bW as minimalisticAssert, bX as inheritsExports, bY as hash$2, bZ as require$$0$d, b_ as require$$2$4, u as utils$t, b$ as require$$1$8, c0 as commonjsRequire, c1 as sha3Exports, c2 as require$$1$9, c3 as require$$2$5, aA as getDefaultExportFromCjs, C as Connector, a as _defineProperty, c4 as ethers$1, c5 as BaseContract, c6 as hashMessage, e as getAddress, x as AddressZero } from './App-40ca2dcc.js';
import require$$1$6 from 'http';
import require$$1$7 from 'https';
import Url from 'url';
import Stream from 'stream';
import require$$0$8 from 'assert';
import { r as requireSrc, s as satisfies_1$2, a as api, j as js } from './js-fc8e7a63.js';
import zlib from 'zlib';
import require$$0$b from 'buffer';
import { r as requireNodeGypBuild } from './index-612ded02.js';
import require$$0$c from 'crypto';
import require$$0$e from 'events';
import require$$0$f from 'util';
import 'os';
import 'fs';
import 'path';
import 'worker_threads';
import 'module';
import 'punycode';
import 'tty';

var lib_esm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BigNumber: BigNumber,
  formatFixed: formatFixed,
  FixedFormat: FixedFormat,
  FixedNumber: FixedNumber,
  parseFixed: parseFixed,
  _base16To36: _base16To36,
  _base36To16: _base36To16
});

var src$6 = {};

var service = {};

var require$$0$7 = /*@__PURE__*/getAugmentedNamespace(lib_esm);

var axios$2 = {exports: {}};

var bind$2 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

var bind$1 = bind$2;

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

var utils$s = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

var utils$r = utils$s;

function encode$2(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
var buildURL$1 = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$r.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils$r.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils$r.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils$r.forEach(val, function parseValue(v) {
        if (utils$r.isDate(v)) {
          v = v.toISOString();
        } else if (utils$r.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$2(key) + '=' + encode$2(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

var utils$q = utils$s;

function InterceptorManager$1() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager$1.prototype.forEach = function forEach(fn) {
  utils$q.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

var InterceptorManager_1 = InterceptorManager$1;

var utils$p = utils$s;

var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$p.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

var AxiosError_1;
var hasRequiredAxiosError;

function requireAxiosError () {
	if (hasRequiredAxiosError) return AxiosError_1;
	hasRequiredAxiosError = 1;

	var utils = utils$s;

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	function AxiosError(message, code, config, request, response) {
	  Error.call(this);
	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  response && (this.response = response);
	}

	utils.inherits(AxiosError, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code,
	      status: this.response && this.response.status ? this.response.status : null
	    };
	  }
	});

	var prototype = AxiosError.prototype;
	var descriptors = {};

	[
	  'ERR_BAD_OPTION_VALUE',
	  'ERR_BAD_OPTION',
	  'ECONNABORTED',
	  'ETIMEDOUT',
	  'ERR_NETWORK',
	  'ERR_FR_TOO_MANY_REDIRECTS',
	  'ERR_DEPRECATED',
	  'ERR_BAD_RESPONSE',
	  'ERR_BAD_REQUEST',
	  'ERR_CANCELED'
	// eslint-disable-next-line func-names
	].forEach(function(code) {
	  descriptors[code] = {value: code};
	});

	Object.defineProperties(AxiosError, descriptors);
	Object.defineProperty(prototype, 'isAxiosError', {value: true});

	// eslint-disable-next-line func-names
	AxiosError.from = function(error, code, config, request, response, customProps) {
	  var axiosError = Object.create(prototype);

	  utils.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  });

	  AxiosError.call(axiosError, error.message, code, config, request, response);

	  axiosError.name = error.name;

	  customProps && Object.assign(axiosError, customProps);

	  return axiosError;
	};

	AxiosError_1 = AxiosError;
	return AxiosError_1;
}

var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var toFormData_1;
var hasRequiredToFormData;

function requireToFormData () {
	if (hasRequiredToFormData) return toFormData_1;
	hasRequiredToFormData = 1;

	var utils = utils$s;

	/**
	 * Convert a data object to FormData
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @returns {Object}
	 **/

	function toFormData(obj, formData) {
	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new FormData();

	  var stack = [];

	  function convertValue(value) {
	    if (value === null) return '';

	    if (utils.isDate(value)) {
	      return value.toISOString();
	    }

	    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
	      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    }

	    return value;
	  }

	  function build(data, parentKey) {
	    if (utils.isPlainObject(data) || utils.isArray(data)) {
	      if (stack.indexOf(data) !== -1) {
	        throw Error('Circular reference detected in ' + parentKey);
	      }

	      stack.push(data);

	      utils.forEach(data, function each(value, key) {
	        if (utils.isUndefined(value)) return;
	        var fullKey = parentKey ? parentKey + '.' + key : key;
	        var arr;

	        if (value && !parentKey && typeof value === 'object') {
	          if (utils.endsWith(key, '{}')) {
	            // eslint-disable-next-line no-param-reassign
	            value = JSON.stringify(value);
	          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
	            // eslint-disable-next-line func-names
	            arr.forEach(function(el) {
	              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
	            });
	            return;
	          }
	        }

	        build(value, fullKey);
	      });

	      stack.pop();
	    } else {
	      formData.append(parentKey, convertValue(data));
	    }
	  }

	  build(obj);

	  return formData;
	}

	toFormData_1 = toFormData;
	return toFormData_1;
}

var settle;
var hasRequiredSettle;

function requireSettle () {
	if (hasRequiredSettle) return settle;
	hasRequiredSettle = 1;

	var AxiosError = requireAxiosError();

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError(
	      'Request failed with status code ' + response.status,
	      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	      response.config,
	      response.request,
	      response
	    ));
	  }
	};
	return settle;
}

var cookies;
var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	var utils = utils$s;

	cookies = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);
	return cookies;
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

var parseHeaders;
var hasRequiredParseHeaders;

function requireParseHeaders () {
	if (hasRequiredParseHeaders) return parseHeaders;
	hasRequiredParseHeaders = 1;

	var utils = utils$s;

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};
	return parseHeaders;
}

var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;

function requireIsURLSameOrigin () {
	if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
	hasRequiredIsURLSameOrigin = 1;

	var utils = utils$s;

	isURLSameOrigin = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);
	return isURLSameOrigin;
}

var CanceledError_1;
var hasRequiredCanceledError;

function requireCanceledError () {
	if (hasRequiredCanceledError) return CanceledError_1;
	hasRequiredCanceledError = 1;

	var AxiosError = requireAxiosError();
	var utils = utils$s;

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function CanceledError(message) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
	  this.name = 'CanceledError';
	}

	utils.inherits(CanceledError, AxiosError, {
	  __CANCEL__: true
	});

	CanceledError_1 = CanceledError;
	return CanceledError_1;
}

var parseProtocol;
var hasRequiredParseProtocol;

function requireParseProtocol () {
	if (hasRequiredParseProtocol) return parseProtocol;
	hasRequiredParseProtocol = 1;

	parseProtocol = function parseProtocol(url) {
	  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	};
	return parseProtocol;
}

var xhr;
var hasRequiredXhr;

function requireXhr () {
	if (hasRequiredXhr) return xhr;
	hasRequiredXhr = 1;

	var utils = utils$s;
	var settle = requireSettle();
	var cookies = requireCookies();
	var buildURL = buildURL$1;
	var buildFullPath = buildFullPath$1;
	var parseHeaders = requireParseHeaders();
	var isURLSameOrigin = requireIsURLSameOrigin();
	var transitionalDefaults = transitional;
	var AxiosError = requireAxiosError();
	var CanceledError = requireCanceledError();
	var parseProtocol = requireParseProtocol();

	xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	    var responseType = config.responseType;
	    var onCanceled;
	    function done() {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(onCanceled);
	      }

	      if (config.signal) {
	        config.signal.removeEventListener('abort', onCanceled);
	      }
	    }

	    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    var fullPath = buildFullPath(config.baseURL, config.url);

	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
	        request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
	      var transitional = config.transitional || transitionalDefaults;
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(new AxiosError(
	        timeoutErrorMessage,
	        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	        config,
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
	        cookies.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = config.responseType;
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken || config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = function(cancel) {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
	        request.abort();
	        request = null;
	      };

	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	      if (config.signal) {
	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	      }
	    }

	    if (!requestData) {
	      requestData = null;
	    }

	    var protocol = parseProtocol(fullPath);

	    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
	      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
	      return;
	    }


	    // Send the request
	    request.send(requestData);
	  });
	};
	return xhr;
}

var followRedirects = {exports: {}};

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;
	var debug;

	debug_1 = function () {
	  if (!debug) {
	    try {
	      /* eslint global-require: off */
	      debug = requireSrc()("follow-redirects");
	    }
	    catch (error) { /* */ }
	    if (typeof debug !== "function") {
	      debug = function () { /* */ };
	    }
	  }
	  debug.apply(null, arguments);
	};
	return debug_1;
}

var hasRequiredFollowRedirects;

function requireFollowRedirects () {
	if (hasRequiredFollowRedirects) return followRedirects.exports;
	hasRequiredFollowRedirects = 1;
	var url = Url;
	var URL = url.URL;
	var http = require$$1$6;
	var https = require$$1$7;
	var Writable = Stream.Writable;
	var assert = require$$0$8;
	var debug = requireDebug();

	// Whether to use the native URL object or the legacy url module
	var useNativeURL = false;
	try {
	  assert(new URL());
	}
	catch (error) {
	  useNativeURL = error.code === "ERR_INVALID_URL";
	}

	// URL fields to preserve in copy operations
	var preservedUrlFields = [
	  "auth",
	  "host",
	  "hostname",
	  "href",
	  "path",
	  "pathname",
	  "port",
	  "protocol",
	  "query",
	  "search",
	  "hash",
	];

	// Create handlers that pass events from native requests
	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	var eventHandlers = Object.create(null);
	events.forEach(function (event) {
	  eventHandlers[event] = function (arg1, arg2, arg3) {
	    this._redirectable.emit(event, arg1, arg2, arg3);
	  };
	});

	// Error types with codes
	var InvalidUrlError = createErrorType(
	  "ERR_INVALID_URL",
	  "Invalid URL",
	  TypeError
	);
	var RedirectionError = createErrorType(
	  "ERR_FR_REDIRECTION_FAILURE",
	  "Redirected request failed"
	);
	var TooManyRedirectsError = createErrorType(
	  "ERR_FR_TOO_MANY_REDIRECTS",
	  "Maximum number of redirects exceeded",
	  RedirectionError
	);
	var MaxBodyLengthExceededError = createErrorType(
	  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
	  "Request body larger than maxBodyLength limit"
	);
	var WriteAfterEndError = createErrorType(
	  "ERR_STREAM_WRITE_AFTER_END",
	  "write after end"
	);

	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop;

	// An HTTP(S) request that can be redirected
	function RedirectableRequest(options, responseCallback) {
	  // Initialize the request
	  Writable.call(this);
	  this._sanitizeOptions(options);
	  this._options = options;
	  this._ended = false;
	  this._ending = false;
	  this._redirectCount = 0;
	  this._redirects = [];
	  this._requestBodyLength = 0;
	  this._requestBodyBuffers = [];

	  // Attach a callback if passed
	  if (responseCallback) {
	    this.on("response", responseCallback);
	  }

	  // React to responses of native requests
	  var self = this;
	  this._onNativeResponse = function (response) {
	    try {
	      self._processResponse(response);
	    }
	    catch (cause) {
	      self.emit("error", cause instanceof RedirectionError ?
	        cause : new RedirectionError({ cause: cause }));
	    }
	  };

	  // Perform the first request
	  this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);

	RedirectableRequest.prototype.abort = function () {
	  destroyRequest(this._currentRequest);
	  this._currentRequest.abort();
	  this.emit("abort");
	};

	RedirectableRequest.prototype.destroy = function (error) {
	  destroyRequest(this._currentRequest, error);
	  destroy.call(this, error);
	  return this;
	};

	// Writes buffered data to the current native request
	RedirectableRequest.prototype.write = function (data, encoding, callback) {
	  // Writing is not allowed if end has been called
	  if (this._ending) {
	    throw new WriteAfterEndError();
	  }

	  // Validate input and shift parameters if necessary
	  if (!isString(data) && !isBuffer(data)) {
	    throw new TypeError("data should be a string, Buffer or Uint8Array");
	  }
	  if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Ignore empty buffers, since writing them doesn't invoke the callback
	  // https://github.com/nodejs/node/issues/22066
	  if (data.length === 0) {
	    if (callback) {
	      callback();
	    }
	    return;
	  }
	  // Only write when we don't exceed the maximum body length
	  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
	    this._requestBodyLength += data.length;
	    this._requestBodyBuffers.push({ data: data, encoding: encoding });
	    this._currentRequest.write(data, encoding, callback);
	  }
	  // Error when we exceed the maximum body length
	  else {
	    this.emit("error", new MaxBodyLengthExceededError());
	    this.abort();
	  }
	};

	// Ends the current native request
	RedirectableRequest.prototype.end = function (data, encoding, callback) {
	  // Shift parameters if necessary
	  if (isFunction(data)) {
	    callback = data;
	    data = encoding = null;
	  }
	  else if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Write data if needed and end
	  if (!data) {
	    this._ended = this._ending = true;
	    this._currentRequest.end(null, null, callback);
	  }
	  else {
	    var self = this;
	    var currentRequest = this._currentRequest;
	    this.write(data, encoding, function () {
	      self._ended = true;
	      currentRequest.end(null, null, callback);
	    });
	    this._ending = true;
	  }
	};

	// Sets a header value on the current native request
	RedirectableRequest.prototype.setHeader = function (name, value) {
	  this._options.headers[name] = value;
	  this._currentRequest.setHeader(name, value);
	};

	// Clears a header value on the current native request
	RedirectableRequest.prototype.removeHeader = function (name) {
	  delete this._options.headers[name];
	  this._currentRequest.removeHeader(name);
	};

	// Global timeout for all underlying requests
	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
	  var self = this;

	  // Destroys the socket on timeout
	  function destroyOnTimeout(socket) {
	    socket.setTimeout(msecs);
	    socket.removeListener("timeout", socket.destroy);
	    socket.addListener("timeout", socket.destroy);
	  }

	  // Sets up a timer to trigger a timeout event
	  function startTimer(socket) {
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	    }
	    self._timeout = setTimeout(function () {
	      self.emit("timeout");
	      clearTimer();
	    }, msecs);
	    destroyOnTimeout(socket);
	  }

	  // Stops a timeout from triggering
	  function clearTimer() {
	    // Clear the timeout
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	      self._timeout = null;
	    }

	    // Clean up all attached listeners
	    self.removeListener("abort", clearTimer);
	    self.removeListener("error", clearTimer);
	    self.removeListener("response", clearTimer);
	    self.removeListener("close", clearTimer);
	    if (callback) {
	      self.removeListener("timeout", callback);
	    }
	    if (!self.socket) {
	      self._currentRequest.removeListener("socket", startTimer);
	    }
	  }

	  // Attach callback if passed
	  if (callback) {
	    this.on("timeout", callback);
	  }

	  // Start the timer if or when the socket is opened
	  if (this.socket) {
	    startTimer(this.socket);
	  }
	  else {
	    this._currentRequest.once("socket", startTimer);
	  }

	  // Clean up on events
	  this.on("socket", destroyOnTimeout);
	  this.on("abort", clearTimer);
	  this.on("error", clearTimer);
	  this.on("response", clearTimer);
	  this.on("close", clearTimer);

	  return this;
	};

	// Proxy all other public ClientRequest methods
	[
	  "flushHeaders", "getHeader",
	  "setNoDelay", "setSocketKeepAlive",
	].forEach(function (method) {
	  RedirectableRequest.prototype[method] = function (a, b) {
	    return this._currentRequest[method](a, b);
	  };
	});

	// Proxy all public ClientRequest properties
	["aborted", "connection", "socket"].forEach(function (property) {
	  Object.defineProperty(RedirectableRequest.prototype, property, {
	    get: function () { return this._currentRequest[property]; },
	  });
	});

	RedirectableRequest.prototype._sanitizeOptions = function (options) {
	  // Ensure headers are always present
	  if (!options.headers) {
	    options.headers = {};
	  }

	  // Since http.request treats host as an alias of hostname,
	  // but the url module interprets host as hostname plus port,
	  // eliminate the host property to avoid confusion.
	  if (options.host) {
	    // Use hostname if set, because it has precedence
	    if (!options.hostname) {
	      options.hostname = options.host;
	    }
	    delete options.host;
	  }

	  // Complete the URL object when necessary
	  if (!options.pathname && options.path) {
	    var searchPos = options.path.indexOf("?");
	    if (searchPos < 0) {
	      options.pathname = options.path;
	    }
	    else {
	      options.pathname = options.path.substring(0, searchPos);
	      options.search = options.path.substring(searchPos);
	    }
	  }
	};


	// Executes the next native request (initial or redirect)
	RedirectableRequest.prototype._performRequest = function () {
	  // Load the native protocol
	  var protocol = this._options.protocol;
	  var nativeProtocol = this._options.nativeProtocols[protocol];
	  if (!nativeProtocol) {
	    throw new TypeError("Unsupported protocol " + protocol);
	  }

	  // If specified, use the agent corresponding to the protocol
	  // (HTTP and HTTPS use different types of agents)
	  if (this._options.agents) {
	    var scheme = protocol.slice(0, -1);
	    this._options.agent = this._options.agents[scheme];
	  }

	  // Create the native request and set up its event handlers
	  var request = this._currentRequest =
	        nativeProtocol.request(this._options, this._onNativeResponse);
	  request._redirectable = this;
	  for (var event of events) {
	    request.on(event, eventHandlers[event]);
	  }

	  // RFC7230§5.3.1: When making a request directly to an origin server, […]
	  // a client MUST send only the absolute path […] as the request-target.
	  this._currentUrl = /^\//.test(this._options.path) ?
	    url.format(this._options) :
	    // When making a request to a proxy, […]
	    // a client MUST send the target URI in absolute-form […].
	    this._options.path;

	  // End a redirected request
	  // (The first request must be ended explicitly with RedirectableRequest#end)
	  if (this._isRedirect) {
	    // Write the request entity and end
	    var i = 0;
	    var self = this;
	    var buffers = this._requestBodyBuffers;
	    (function writeNext(error) {
	      // Only write if this request has not been redirected yet
	      /* istanbul ignore else */
	      if (request === self._currentRequest) {
	        // Report any write errors
	        /* istanbul ignore if */
	        if (error) {
	          self.emit("error", error);
	        }
	        // Write the next buffer if there are still left
	        else if (i < buffers.length) {
	          var buffer = buffers[i++];
	          /* istanbul ignore else */
	          if (!request.finished) {
	            request.write(buffer.data, buffer.encoding, writeNext);
	          }
	        }
	        // End the request if `end` has been called on us
	        else if (self._ended) {
	          request.end();
	        }
	      }
	    }());
	  }
	};

	// Processes a response from the current native request
	RedirectableRequest.prototype._processResponse = function (response) {
	  // Store the redirected response
	  var statusCode = response.statusCode;
	  if (this._options.trackRedirects) {
	    this._redirects.push({
	      url: this._currentUrl,
	      headers: response.headers,
	      statusCode: statusCode,
	    });
	  }

	  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
	  // that further action needs to be taken by the user agent in order to
	  // fulfill the request. If a Location header field is provided,
	  // the user agent MAY automatically redirect its request to the URI
	  // referenced by the Location field value,
	  // even if the specific status code is not understood.

	  // If the response is not a redirect; return it as-is
	  var location = response.headers.location;
	  if (!location || this._options.followRedirects === false ||
	      statusCode < 300 || statusCode >= 400) {
	    response.responseUrl = this._currentUrl;
	    response.redirects = this._redirects;
	    this.emit("response", response);

	    // Clean up
	    this._requestBodyBuffers = [];
	    return;
	  }

	  // The response is a redirect, so abort the current request
	  destroyRequest(this._currentRequest);
	  // Discard the remainder of the response to avoid waiting for data
	  response.destroy();

	  // RFC7231§6.4: A client SHOULD detect and intervene
	  // in cyclical redirections (i.e., "infinite" redirection loops).
	  if (++this._redirectCount > this._options.maxRedirects) {
	    throw new TooManyRedirectsError();
	  }

	  // Store the request headers if applicable
	  var requestHeaders;
	  var beforeRedirect = this._options.beforeRedirect;
	  if (beforeRedirect) {
	    requestHeaders = Object.assign({
	      // The Host header was set by nativeProtocol.request
	      Host: response.req.getHeader("host"),
	    }, this._options.headers);
	  }

	  // RFC7231§6.4: Automatic redirection needs to done with
	  // care for methods not known to be safe, […]
	  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
	  // the request method from POST to GET for the subsequent request.
	  var method = this._options.method;
	  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
	      // RFC7231§6.4.4: The 303 (See Other) status code indicates that
	      // the server is redirecting the user agent to a different resource […]
	      // A user agent can perform a retrieval request targeting that URI
	      // (a GET or HEAD request if using HTTP) […]
	      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
	    this._options.method = "GET";
	    // Drop a possible entity and headers related to it
	    this._requestBodyBuffers = [];
	    removeMatchingHeaders(/^content-/i, this._options.headers);
	  }

	  // Drop the Host header, as the redirect might lead to a different host
	  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

	  // If the redirect is relative, carry over the host of the last request
	  var currentUrlParts = parseUrl(this._currentUrl);
	  var currentHost = currentHostHeader || currentUrlParts.host;
	  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
	    url.format(Object.assign(currentUrlParts, { host: currentHost }));

	  // Create the redirected request
	  var redirectUrl = resolveUrl(location, currentUrl);
	  debug("redirecting to", redirectUrl.href);
	  this._isRedirect = true;
	  spreadUrlObject(redirectUrl, this._options);

	  // Drop confidential headers when redirecting to a less secure protocol
	  // or to a different domain that is not a superdomain
	  if (redirectUrl.protocol !== currentUrlParts.protocol &&
	     redirectUrl.protocol !== "https:" ||
	     redirectUrl.host !== currentHost &&
	     !isSubdomain(redirectUrl.host, currentHost)) {
	    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
	  }

	  // Evaluate the beforeRedirect callback
	  if (isFunction(beforeRedirect)) {
	    var responseDetails = {
	      headers: response.headers,
	      statusCode: statusCode,
	    };
	    var requestDetails = {
	      url: currentUrl,
	      method: method,
	      headers: requestHeaders,
	    };
	    beforeRedirect(this._options, responseDetails, requestDetails);
	    this._sanitizeOptions(this._options);
	  }

	  // Perform the redirected request
	  this._performRequest();
	};

	// Wraps the key/value object of protocols with redirect functionality
	function wrap(protocols) {
	  // Default settings
	  var exports = {
	    maxRedirects: 21,
	    maxBodyLength: 10 * 1024 * 1024,
	  };

	  // Wrap each protocol
	  var nativeProtocols = {};
	  Object.keys(protocols).forEach(function (scheme) {
	    var protocol = scheme + ":";
	    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
	    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

	    // Executes a request, following redirects
	    function request(input, options, callback) {
	      // Parse parameters, ensuring that input is an object
	      if (isURL(input)) {
	        input = spreadUrlObject(input);
	      }
	      else if (isString(input)) {
	        input = spreadUrlObject(parseUrl(input));
	      }
	      else {
	        callback = options;
	        options = validateUrl(input);
	        input = { protocol: protocol };
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }

	      // Set defaults
	      options = Object.assign({
	        maxRedirects: exports.maxRedirects,
	        maxBodyLength: exports.maxBodyLength,
	      }, input, options);
	      options.nativeProtocols = nativeProtocols;
	      if (!isString(options.host) && !isString(options.hostname)) {
	        options.hostname = "::1";
	      }

	      assert.equal(options.protocol, protocol, "protocol mismatch");
	      debug("options", options);
	      return new RedirectableRequest(options, callback);
	    }

	    // Executes a GET request, following redirects
	    function get(input, options, callback) {
	      var wrappedRequest = wrappedProtocol.request(input, options, callback);
	      wrappedRequest.end();
	      return wrappedRequest;
	    }

	    // Expose the properties on the wrapped protocol
	    Object.defineProperties(wrappedProtocol, {
	      request: { value: request, configurable: true, enumerable: true, writable: true },
	      get: { value: get, configurable: true, enumerable: true, writable: true },
	    });
	  });
	  return exports;
	}

	function noop() { /* empty */ }

	function parseUrl(input) {
	  var parsed;
	  /* istanbul ignore else */
	  if (useNativeURL) {
	    parsed = new URL(input);
	  }
	  else {
	    // Ensure the URL is valid and absolute
	    parsed = validateUrl(url.parse(input));
	    if (!isString(parsed.protocol)) {
	      throw new InvalidUrlError({ input });
	    }
	  }
	  return parsed;
	}

	function resolveUrl(relative, base) {
	  /* istanbul ignore next */
	  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
	}

	function validateUrl(input) {
	  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  return input;
	}

	function spreadUrlObject(urlObject, target) {
	  var spread = target || {};
	  for (var key of preservedUrlFields) {
	    spread[key] = urlObject[key];
	  }

	  // Fix IPv6 hostname
	  if (spread.hostname.startsWith("[")) {
	    spread.hostname = spread.hostname.slice(1, -1);
	  }
	  // Ensure port is a number
	  if (spread.port !== "") {
	    spread.port = Number(spread.port);
	  }
	  // Concatenate path
	  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

	  return spread;
	}

	function removeMatchingHeaders(regex, headers) {
	  var lastValue;
	  for (var header in headers) {
	    if (regex.test(header)) {
	      lastValue = headers[header];
	      delete headers[header];
	    }
	  }
	  return (lastValue === null || typeof lastValue === "undefined") ?
	    undefined : String(lastValue).trim();
	}

	function createErrorType(code, message, baseClass) {
	  // Create constructor
	  function CustomError(properties) {
	    Error.captureStackTrace(this, this.constructor);
	    Object.assign(this, properties || {});
	    this.code = code;
	    this.message = this.cause ? message + ": " + this.cause.message : message;
	  }

	  // Attach constructor and set default properties
	  CustomError.prototype = new (baseClass || Error)();
	  Object.defineProperties(CustomError.prototype, {
	    constructor: {
	      value: CustomError,
	      enumerable: false,
	    },
	    name: {
	      value: "Error [" + code + "]",
	      enumerable: false,
	    },
	  });
	  return CustomError;
	}

	function destroyRequest(request, error) {
	  for (var event of events) {
	    request.removeListener(event, eventHandlers[event]);
	  }
	  request.on("error", noop);
	  request.destroy(error);
	}

	function isSubdomain(subdomain, domain) {
	  assert(isString(subdomain) && isString(domain));
	  var dot = subdomain.length - domain.length - 1;
	  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}

	function isString(value) {
	  return typeof value === "string" || value instanceof String;
	}

	function isFunction(value) {
	  return typeof value === "function";
	}

	function isBuffer(value) {
	  return typeof value === "object" && ("length" in value);
	}

	function isURL(value) {
	  return URL && value instanceof URL;
	}

	// Exports
	followRedirects.exports = wrap({ http: http, https: https });
	followRedirects.exports.wrap = wrap;
	return followRedirects.exports;
}

var data;
var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;
	data = {
	  "version": "0.27.2"
	};
	return data;
}

var http_1;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http_1;
	hasRequiredHttp = 1;

	var utils = utils$s;
	var settle = requireSettle();
	var buildFullPath = buildFullPath$1;
	var buildURL = buildURL$1;
	var http = require$$1$6;
	var https = require$$1$7;
	var httpFollow = requireFollowRedirects().http;
	var httpsFollow = requireFollowRedirects().https;
	var url = Url;
	var zlib$1 = zlib;
	var VERSION = requireData().version;
	var transitionalDefaults = transitional;
	var AxiosError = requireAxiosError();
	var CanceledError = requireCanceledError();

	var isHttps = /https:?/;

	var supportedProtocols = [ 'http:', 'https:', 'file:' ];

	/**
	 *
	 * @param {http.ClientRequestArgs} options
	 * @param {AxiosProxyConfig} proxy
	 * @param {string} location
	 */
	function setProxy(options, proxy, location) {
	  options.hostname = proxy.host;
	  options.host = proxy.host;
	  options.port = proxy.port;
	  options.path = location;

	  // Basic proxy authorization
	  if (proxy.auth) {
	    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
	    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
	  }

	  // If a proxy is used, any redirects must also pass through the proxy
	  options.beforeRedirect = function beforeRedirect(redirection) {
	    redirection.headers.host = redirection.host;
	    setProxy(redirection, proxy, redirection.href);
	  };
	}

	/*eslint consistent-return:0*/
	http_1 = function httpAdapter(config) {
	  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
	    var onCanceled;
	    function done() {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(onCanceled);
	      }

	      if (config.signal) {
	        config.signal.removeEventListener('abort', onCanceled);
	      }
	    }
	    var resolve = function resolve(value) {
	      done();
	      resolvePromise(value);
	    };
	    var rejected = false;
	    var reject = function reject(value) {
	      done();
	      rejected = true;
	      rejectPromise(value);
	    };
	    var data = config.data;
	    var headers = config.headers;
	    var headerNames = {};

	    Object.keys(headers).forEach(function storeLowerName(name) {
	      headerNames[name.toLowerCase()] = name;
	    });

	    // Set User-Agent (required by some servers)
	    // See https://github.com/axios/axios/issues/69
	    if ('user-agent' in headerNames) {
	      // User-Agent is specified; handle case where no UA header is desired
	      if (!headers[headerNames['user-agent']]) {
	        delete headers[headerNames['user-agent']];
	      }
	      // Otherwise, use specified value
	    } else {
	      // Only set header if it hasn't been set in config
	      headers['User-Agent'] = 'axios/' + VERSION;
	    }

	    // support for https://www.npmjs.com/package/form-data api
	    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
	      Object.assign(headers, data.getHeaders());
	    } else if (data && !utils.isStream(data)) {
	      if (Buffer.isBuffer(data)) ; else if (utils.isArrayBuffer(data)) {
	        data = Buffer.from(new Uint8Array(data));
	      } else if (utils.isString(data)) {
	        data = Buffer.from(data, 'utf-8');
	      } else {
	        return reject(new AxiosError(
	          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
	          AxiosError.ERR_BAD_REQUEST,
	          config
	        ));
	      }

	      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
	        return reject(new AxiosError(
	          'Request body larger than maxBodyLength limit',
	          AxiosError.ERR_BAD_REQUEST,
	          config
	        ));
	      }

	      // Add Content-Length header if data exists
	      if (!headerNames['content-length']) {
	        headers['Content-Length'] = data.length;
	      }
	    }

	    // HTTP basic authentication
	    var auth = undefined;
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      auth = username + ':' + password;
	    }

	    // Parse url
	    var fullPath = buildFullPath(config.baseURL, config.url);
	    var parsed = url.parse(fullPath);
	    var protocol = parsed.protocol || supportedProtocols[0];

	    if (supportedProtocols.indexOf(protocol) === -1) {
	      return reject(new AxiosError(
	        'Unsupported protocol ' + protocol,
	        AxiosError.ERR_BAD_REQUEST,
	        config
	      ));
	    }

	    if (!auth && parsed.auth) {
	      var urlAuth = parsed.auth.split(':');
	      var urlUsername = urlAuth[0] || '';
	      var urlPassword = urlAuth[1] || '';
	      auth = urlUsername + ':' + urlPassword;
	    }

	    if (auth && headerNames.authorization) {
	      delete headers[headerNames.authorization];
	    }

	    var isHttpsRequest = isHttps.test(protocol);
	    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

	    try {
	      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, '');
	    } catch (err) {
	      var customErr = new Error(err.message);
	      customErr.config = config;
	      customErr.url = config.url;
	      customErr.exists = true;
	      reject(customErr);
	    }

	    var options = {
	      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
	      method: config.method.toUpperCase(),
	      headers: headers,
	      agent: agent,
	      agents: { http: config.httpAgent, https: config.httpsAgent },
	      auth: auth
	    };

	    if (config.socketPath) {
	      options.socketPath = config.socketPath;
	    } else {
	      options.hostname = parsed.hostname;
	      options.port = parsed.port;
	    }

	    var proxy = config.proxy;
	    if (!proxy && proxy !== false) {
	      var proxyEnv = protocol.slice(0, -1) + '_proxy';
	      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
	      if (proxyUrl) {
	        var parsedProxyUrl = url.parse(proxyUrl);
	        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
	        var shouldProxy = true;

	        if (noProxyEnv) {
	          var noProxy = noProxyEnv.split(',').map(function trim(s) {
	            return s.trim();
	          });

	          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
	            if (!proxyElement) {
	              return false;
	            }
	            if (proxyElement === '*') {
	              return true;
	            }
	            if (proxyElement[0] === '.' &&
	                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
	              return true;
	            }

	            return parsed.hostname === proxyElement;
	          });
	        }

	        if (shouldProxy) {
	          proxy = {
	            host: parsedProxyUrl.hostname,
	            port: parsedProxyUrl.port,
	            protocol: parsedProxyUrl.protocol
	          };

	          if (parsedProxyUrl.auth) {
	            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
	            proxy.auth = {
	              username: proxyUrlAuth[0],
	              password: proxyUrlAuth[1]
	            };
	          }
	        }
	      }
	    }

	    if (proxy) {
	      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
	      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
	    }

	    var transport;
	    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
	    if (config.transport) {
	      transport = config.transport;
	    } else if (config.maxRedirects === 0) {
	      transport = isHttpsProxy ? https : http;
	    } else {
	      if (config.maxRedirects) {
	        options.maxRedirects = config.maxRedirects;
	      }
	      if (config.beforeRedirect) {
	        options.beforeRedirect = config.beforeRedirect;
	      }
	      transport = isHttpsProxy ? httpsFollow : httpFollow;
	    }

	    if (config.maxBodyLength > -1) {
	      options.maxBodyLength = config.maxBodyLength;
	    }

	    if (config.insecureHTTPParser) {
	      options.insecureHTTPParser = config.insecureHTTPParser;
	    }

	    // Create the request
	    var req = transport.request(options, function handleResponse(res) {
	      if (req.aborted) return;

	      // uncompress the response body transparently if required
	      var stream = res;

	      // return the last request in case of redirects
	      var lastRequest = res.req || req;


	      // if no content, is HEAD request or decompress disabled we should not decompress
	      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
	        switch (res.headers['content-encoding']) {
	        /*eslint default-case:0*/
	        case 'gzip':
	        case 'compress':
	        case 'deflate':
	        // add the unzipper to the body stream processing pipeline
	          stream = stream.pipe(zlib$1.createUnzip());

	          // remove the content-encoding in order to not confuse downstream operations
	          delete res.headers['content-encoding'];
	          break;
	        }
	      }

	      var response = {
	        status: res.statusCode,
	        statusText: res.statusMessage,
	        headers: res.headers,
	        config: config,
	        request: lastRequest
	      };

	      if (config.responseType === 'stream') {
	        response.data = stream;
	        settle(resolve, reject, response);
	      } else {
	        var responseBuffer = [];
	        var totalResponseBytes = 0;
	        stream.on('data', function handleStreamData(chunk) {
	          responseBuffer.push(chunk);
	          totalResponseBytes += chunk.length;

	          // make sure the content length is not over the maxContentLength if specified
	          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
	            // stream.destoy() emit aborted event before calling reject() on Node.js v16
	            rejected = true;
	            stream.destroy();
	            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
	              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
	          }
	        });

	        stream.on('aborted', function handlerStreamAborted() {
	          if (rejected) {
	            return;
	          }
	          stream.destroy();
	          reject(new AxiosError(
	            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
	            AxiosError.ERR_BAD_RESPONSE,
	            config,
	            lastRequest
	          ));
	        });

	        stream.on('error', function handleStreamError(err) {
	          if (req.aborted) return;
	          reject(AxiosError.from(err, null, config, lastRequest));
	        });

	        stream.on('end', function handleStreamEnd() {
	          try {
	            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
	            if (config.responseType !== 'arraybuffer') {
	              responseData = responseData.toString(config.responseEncoding);
	              if (!config.responseEncoding || config.responseEncoding === 'utf8') {
	                responseData = utils.stripBOM(responseData);
	              }
	            }
	            response.data = responseData;
	          } catch (err) {
	            reject(AxiosError.from(err, null, config, response.request, response));
	          }
	          settle(resolve, reject, response);
	        });
	      }
	    });

	    // Handle errors
	    req.on('error', function handleRequestError(err) {
	      // @todo remove
	      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
	      reject(AxiosError.from(err, null, config, req));
	    });

	    // set tcp keep alive to prevent drop connection by peer
	    req.on('socket', function handleRequestSocket(socket) {
	      // default interval of sending ack packet is 1 minute
	      socket.setKeepAlive(true, 1000 * 60);
	    });

	    // Handle request timeout
	    if (config.timeout) {
	      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
	      var timeout = parseInt(config.timeout, 10);

	      if (isNaN(timeout)) {
	        reject(new AxiosError(
	          'error trying to parse `config.timeout` to int',
	          AxiosError.ERR_BAD_OPTION_VALUE,
	          config,
	          req
	        ));

	        return;
	      }

	      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
	      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
	      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
	      // And then these socket which be hang up will devoring CPU little by little.
	      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
	      req.setTimeout(timeout, function handleRequestTimeout() {
	        req.abort();
	        var transitional = config.transitional || transitionalDefaults;
	        reject(new AxiosError(
	          'timeout of ' + timeout + 'ms exceeded',
	          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	          config,
	          req
	        ));
	      });
	    }

	    if (config.cancelToken || config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = function(cancel) {
	        if (req.aborted) return;

	        req.abort();
	        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
	      };

	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	      if (config.signal) {
	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	      }
	    }


	    // Send the request
	    if (utils.isStream(data)) {
	      data.on('error', function handleStreamError(err) {
	        reject(AxiosError.from(err, config, null, req));
	      }).pipe(req);
	    } else {
	      req.end(data);
	    }
	  });
	};
	return http_1;
}

var FormData$1;
var hasRequiredFormData;

function requireFormData () {
	if (hasRequiredFormData) return FormData$1;
	hasRequiredFormData = 1;
	// eslint-disable-next-line strict
	FormData$1 = form_data;
	return FormData$1;
}

var utils$o = utils$s;
var normalizeHeaderName = normalizeHeaderName$1;
var AxiosError$1 = requireAxiosError();
var transitionalDefaults = transitional;
var toFormData = requireToFormData();

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils$o.isUndefined(headers) && utils$o.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = requireXhr();
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = requireHttp();
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils$o.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$o.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults$3 = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils$o.isFormData(data) ||
      utils$o.isArrayBuffer(data) ||
      utils$o.isBuffer(data) ||
      utils$o.isStream(data) ||
      utils$o.isFile(data) ||
      utils$o.isBlob(data)
    ) {
      return data;
    }
    if (utils$o.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$o.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils$o.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils$o.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils$o.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: requireFormData()
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils$o.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});

utils$o.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$o.merge(DEFAULT_CONTENT_TYPE);
});

var defaults_1 = defaults$3;

var utils$n = utils$s;
var defaults$2 = defaults_1;

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
var transformData$1 = function transformData(data, headers, fns) {
  var context = this || defaults$2;
  /*eslint no-param-reassign:0*/
  utils$n.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

var isCancel$1;
var hasRequiredIsCancel;

function requireIsCancel () {
	if (hasRequiredIsCancel) return isCancel$1;
	hasRequiredIsCancel = 1;

	isCancel$1 = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};
	return isCancel$1;
}

var utils$m = utils$s;
var transformData = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
var CanceledError = requireCanceledError();

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils$m.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils$m.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults$1.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

var utils$l = utils$s;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
var mergeConfig$2 = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils$l.isPlainObject(target) && utils$l.isPlainObject(source)) {
      return utils$l.merge(target, source);
    } else if (utils$l.isPlainObject(source)) {
      return utils$l.merge({}, source);
    } else if (utils$l.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils$l.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$l.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils$l.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils$l.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils$l.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils$l.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils$l.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

var VERSION = requireData().version;
var AxiosError = requireAxiosError();

var validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator$1 = {
  assertOptions: assertOptions,
  validators: validators$1
};

var utils$k = utils$s;
var buildURL = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath = buildFullPath$1;
var validator = validator$1;

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios$1.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig$1(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils$k.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils$k.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios$1.prototype[method] = generateHTTPMethod();

  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios_1 = Axios$1;

var CancelToken_1;
var hasRequiredCancelToken;

function requireCancelToken () {
	if (hasRequiredCancelToken) return CancelToken_1;
	hasRequiredCancelToken = 1;

	var CanceledError = requireCanceledError();

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;

	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;

	  // eslint-disable-next-line func-names
	  this.promise.then(function(cancel) {
	    if (!token._listeners) return;

	    var i;
	    var l = token._listeners.length;

	    for (i = 0; i < l; i++) {
	      token._listeners[i](cancel);
	    }
	    token._listeners = null;
	  });

	  // eslint-disable-next-line func-names
	  this.promise.then = function(onfulfilled) {
	    var _resolve;
	    // eslint-disable-next-line func-names
	    var promise = new Promise(function(resolve) {
	      token.subscribe(resolve);
	      _resolve = resolve;
	    }).then(onfulfilled);

	    promise.cancel = function reject() {
	      token.unsubscribe(_resolve);
	    };

	    return promise;
	  };

	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new CanceledError(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Subscribe to the cancel signal
	 */

	CancelToken.prototype.subscribe = function subscribe(listener) {
	  if (this.reason) {
	    listener(this.reason);
	    return;
	  }

	  if (this._listeners) {
	    this._listeners.push(listener);
	  } else {
	    this._listeners = [listener];
	  }
	};

	/**
	 * Unsubscribe from the cancel signal
	 */

	CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
	  if (!this._listeners) {
	    return;
	  }
	  var index = this._listeners.indexOf(listener);
	  if (index !== -1) {
	    this._listeners.splice(index, 1);
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	CancelToken_1 = CancelToken;
	return CancelToken_1;
}

var spread;
var hasRequiredSpread;

function requireSpread () {
	if (hasRequiredSpread) return spread;
	hasRequiredSpread = 1;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};
	return spread;
}

var isAxiosError;
var hasRequiredIsAxiosError;

function requireIsAxiosError () {
	if (hasRequiredIsAxiosError) return isAxiosError;
	hasRequiredIsAxiosError = 1;

	var utils = utils$s;

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	isAxiosError = function isAxiosError(payload) {
	  return utils.isObject(payload) && (payload.isAxiosError === true);
	};
	return isAxiosError;
}

var utils$j = utils$s;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = defaults_1;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils$j.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils$j.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios$1 = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios$1.Axios = Axios;

// Expose Cancel & CancelToken
axios$1.CanceledError = requireCanceledError();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.VERSION = requireData().version;
axios$1.toFormData = requireToFormData();

// Expose AxiosError class
axios$1.AxiosError = requireAxiosError();

// alias for CanceledError for backward compatibility
axios$1.Cancel = axios$1.CanceledError;

// Expose all/spread
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = requireSpread();

// Expose isAxiosError
axios$1.isAxiosError = requireIsAxiosError();

axios$2.exports = axios$1;

// Allow use of default import syntax in TypeScript
axios$2.exports.default = axios$1;

var axiosExports = axios$2.exports;

var axios = axiosExports;

var __importDefault$Y = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(service, "__esModule", { value: true });
service.SafeService = void 0;
const bignumber_1$8 = require$$0$7;
const axios_1 = __importDefault$Y(axios);
class SafeService {
    constructor(serviceUrl, network) {
        this.serviceUrl = serviceUrl;
        this.network = network !== null && network !== void 0 ? network : axios_1.default;
    }
    /**
     * Estimates a Safe transaction
     *
     * @param safe - Address of the Safe for which this transaction should be estimated
     * @param safeTx - Safe transaction that should be estimated for execution
     * @returns A big number representing the safeTxGas for the passed Safe transaction
     */
    async estimateSafeTx(safe, safeTx) {
        const url = `${this.serviceUrl}/api/v1/safes/${safe}/multisig-transactions/estimations/`;
        const resp = await this.network.post(url, safeTx);
        return bignumber_1$8.BigNumber.from(resp.data.safeTxGas);
    }
    /**
     * Load details for a Safe transaction
     *
     * @param safeTxHash - Hash of the Safe transaction
     * @returns A `SafeTxDetails` object that contains the details of a Safe transaction
     */
    async getSafeTxDetails(safeTxHash) {
        const url = `${this.serviceUrl}/api/v1/multisig-transactions/${safeTxHash}`;
        const resp = await this.network.get(url);
        return resp.data;
    }
    /**
     * Propose a new Safe transaction to the service
     *
     * @param safeAddress - Address of the Safe for which this transaction should be proposed
     * @param safeTxHash - Hash of the Safe transaction
     * @param safeTx - Safe transaction that should be proposed
     * @param signature - Signature of an owner or a delegate of an owner of the specified Safe to authorize the proposal
     * @returns The hash of the Safe transaction that has been proposed
     */
    async proposeTx(safeAddress, safeTxHash, safeTx, signature) {
        const url = `${this.serviceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/`;
        const data = {
            ...safeTx.data,
            contractTransactionHash: safeTxHash,
            sender: signature.signer,
            signature: signature.data
        };
        const resp = await this.network.post(url, data);
        return resp.data;
    }
}
service.SafeService = SafeService;

var signer$1 = {};

var require$$0$6 = /*@__PURE__*/getAugmentedNamespace(lib_esm$1);

var src$5 = {};

var CompatibilityFallbackHandlerContract = {};

Object.defineProperty(CompatibilityFallbackHandlerContract, "__esModule", { value: true });

var CreateCallContract = {};

Object.defineProperty(CreateCallContract, "__esModule", { value: true });

var GnosisSafeContract = {};

Object.defineProperty(GnosisSafeContract, "__esModule", { value: true });

var GnosisSafeProxyFactoryContract = {};

Object.defineProperty(GnosisSafeProxyFactoryContract, "__esModule", { value: true });

var MultiSendCallOnlyContract = {};

Object.defineProperty(MultiSendCallOnlyContract, "__esModule", { value: true });

var MultiSendContract = {};

Object.defineProperty(MultiSendContract, "__esModule", { value: true });

var SignMessageLibContract = {};

Object.defineProperty(SignMessageLibContract, "__esModule", { value: true });

var EthAdapter = {};

Object.defineProperty(EthAdapter, "__esModule", { value: true });

var types$6 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OperationType = void 0;
	(function (OperationType) {
	    OperationType[OperationType["Call"] = 0] = "Call";
	    OperationType[OperationType["DelegateCall"] = 1] = "DelegateCall"; // 1
	})(exports.OperationType || (exports.OperationType = {}));
	
} (types$6));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(CompatibilityFallbackHandlerContract, exports);
	__exportStar(CreateCallContract, exports);
	__exportStar(GnosisSafeContract, exports);
	__exportStar(GnosisSafeProxyFactoryContract, exports);
	__exportStar(MultiSendCallOnlyContract, exports);
	__exportStar(MultiSendContract, exports);
	__exportStar(SignMessageLibContract, exports);
	__exportStar(EthAdapter, exports);
	__exportStar(types$6, exports);
	
} (src$5));

var utils$i = {};

var dist$5 = {};

var types$5 = {};

Object.defineProperty(types$5, "__esModule", { value: true });

var safes = {};

var defaultAddress$o = "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762";
var released$o = true;
var contractName$o = "SafeL2";
var version$p = "1.4.1";
var networkAddresses$o = {
	"1": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"5": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"10": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"56": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"71": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"97": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"100": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"137": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"1030": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"1101": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"1442": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"4337": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"8192": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"8194": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"8453": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"10243": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"11235": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"13337": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"17000": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"42161": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"42220": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"54211": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"80001": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"84531": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"84532": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
	"11155111": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762"
};
var abi$w = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "approvedHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "ApproveHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "ChangedFallbackHandler",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "ChangedGuard",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "module",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "SafeModuleTransaction",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "additionalInfo",
				type: "bytes"
			}
		],
		name: "SafeMultiSigTransaction",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "SafeReceived",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "initiator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address[]",
				name: "owners",
				type: "address[]"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "initializer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			}
		],
		name: "SafeSetup",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		stateMutability: "nonpayable",
		type: "fallback"
	},
	{
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "requiredSignatures",
				type: "uint256"
			}
		],
		name: "checkNSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "checkSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevModule",
				type: "address"
			},
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModuleReturnData",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getChainId",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "start",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "pageSize",
				type: "uint256"
			}
		],
		name: "getModulesPaginated",
		outputs: [
			{
				internalType: "address[]",
				name: "array",
				type: "address[]"
			},
			{
				internalType: "address",
				name: "next",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "offset",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "length",
				type: "uint256"
			}
		],
		name: "getStorageAt",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "isModuleEnabled",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "setFallbackHandler",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "setGuard",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "_owners",
				type: "address[]"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			},
			{
				internalType: "address",
				name: "paymentToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			},
			{
				internalType: "address payable",
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "targetContract",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "calldataPayload",
				type: "bytes"
			}
		],
		name: "simulateAndRevert",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "oldOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		stateMutability: "payable",
		type: "receive"
	}
];
var require$$0$5 = {
	defaultAddress: defaultAddress$o,
	released: released$o,
	contractName: contractName$o,
	version: version$p,
	networkAddresses: networkAddresses$o,
	abi: abi$w
};

var defaultAddress$n = "0x41675C099F32341bf84BFc5382aF534df5C7461a";
var released$n = true;
var contractName$n = "Safe";
var version$o = "1.4.1";
var networkAddresses$n = {
	"1": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"5": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"10": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"56": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"71": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"97": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"100": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"137": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"1030": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"1101": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"1442": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"4337": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"8192": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"8194": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"8453": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"10243": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"11235": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"13337": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"17000": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"42161": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"42220": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"54211": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"80001": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"84531": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"84532": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
	"11155111": "0x41675C099F32341bf84BFc5382aF534df5C7461a"
};
var abi$v = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "approvedHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "ApproveHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "ChangedFallbackHandler",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "ChangedGuard",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "SafeReceived",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "initiator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address[]",
				name: "owners",
				type: "address[]"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "initializer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			}
		],
		name: "SafeSetup",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		stateMutability: "nonpayable",
		type: "fallback"
	},
	{
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "requiredSignatures",
				type: "uint256"
			}
		],
		name: "checkNSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "checkSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevModule",
				type: "address"
			},
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModuleReturnData",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getChainId",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "start",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "pageSize",
				type: "uint256"
			}
		],
		name: "getModulesPaginated",
		outputs: [
			{
				internalType: "address[]",
				name: "array",
				type: "address[]"
			},
			{
				internalType: "address",
				name: "next",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "offset",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "length",
				type: "uint256"
			}
		],
		name: "getStorageAt",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "isModuleEnabled",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "setFallbackHandler",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "setGuard",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "_owners",
				type: "address[]"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			},
			{
				internalType: "address",
				name: "paymentToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			},
			{
				internalType: "address payable",
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "targetContract",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "calldataPayload",
				type: "bytes"
			}
		],
		name: "simulateAndRevert",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "oldOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		stateMutability: "payable",
		type: "receive"
	}
];
var require$$1$5 = {
	defaultAddress: defaultAddress$n,
	released: released$n,
	contractName: contractName$n,
	version: version$o,
	networkAddresses: networkAddresses$n,
	abi: abi$v
};

var defaultAddress$m = "0x3E5c63644E683549055b9Be8653de26E0B4CD36E";
var released$m = true;
var contractName$m = "GnosisSafeL2";
var version$n = "1.3.0";
var networkAddresses$m = {
	"1": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"3": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"4": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"5": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"10": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"11": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"12": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"18": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"25": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"28": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"30": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"31": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"39": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"40": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"41": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"42": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"44": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"46": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"50": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"51": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"56": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"57": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"61": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"63": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"69": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"71": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"81": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"82": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"83": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"97": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"100": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"106": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"108": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"109": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"111": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"122": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"123": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"137": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"148": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"155": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"169": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"204": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"246": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"250": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"255": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"280": "0x1727c2c531cf966f902E5927b98490fDFb3b2b70",
	"288": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"291": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"300": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"321": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"322": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"324": "0x1727c2c531cf966f902E5927b98490fDFb3b2b70",
	"336": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"338": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"420": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"424": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"570": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"588": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"592": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"595": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"599": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"686": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"787": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"919": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1030": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1088": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1101": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1111": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1112": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1115": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1116": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1230": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1231": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1284": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1285": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1287": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1294": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1442": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1559": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1663": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1807": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1890": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1891": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1984": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1998": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2001": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2002": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2019": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2020": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2021": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2221": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2222": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"2358": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"3737": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"4002": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"4337": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"4460": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"4689": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"4918": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"4919": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"5000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"5001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"5003": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"5700": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"6102": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"7001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"7332": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"7341": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"7700": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"8192": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"8194": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"8217": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"8453": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"9000": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"9001": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"9728": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"10000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"10001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"10081": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"10200": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"10243": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"11235": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"11437": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"11891": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"12357": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"13337": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"17000": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"17172": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"18231": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"23294": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"23295": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"34443": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"42161": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"42170": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"42220": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"43113": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"43114": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"43288": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"44787": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"45000": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"47805": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"54211": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"56288": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"57000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"58008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"59140": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"59144": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"71401": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"71402": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"73799": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"80001": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"80085": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"84531": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"84532": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"167008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"200101": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"200202": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"333999": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"421611": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"421613": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"421614": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"534351": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"534352": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"534353": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"622277": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"713715": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"7777777": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"11155111": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"11155420": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"222000222": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"245022926": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"245022934": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"333000333": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"999999999": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1313161554": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1313161555": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"1666600000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"1666700000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
	"11297108099": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
	"11297108109": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E"
};
var abi$u = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "approvedHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "ApproveHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "ChangedFallbackHandler",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "ChangedGuard",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "module",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "SafeModuleTransaction",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "additionalInfo",
				type: "bytes"
			}
		],
		name: "SafeMultiSigTransaction",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "SafeReceived",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "initiator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address[]",
				name: "owners",
				type: "address[]"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "initializer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			}
		],
		name: "SafeSetup",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		stateMutability: "nonpayable",
		type: "fallback"
	},
	{
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "requiredSignatures",
				type: "uint256"
			}
		],
		name: "checkNSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "checkSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevModule",
				type: "address"
			},
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModuleReturnData",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getChainId",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "start",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "pageSize",
				type: "uint256"
			}
		],
		name: "getModulesPaginated",
		outputs: [
			{
				internalType: "address[]",
				name: "array",
				type: "address[]"
			},
			{
				internalType: "address",
				name: "next",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "offset",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "length",
				type: "uint256"
			}
		],
		name: "getStorageAt",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "isModuleEnabled",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "requiredTxGas",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "setFallbackHandler",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "setGuard",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "_owners",
				type: "address[]"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			},
			{
				internalType: "address",
				name: "paymentToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			},
			{
				internalType: "address payable",
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "targetContract",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "calldataPayload",
				type: "bytes"
			}
		],
		name: "simulateAndRevert",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "oldOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		stateMutability: "payable",
		type: "receive"
	}
];
var require$$2$3 = {
	defaultAddress: defaultAddress$m,
	released: released$m,
	contractName: contractName$m,
	version: version$n,
	networkAddresses: networkAddresses$m,
	abi: abi$u
};

var defaultAddress$l = "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552";
var released$l = true;
var contractName$l = "GnosisSafe";
var version$m = "1.3.0";
var networkAddresses$l = {
	"1": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"3": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"4": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"5": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"10": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"11": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"12": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"18": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"25": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"28": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"30": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"31": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"39": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"40": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"41": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"42": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"44": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"46": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"50": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"51": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"56": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"57": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"61": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"63": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"69": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"71": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"81": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"82": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"83": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"97": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"100": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"106": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"108": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"109": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"111": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"122": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"123": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"137": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"148": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"155": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"169": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"204": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"246": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"250": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"255": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"280": "0xB00ce5CCcdEf57e539ddcEd01DF43a13855d9910",
	"288": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"291": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"300": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"321": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"322": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"324": "0xB00ce5CCcdEf57e539ddcEd01DF43a13855d9910",
	"336": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"338": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"420": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"424": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"570": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"588": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"592": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"595": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"599": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"686": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"787": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"919": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1030": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1088": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1101": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1111": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1112": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1115": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1116": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1230": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1231": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1284": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1285": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1287": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1294": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1442": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1559": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1663": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1807": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1890": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1891": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1984": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1998": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2001": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2002": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2019": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2020": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2021": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2221": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2222": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"2358": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"3737": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"4002": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"4337": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"4460": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"4689": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"4918": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"4919": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"5000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"5001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"5003": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"5700": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"6102": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"7001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"7332": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"7341": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"7700": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"8192": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"8194": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"8217": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"8453": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"9000": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"9001": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"9728": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"10000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"10001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"10081": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"10200": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"10243": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"11235": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"11437": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"11891": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"12357": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"13337": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"17000": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"17172": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"18231": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"23294": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"23295": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"34443": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"42161": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"42170": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"42220": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"43113": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"43114": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"43288": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"44787": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"45000": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"47805": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"54211": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"56288": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"57000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"58008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"59140": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"59144": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"71401": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"71402": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"73799": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"80001": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"80085": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"84531": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"84532": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"167008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"200101": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"200202": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"333999": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"421611": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"421613": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"421614": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"534351": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"534352": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"534353": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"622277": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"713715": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"7777777": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"11155111": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"11155420": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"222000222": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"245022926": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"245022934": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"333000333": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"999999999": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1313161554": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1313161555": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"1666600000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"1666700000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
	"11297108099": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
	"11297108109": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552"
};
var abi$t = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "approvedHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "ApproveHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "ChangedFallbackHandler",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "ChangedGuard",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "SafeReceived",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "initiator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address[]",
				name: "owners",
				type: "address[]"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "initializer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			}
		],
		name: "SafeSetup",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		stateMutability: "nonpayable",
		type: "fallback"
	},
	{
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "requiredSignatures",
				type: "uint256"
			}
		],
		name: "checkNSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "checkSignatures",
		outputs: [
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevModule",
				type: "address"
			},
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModuleReturnData",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getChainId",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "start",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "pageSize",
				type: "uint256"
			}
		],
		name: "getModulesPaginated",
		outputs: [
			{
				internalType: "address[]",
				name: "array",
				type: "address[]"
			},
			{
				internalType: "address",
				name: "next",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "offset",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "length",
				type: "uint256"
			}
		],
		name: "getStorageAt",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "isModuleEnabled",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "requiredTxGas",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "setFallbackHandler",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "guard",
				type: "address"
			}
		],
		name: "setGuard",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "_owners",
				type: "address[]"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			},
			{
				internalType: "address",
				name: "paymentToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			},
			{
				internalType: "address payable",
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "targetContract",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "calldataPayload",
				type: "bytes"
			}
		],
		name: "simulateAndRevert",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "oldOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		stateMutability: "payable",
		type: "receive"
	}
];
var require$$3$2 = {
	defaultAddress: defaultAddress$l,
	released: released$l,
	contractName: contractName$l,
	version: version$m,
	networkAddresses: networkAddresses$l,
	abi: abi$t
};

var defaultAddress$k = "0x6851D6fDFAfD08c0295C392436245E5bc78B0185";
var released$k = true;
var contractName$k = "GnosisSafe";
var version$l = "1.2.0";
var networkAddresses$k = {
	"1": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"4": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"5": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"42": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"88": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"100": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"246": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
	"73799": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185"
};
var abi$s = [
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "approvedHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "ApproveHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "masterCopy",
				type: "address"
			}
		],
		name: "ChangedMasterCopy",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		constant: true,
		inputs: [
		],
		name: "NAME",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_masterCopy",
				type: "address"
			}
		],
		name: "changeMasterCopy",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "contract Module",
				name: "prevModule",
				type: "address"
			},
			{
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModuleReturnData",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getModules",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "start",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "pageSize",
				type: "uint256"
			}
		],
		name: "getModulesPaginated",
		outputs: [
			{
				internalType: "address[]",
				name: "array",
				type: "address[]"
			},
			{
				internalType: "address",
				name: "next",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "isModuleEnabled",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "setFallbackHandler",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "oldOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address[]",
				name: "_owners",
				type: "address[]"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			},
			{
				internalType: "address",
				name: "paymentToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			},
			{
				internalType: "address payable",
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		payable: true,
		stateMutability: "payable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "requiredTxGas",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		name: "signMessage",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$4$1 = {
	defaultAddress: defaultAddress$k,
	released: released$k,
	contractName: contractName$k,
	version: version$l,
	networkAddresses: networkAddresses$k,
	abi: abi$s
};

var defaultAddress$j = "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F";
var released$j = true;
var contractName$j = "GnosisSafe";
var version$k = "1.1.1";
var networkAddresses$j = {
	"1": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"4": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"5": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"42": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"88": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"100": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"246": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
	"73799": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F"
};
var abi$r = [
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "approvedHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "ApproveHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "masterCopy",
				type: "address"
			}
		],
		name: "ChangedMasterCopy",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleFailure",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "module",
				type: "address"
			}
		],
		name: "ExecutionFromModuleSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			}
		],
		name: "ExecutionSuccess",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		constant: true,
		inputs: [
		],
		name: "NAME",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_masterCopy",
				type: "address"
			}
		],
		name: "changeMasterCopy",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "contract Module",
				name: "prevModule",
				type: "address"
			},
			{
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "contract Module",
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModuleReturnData",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getModules",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "start",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "pageSize",
				type: "uint256"
			}
		],
		name: "getModulesPaginated",
		outputs: [
			{
				internalType: "address[]",
				name: "array",
				type: "address[]"
			},
			{
				internalType: "address",
				name: "next",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "handler",
				type: "address"
			}
		],
		name: "setFallbackHandler",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "prevOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "oldOwner",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address[]",
				name: "_owners",
				type: "address[]"
			},
			{
				internalType: "uint256",
				name: "_threshold",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "address",
				name: "fallbackHandler",
				type: "address"
			},
			{
				internalType: "address",
				name: "paymentToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "payment",
				type: "uint256"
			},
			{
				internalType: "address payable",
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address payable",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "requiredTxGas",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		name: "signMessage",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "safeTxGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "baseGas",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "gasPrice",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "gasToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "refundReceiver",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$5$1 = {
	defaultAddress: defaultAddress$j,
	released: released$j,
	contractName: contractName$j,
	version: version$k,
	networkAddresses: networkAddresses$j,
	abi: abi$r
};

var defaultAddress$i = "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A";
var released$i = true;
var contractName$i = "GnosisSafe";
var version$j = "1.0.0";
var networkAddresses$i = {
	"1": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
	"4": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
	"5": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
	"42": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
	"100": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A"
};
var abi$q = [
	{
		constant: false,
		inputs: [
			{
				name: "owner",
				type: "address"
			},
			{
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "addOwnerWithThreshold",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "DOMAIN_SEPARATOR_TYPEHASH",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "owner",
				type: "address"
			}
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "to",
				type: "address"
			},
			{
				name: "value",
				type: "uint256"
			},
			{
				name: "data",
				type: "bytes"
			},
			{
				name: "operation",
				type: "uint8"
			}
		],
		name: "execTransactionFromModule",
		outputs: [
			{
				name: "success",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "signedMessages",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "module",
				type: "address"
			}
		],
		name: "enableModule",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "changeThreshold",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "address"
			},
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "approvedHashes",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_masterCopy",
				type: "address"
			}
		],
		name: "changeMasterCopy",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "SENTINEL_MODULES",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "SENTINEL_OWNERS",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getOwners",
		outputs: [
			{
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "NAME",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "nonce",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getModules",
		outputs: [
			{
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "SAFE_MSG_TYPEHASH",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "SAFE_TX_TYPEHASH",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "prevModule",
				type: "address"
			},
			{
				name: "module",
				type: "address"
			}
		],
		name: "disableModule",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "prevOwner",
				type: "address"
			},
			{
				name: "oldOwner",
				type: "address"
			},
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "swapOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "domainSeparator",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "prevOwner",
				type: "address"
			},
			{
				name: "owner",
				type: "address"
			},
			{
				name: "_threshold",
				type: "uint256"
			}
		],
		name: "removeOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "txHash",
				type: "bytes32"
			}
		],
		name: "ExecutionFailed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "owner",
				type: "address"
			}
		],
		name: "AddedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "owner",
				type: "address"
			}
		],
		name: "RemovedOwner",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "threshold",
				type: "uint256"
			}
		],
		name: "ChangedThreshold",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "module",
				type: "address"
			}
		],
		name: "EnabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "module",
				type: "address"
			}
		],
		name: "DisabledModule",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "newContract",
				type: "address"
			}
		],
		name: "ContractCreation",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_owners",
				type: "address[]"
			},
			{
				name: "_threshold",
				type: "uint256"
			},
			{
				name: "to",
				type: "address"
			},
			{
				name: "data",
				type: "bytes"
			},
			{
				name: "paymentToken",
				type: "address"
			},
			{
				name: "payment",
				type: "uint256"
			},
			{
				name: "paymentReceiver",
				type: "address"
			}
		],
		name: "setup",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "to",
				type: "address"
			},
			{
				name: "value",
				type: "uint256"
			},
			{
				name: "data",
				type: "bytes"
			},
			{
				name: "operation",
				type: "uint8"
			},
			{
				name: "safeTxGas",
				type: "uint256"
			},
			{
				name: "baseGas",
				type: "uint256"
			},
			{
				name: "gasPrice",
				type: "uint256"
			},
			{
				name: "gasToken",
				type: "address"
			},
			{
				name: "refundReceiver",
				type: "address"
			},
			{
				name: "signatures",
				type: "bytes"
			}
		],
		name: "execTransaction",
		outputs: [
			{
				name: "success",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "to",
				type: "address"
			},
			{
				name: "value",
				type: "uint256"
			},
			{
				name: "data",
				type: "bytes"
			},
			{
				name: "operation",
				type: "uint8"
			}
		],
		name: "requiredTxGas",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "hashToApprove",
				type: "bytes32"
			}
		],
		name: "approveHash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_data",
				type: "bytes"
			}
		],
		name: "signMessage",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_data",
				type: "bytes"
			},
			{
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				name: "",
				type: "bytes4"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "to",
				type: "address"
			},
			{
				name: "value",
				type: "uint256"
			},
			{
				name: "data",
				type: "bytes"
			},
			{
				name: "operation",
				type: "uint8"
			},
			{
				name: "safeTxGas",
				type: "uint256"
			},
			{
				name: "baseGas",
				type: "uint256"
			},
			{
				name: "gasPrice",
				type: "uint256"
			},
			{
				name: "gasToken",
				type: "address"
			},
			{
				name: "refundReceiver",
				type: "address"
			},
			{
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "encodeTransactionData",
		outputs: [
			{
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "to",
				type: "address"
			},
			{
				name: "value",
				type: "uint256"
			},
			{
				name: "data",
				type: "bytes"
			},
			{
				name: "operation",
				type: "uint8"
			},
			{
				name: "safeTxGas",
				type: "uint256"
			},
			{
				name: "baseGas",
				type: "uint256"
			},
			{
				name: "gasPrice",
				type: "uint256"
			},
			{
				name: "gasToken",
				type: "address"
			},
			{
				name: "refundReceiver",
				type: "address"
			},
			{
				name: "_nonce",
				type: "uint256"
			}
		],
		name: "getTransactionHash",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$6$2 = {
	defaultAddress: defaultAddress$i,
	released: released$i,
	contractName: contractName$i,
	version: version$j,
	networkAddresses: networkAddresses$i,
	abi: abi$q
};

var utils$h = {};

var __importDefault$X = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(utils$h, "__esModule", { value: true });
utils$h.findDeployment = void 0;
const satisfies_1$1 = __importDefault$X(satisfies_1$2);
const DEFAULT_FILTER = { released: true };
const findDeployment = (criteria = DEFAULT_FILTER, deployments) => {
    const criteriaWithDefaults = Object.assign(Object.assign({}, DEFAULT_FILTER), criteria);
    return deployments.find((deployment) => {
        if (typeof criteriaWithDefaults.version !== 'undefined' && !(0, satisfies_1$1.default)(deployment.version, criteriaWithDefaults.version))
            return false;
        if (typeof criteriaWithDefaults.released === 'boolean' && deployment.released != criteriaWithDefaults.released)
            return false;
        if (criteriaWithDefaults.network && !deployment.networkAddresses[criteriaWithDefaults.network])
            return false;
        return true;
    });
};
utils$h.findDeployment = findDeployment;

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getSafeL2SingletonDeployment = exports._safeL2Deployments = exports.getSafeSingletonDeployment = exports._safeDeployments = void 0;
	const safe_l2_json_1 = __importDefault(require$$0$5);
	const safe_json_1 = __importDefault(require$$1$5);
	const gnosis_safe_l2_json_1 = __importDefault(require$$2$3);
	const gnosis_safe_json_1 = __importDefault(require$$3$2);
	const gnosis_safe_json_2 = __importDefault(require$$4$1);
	const gnosis_safe_json_3 = __importDefault(require$$5$1);
	const gnosis_safe_json_4 = __importDefault(require$$6$2);
	const utils_1 = utils$h;
	// This is a sorted array (newest to oldest), exported for tests
	exports._safeDeployments = [
	    safe_json_1.default, gnosis_safe_json_1.default, gnosis_safe_json_2.default, gnosis_safe_json_3.default, gnosis_safe_json_4.default
	];
	const getSafeSingletonDeployment = (filter) => {
	    return (0, utils_1.findDeployment)(filter, exports._safeDeployments);
	};
	exports.getSafeSingletonDeployment = getSafeSingletonDeployment;
	// This is a sorted array (newest to oldest), exported for tests
	exports._safeL2Deployments = [
	    safe_l2_json_1.default, gnosis_safe_l2_json_1.default
	];
	const getSafeL2SingletonDeployment = (filter) => {
	    return (0, utils_1.findDeployment)(filter, exports._safeL2Deployments);
	};
	exports.getSafeL2SingletonDeployment = getSafeL2SingletonDeployment; 
} (safes));

var factories = {};

var defaultAddress$h = "0x12302fE9c02ff50939BaAaaf415fc226C078613C";
var released$h = true;
var contractName$h = "ProxyFactory";
var version$i = "1.0.0";
var networkAddresses$h = {
	"1": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
	"4": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
	"5": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
	"42": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
	"100": "0x12302fE9c02ff50939BaAaaf415fc226C078613C"
};
var abi$p = [
	{
		constant: false,
		inputs: [
			{
				name: "_mastercopy",
				type: "address"
			},
			{
				name: "initializer",
				type: "bytes"
			},
			{
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "createProxyWithNonce",
		outputs: [
			{
				name: "proxy",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "proxyCreationCode",
		outputs: [
			{
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "masterCopy",
				type: "address"
			},
			{
				name: "data",
				type: "bytes"
			}
		],
		name: "createProxy",
		outputs: [
			{
				name: "proxy",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "proxyRuntimeCode",
		outputs: [
			{
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "proxy",
				type: "address"
			}
		],
		name: "ProxyCreation",
		type: "event"
	}
];
var require$$0$4 = {
	defaultAddress: defaultAddress$h,
	released: released$h,
	contractName: contractName$h,
	version: version$i,
	networkAddresses: networkAddresses$h,
	abi: abi$p
};

var defaultAddress$g = "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B";
var released$g = true;
var contractName$g = "ProxyFactory";
var version$h = "1.1.1";
var networkAddresses$g = {
	"1": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"4": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"5": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"42": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"88": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"100": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"246": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
	"73799": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B"
};
var abi$o = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		name: "ProxyCreation",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "masterCopy",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "createProxy",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "proxyRuntimeCode",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "proxyCreationCode",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_mastercopy",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "createProxyWithNonce",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_mastercopy",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			},
			{
				internalType: "contract IProxyCreationCallback",
				name: "callback",
				type: "address"
			}
		],
		name: "createProxyWithCallback",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_mastercopy",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "calculateCreateProxyWithNonceAddress",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$4 = {
	defaultAddress: defaultAddress$g,
	released: released$g,
	contractName: contractName$g,
	version: version$h,
	networkAddresses: networkAddresses$g,
	abi: abi$o
};

var defaultAddress$f = "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2";
var released$f = true;
var contractName$f = "GnosisSafeProxyFactory";
var version$g = "1.3.0";
var networkAddresses$f = {
	"1": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"3": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"4": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"5": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"10": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"11": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"12": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"18": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"25": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"28": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"30": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"31": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"39": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"40": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"41": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"42": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"44": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"46": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"50": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"51": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"56": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"57": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"61": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"63": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"69": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"71": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"81": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"82": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"83": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"97": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"100": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"106": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"108": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"109": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"111": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"122": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"123": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"137": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"148": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"155": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"169": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"204": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"246": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"250": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"255": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"280": "0xDAec33641865E4651fB43181C6DB6f7232Ee91c2",
	"288": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"291": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"300": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"321": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"322": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"324": "0xDAec33641865E4651fB43181C6DB6f7232Ee91c2",
	"336": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"338": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"420": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"424": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"570": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"588": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"592": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"595": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"599": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"686": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"787": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"919": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1030": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1088": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1101": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1111": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1112": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1115": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1116": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1230": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1231": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1284": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1285": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1287": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1294": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1442": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1559": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1663": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1807": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1890": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1891": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1984": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1998": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2001": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2002": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2019": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2020": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2021": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2221": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2222": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"2358": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"3737": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"4002": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"4337": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"4460": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"4689": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"4918": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"4919": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"5000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"5001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"5003": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"5700": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"6102": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"7001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"7332": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"7341": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"7700": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"8192": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"8194": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"8217": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"8453": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"9000": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"9001": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"9728": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"10000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"10001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"10081": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"10200": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"10243": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"11235": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"11437": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"11891": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"12357": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"13337": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"17000": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"17172": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"18231": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"23294": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"23295": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"34443": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"42161": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"42170": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"42220": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"43113": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"43114": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"43288": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"44787": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"45000": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"47805": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"54211": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"56288": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"57000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"58008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"59140": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"59144": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"71401": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"71402": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"73799": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"80001": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"80085": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"84531": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"84532": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"167008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"200101": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"200202": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"333999": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"421611": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"421613": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"421614": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"534351": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"534352": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"534353": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"622277": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"713715": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"7777777": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"11155111": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"11155420": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"222000222": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"245022926": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"245022934": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"333000333": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"999999999": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1313161554": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1313161555": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"1666600000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"1666700000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
	"11297108099": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
	"11297108109": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2"
};
var abi$n = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "singleton",
				type: "address"
			}
		],
		name: "ProxyCreation",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "calculateCreateProxyWithNonceAddress",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "createProxy",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			},
			{
				internalType: "contract IProxyCreationCallback",
				name: "callback",
				type: "address"
			}
		],
		name: "createProxyWithCallback",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "createProxyWithNonce",
		outputs: [
			{
				internalType: "contract GnosisSafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "proxyCreationCode",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
		],
		name: "proxyRuntimeCode",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "pure",
		type: "function"
	}
];
var require$$2$2 = {
	defaultAddress: defaultAddress$f,
	released: released$f,
	contractName: contractName$f,
	version: version$g,
	networkAddresses: networkAddresses$f,
	abi: abi$n
};

var defaultAddress$e = "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67";
var contractName$e = "SafeProxyFactory";
var version$f = "1.4.1";
var released$e = true;
var networkAddresses$e = {
	"1": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"5": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"10": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"56": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"71": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"97": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"100": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"137": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"1030": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"1101": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"1442": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"4337": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"8192": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"8194": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"8453": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"10243": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"11235": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"13337": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"17000": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"42161": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"42220": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"54211": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"80001": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"84531": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"84532": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
	"11155111": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67"
};
var abi$m = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "contract SafeProxy",
				name: "proxy",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "singleton",
				type: "address"
			}
		],
		name: "ProxyCreation",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "createChainSpecificProxyWithNonce",
		outputs: [
			{
				internalType: "contract SafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			},
			{
				internalType: "contract IProxyCreationCallback",
				name: "callback",
				type: "address"
			}
		],
		name: "createProxyWithCallback",
		outputs: [
			{
				internalType: "contract SafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_singleton",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "initializer",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "saltNonce",
				type: "uint256"
			}
		],
		name: "createProxyWithNonce",
		outputs: [
			{
				internalType: "contract SafeProxy",
				name: "proxy",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getChainId",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "proxyCreationCode",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "pure",
		type: "function"
	}
];
var require$$3$1 = {
	defaultAddress: defaultAddress$e,
	contractName: contractName$e,
	version: version$f,
	released: released$e,
	networkAddresses: networkAddresses$e,
	abi: abi$m
};

var __importDefault$W = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(factories, "__esModule", { value: true });
factories.getProxyFactoryDeployment = void 0;
const proxy_factory_json_1 = __importDefault$W(require$$0$4);
const proxy_factory_json_2 = __importDefault$W(require$$1$4);
const proxy_factory_json_3 = __importDefault$W(require$$2$2);
const safe_proxy_factory_json_1 = __importDefault$W(require$$3$1);
const utils_1$v = utils$h;
// This is a sorted array (newest to oldest)
const factoryDeployments = [
    safe_proxy_factory_json_1.default, proxy_factory_json_3.default, proxy_factory_json_2.default, proxy_factory_json_1.default
];
const getProxyFactoryDeployment = (filter) => {
    return (0, utils_1$v.findDeployment)(filter, factoryDeployments);
};
factories.getProxyFactoryDeployment = getProxyFactoryDeployment;

var libs = {};

var defaultAddress$d = "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4";
var released$d = true;
var contractName$d = "CreateCall";
var version$e = "1.3.0";
var networkAddresses$d = {
	"1": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"3": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"4": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"5": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"10": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"11": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"12": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"18": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"25": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"28": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"30": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"31": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"39": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"40": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"41": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"42": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"44": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"46": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"50": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"51": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"56": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"57": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"61": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"63": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"69": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"71": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"81": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"82": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"83": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"97": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"100": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"106": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"108": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"109": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"111": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"122": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"123": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"137": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"148": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"155": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"169": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"204": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"246": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"250": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"255": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"280": "0xcB8e5E438c5c2b45FbE17B02Ca9aF91509a8ad56",
	"288": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"291": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"300": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"321": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"322": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"324": "0xcB8e5E438c5c2b45FbE17B02Ca9aF91509a8ad56",
	"336": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"338": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"420": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"424": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"570": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"588": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"592": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"595": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"599": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"686": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"787": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"919": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1030": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1088": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1101": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1111": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1112": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1115": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1116": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1230": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1231": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1284": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1285": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1287": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1294": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1442": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1559": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1663": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1807": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1890": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1891": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1984": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1998": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2001": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2002": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2019": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2020": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2021": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2221": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2222": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"2358": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"3737": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"4002": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"4337": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"4460": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"4689": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"4918": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"4919": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"5000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"5001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"5003": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"5700": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"6102": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"7001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"7332": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"7341": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"7700": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"8192": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"8194": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"8217": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"8453": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"9000": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"9001": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"9728": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"10000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"10001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"10081": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"10200": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"10243": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"11235": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"11437": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"11891": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"12357": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"13337": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"17000": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"17172": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"18231": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"23294": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"23295": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"34443": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"42161": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"42170": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"42220": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"43113": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"43114": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"43288": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"44787": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"45000": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"47805": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"54211": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"56288": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"57000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"58008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"59140": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"59144": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"71401": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"71402": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"73799": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"80001": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"80085": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"84531": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"84532": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"167008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"200101": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"200202": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"333999": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"421611": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"421613": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"421614": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"534351": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"534352": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"534353": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"622277": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"713715": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"7777777": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"11155111": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"11155420": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"222000222": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"245022926": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"245022934": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"333000333": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"999999999": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1313161554": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1313161555": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"1666600000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"1666700000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
	"11297108099": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
	"11297108109": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
};
var abi$l = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "newContract",
				type: "address"
			}
		],
		name: "ContractCreation",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "deploymentData",
				type: "bytes"
			}
		],
		name: "performCreate",
		outputs: [
			{
				internalType: "address",
				name: "newContract",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "deploymentData",
				type: "bytes"
			},
			{
				internalType: "bytes32",
				name: "salt",
				type: "bytes32"
			}
		],
		name: "performCreate2",
		outputs: [
			{
				internalType: "address",
				name: "newContract",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$0$3 = {
	defaultAddress: defaultAddress$d,
	released: released$d,
	contractName: contractName$d,
	version: version$e,
	networkAddresses: networkAddresses$d,
	abi: abi$l
};

var defaultAddress$c = "0x9b35Af71d77eaf8d7e40252370304687390A1A52";
var released$c = true;
var contractName$c = "CreateCall";
var version$d = "1.4.1";
var networkAddresses$c = {
	"1": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"5": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"10": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"56": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"71": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"97": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"100": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"137": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"1030": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"1101": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"1442": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"4337": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"8192": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"8194": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"8453": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"10243": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"11235": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"13337": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"17000": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"42161": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"42220": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"54211": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"80001": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"84531": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"84532": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
	"11155111": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
};
var abi$k = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "newContract",
				type: "address"
			}
		],
		name: "ContractCreation",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "deploymentData",
				type: "bytes"
			}
		],
		name: "performCreate",
		outputs: [
			{
				internalType: "address",
				name: "newContract",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "deploymentData",
				type: "bytes"
			},
			{
				internalType: "bytes32",
				name: "salt",
				type: "bytes32"
			}
		],
		name: "performCreate2",
		outputs: [
			{
				internalType: "address",
				name: "newContract",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$3 = {
	defaultAddress: defaultAddress$c,
	released: released$c,
	contractName: contractName$c,
	version: version$d,
	networkAddresses: networkAddresses$c,
	abi: abi$k
};

var defaultAddress$b = "0x8D29bE29923b68abfDD21e541b9374737B49cdAD";
var released$b = true;
var contractName$b = "MultiSend";
var version$c = "1.1.1";
var networkAddresses$b = {
	"1": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"4": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"5": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"42": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"88": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"100": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"246": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
	"73799": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD"
};
var abi$j = [
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes",
				name: "transactions",
				type: "bytes"
			}
		],
		name: "multiSend",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$2$1 = {
	defaultAddress: defaultAddress$b,
	released: released$b,
	contractName: contractName$b,
	version: version$c,
	networkAddresses: networkAddresses$b,
	abi: abi$j
};

var defaultAddress$a = "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761";
var released$a = true;
var contractName$a = "MultiSend";
var version$b = "1.3.0";
var networkAddresses$a = {
	"1": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"3": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"4": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"5": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"10": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"11": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"12": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"18": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"25": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"28": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"30": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"31": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"39": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"40": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"41": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"42": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"44": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"46": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"50": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"51": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"56": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"57": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"61": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"63": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"69": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"71": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"81": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"82": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"83": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"97": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"100": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"106": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"108": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"109": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"111": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"122": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"123": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"137": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"148": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"155": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"169": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"204": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"246": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"250": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"255": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"280": "0x0dFcccB95225ffB03c6FBB2559B530C2B7C8A912",
	"288": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"291": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"300": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"321": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"322": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"324": "0x0dFcccB95225ffB03c6FBB2559B530C2B7C8A912",
	"336": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"338": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"420": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"424": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"570": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"588": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"592": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"595": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"599": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"686": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"787": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"919": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1030": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1088": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1101": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1111": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1112": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1115": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1116": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1230": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1231": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1284": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1285": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1287": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1294": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1442": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1559": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1663": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1807": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1890": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1891": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1984": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1998": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2001": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2002": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2019": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2020": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2021": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2221": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2222": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"2358": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"3737": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"4002": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"4337": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"4460": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"4689": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"4918": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"4919": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"5000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"5001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"5003": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"5700": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"6102": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"7001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"7332": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"7341": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"7700": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"8192": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"8194": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"8217": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"8453": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"9000": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"9001": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"9728": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"10000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"10001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"10081": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"10200": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"10243": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"11235": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"11437": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"11891": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"12357": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"13337": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"17000": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"17172": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"18231": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"23294": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"23295": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"34443": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"42161": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"42170": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"42220": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"43113": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"43114": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"43288": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"44787": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"45000": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"47805": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"54211": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"56288": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"57000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"58008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"59140": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"59144": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"71401": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"71402": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"73799": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"80001": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"80085": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"84531": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"84532": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"167008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"200101": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"200202": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"333999": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"421611": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"421613": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"421614": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"534351": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"534352": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"534353": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"622277": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"713715": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"7777777": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"11155111": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"11155420": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"222000222": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"245022926": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"245022934": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"333000333": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"999999999": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1313161554": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1313161555": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"1666600000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"1666700000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
	"11297108099": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
	"11297108109": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761"
};
var abi$i = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "transactions",
				type: "bytes"
			}
		],
		name: "multiSend",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	}
];
var require$$3 = {
	defaultAddress: defaultAddress$a,
	released: released$a,
	contractName: contractName$a,
	version: version$b,
	networkAddresses: networkAddresses$a,
	abi: abi$i
};

var defaultAddress$9 = "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526";
var released$9 = true;
var contractName$9 = "MultiSend";
var version$a = "1.4.1";
var networkAddresses$9 = {
	"1": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"5": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"10": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"56": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"71": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"97": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"100": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"137": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"1030": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"1101": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"1442": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"4337": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"8192": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"8194": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"8453": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"10243": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"11235": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"13337": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"17000": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"42161": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"42220": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"54211": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"80001": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"84531": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"84532": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
	"11155111": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526"
};
var abi$h = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "transactions",
				type: "bytes"
			}
		],
		name: "multiSend",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	}
];
var require$$4 = {
	defaultAddress: defaultAddress$9,
	released: released$9,
	contractName: contractName$9,
	version: version$a,
	networkAddresses: networkAddresses$9,
	abi: abi$h
};

var defaultAddress$8 = "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D";
var released$8 = true;
var contractName$8 = "MultiSendCallOnly";
var version$9 = "1.3.0";
var networkAddresses$8 = {
	"1": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"3": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"4": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"5": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"10": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"11": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"12": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"18": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"25": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"28": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"30": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"31": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"39": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"40": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"41": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"42": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"44": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"46": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"50": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"51": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"56": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"57": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"61": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"63": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"69": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"71": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"81": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"82": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"83": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"97": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"100": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"106": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"108": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"109": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"111": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"122": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"123": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"137": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"148": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"155": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"169": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"204": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"246": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"250": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"255": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"280": "0xf220D3b4DFb23C4ade8C88E526C1353AbAcbC38F",
	"288": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"291": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"300": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"321": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"322": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"324": "0xf220D3b4DFb23C4ade8C88E526C1353AbAcbC38F",
	"336": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"338": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"420": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"424": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"570": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"588": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"592": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"595": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"599": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"686": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"787": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"919": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1030": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1088": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1101": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1111": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1112": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1115": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1116": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1230": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1231": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1284": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1285": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1287": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1294": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1442": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1559": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1663": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1807": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1890": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1891": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1984": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1998": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2001": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2002": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2019": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2020": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2021": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2221": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2222": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"2358": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"3737": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"4002": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"4337": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"4460": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"4689": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"4918": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"4919": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"5000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"5001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"5003": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"5700": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"6102": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"7001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"7332": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"7341": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"7700": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"8192": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"8194": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"8217": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"8453": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"9000": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"9001": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"9728": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"10000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"10001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"10081": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"10200": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"10243": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"11235": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"11437": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"11891": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"12357": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"13337": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"17000": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"17172": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"18231": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"23294": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"23295": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"34443": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"42161": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"42170": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"42220": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"43113": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"43114": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"43288": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"44787": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"45000": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"47805": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"54211": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"56288": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"57000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"58008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"59140": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"59144": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"71401": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"71402": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"73799": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"80001": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"80085": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"84531": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"84532": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"167008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"200101": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"200202": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"333999": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"421611": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"421613": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"421614": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"534351": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"534352": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"534353": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"622277": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"713715": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"7777777": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"11155111": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"11155420": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"222000222": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"245022926": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"245022934": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"333000333": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"999999999": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1313161554": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1313161555": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"1666600000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"1666700000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
	"11297108099": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
	"11297108109": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D"
};
var abi$g = [
	{
		inputs: [
			{
				internalType: "bytes",
				name: "transactions",
				type: "bytes"
			}
		],
		name: "multiSend",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	}
];
var require$$5 = {
	defaultAddress: defaultAddress$8,
	released: released$8,
	contractName: contractName$8,
	version: version$9,
	networkAddresses: networkAddresses$8,
	abi: abi$g
};

var defaultAddress$7 = "0x9641d764fc13c8B624c04430C7356C1C7C8102e2";
var released$7 = true;
var contractName$7 = "MultiSendCallOnly";
var version$8 = "1.4.1";
var networkAddresses$7 = {
	"1": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"5": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"10": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"56": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"71": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"97": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"100": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"137": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"1030": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"1101": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"1442": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"4337": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"8192": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"8194": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"8453": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"10243": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"11235": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"13337": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"17000": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"42161": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"42220": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"54211": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"80001": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"84531": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"84532": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
	"11155111": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2"
};
var abi$f = [
	{
		inputs: [
			{
				internalType: "bytes",
				name: "transactions",
				type: "bytes"
			}
		],
		name: "multiSend",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	}
];
var require$$6$1 = {
	defaultAddress: defaultAddress$7,
	released: released$7,
	contractName: contractName$7,
	version: version$8,
	networkAddresses: networkAddresses$7,
	abi: abi$f
};

var defaultAddress$6 = "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2";
var contractName$6 = "SignMessageLib";
var version$7 = "1.3.0";
var released$6 = true;
var networkAddresses$6 = {
	"1": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"3": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"4": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"5": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"10": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"11": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"12": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"18": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"25": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"28": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"30": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"31": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"39": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"40": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"41": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"42": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"44": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"46": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"50": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"51": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"56": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"57": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"61": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"63": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"69": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"71": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"81": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"82": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"83": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"97": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"100": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"106": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"108": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"109": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"111": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"122": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"123": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"137": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"148": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"155": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"169": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"204": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"246": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"250": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"255": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"280": "0x357147caf9C0cCa67DfA0CF5369318d8193c8407",
	"288": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"291": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"300": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"321": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"322": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"324": "0x357147caf9C0cCa67DfA0CF5369318d8193c8407",
	"336": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"338": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"420": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"424": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"570": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"588": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"592": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"595": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"599": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"686": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"787": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"919": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1030": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1088": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1101": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1111": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1112": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1115": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1116": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1230": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1231": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1284": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1285": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1287": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1294": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1442": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1559": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1663": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1807": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1890": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1891": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1984": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1998": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2001": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2002": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2019": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2020": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2021": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2221": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2222": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"2358": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"3737": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"4002": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"4337": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"4460": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"4689": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"4918": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"4919": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"5000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"5001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"5003": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"5700": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"6102": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"7001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"7332": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"7341": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"7700": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"8192": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"8194": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"8217": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"8453": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"9000": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"9001": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"9728": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"10000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"10001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"10081": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"10200": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"10243": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"11235": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"11437": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"11891": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"12357": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"13337": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"17000": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"17172": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"18231": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"23294": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"23295": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"34443": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"42161": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"42170": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"42220": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"43113": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"43114": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"43288": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"44787": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"45000": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"47805": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"54211": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"56288": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"57000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"58008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"59140": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"59144": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"71401": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"71402": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"73799": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"80001": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"80085": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"84531": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"84532": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"167008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"200101": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"200202": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"333999": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"421611": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"421613": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"421614": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"534351": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"534352": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"534353": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"622277": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"713715": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"7777777": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"11155111": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"11155420": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"222000222": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"245022926": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"245022934": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"333000333": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"999999999": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1313161554": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1313161555": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"1666600000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"1666700000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
	"11297108099": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
	"11297108109": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2"
};
var abi$e = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		name: "signMessage",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$7$1 = {
	defaultAddress: defaultAddress$6,
	contractName: contractName$6,
	version: version$7,
	released: released$6,
	networkAddresses: networkAddresses$6,
	abi: abi$e
};

var defaultAddress$5 = "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9";
var contractName$5 = "SignMessageLib";
var version$6 = "1.4.1";
var released$5 = true;
var networkAddresses$5 = {
	"1": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"5": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"10": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"56": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"71": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"97": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"100": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"137": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"1030": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"1101": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"1442": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"4337": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"8192": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"8194": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"8453": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"10243": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"11235": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"13337": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"17000": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"42161": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"42220": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"54211": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"80001": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"84531": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"84532": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
	"11155111": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9"
};
var abi$d = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "msgHash",
				type: "bytes32"
			}
		],
		name: "SignMsg",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		name: "signMessage",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$8$1 = {
	defaultAddress: defaultAddress$5,
	contractName: contractName$5,
	version: version$6,
	released: released$5,
	networkAddresses: networkAddresses$5,
	abi: abi$d
};

var __importDefault$V = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(libs, "__esModule", { value: true });
libs.getSignMessageLibDeployment = libs.getCreateCallDeployment = libs.getMultiSendCallOnlyDeployment = libs.getMultiSendDeployment = void 0;
const create_call_json_1 = __importDefault$V(require$$0$3);
const create_call_json_2 = __importDefault$V(require$$1$3);
const multi_send_json_1 = __importDefault$V(require$$2$1);
const multi_send_json_2 = __importDefault$V(require$$3);
const multi_send_json_3 = __importDefault$V(require$$4);
const multi_send_call_only_json_1 = __importDefault$V(require$$5);
const multi_send_call_only_json_2 = __importDefault$V(require$$6$1);
const sign_message_lib_json_1 = __importDefault$V(require$$7$1);
const sign_message_lib_json_2 = __importDefault$V(require$$8$1);
const utils_1$u = utils$h;
// This is a sorted array (by preference, currently we use 111 in most cases)
const multiSendDeployments = [
    multi_send_json_3.default, multi_send_json_2.default, multi_send_json_1.default
];
const getMultiSendDeployment = (filter) => {
    return (0, utils_1$u.findDeployment)(filter, multiSendDeployments);
};
libs.getMultiSendDeployment = getMultiSendDeployment;
// This is a sorted array (by preference)
const multiSendCallOnlyDeployments = [
    multi_send_call_only_json_2.default, multi_send_call_only_json_1.default
];
const getMultiSendCallOnlyDeployment = (filter) => {
    return (0, utils_1$u.findDeployment)(filter, multiSendCallOnlyDeployments);
};
libs.getMultiSendCallOnlyDeployment = getMultiSendCallOnlyDeployment;
// This is a sorted array (by preference)
const createCallDeployments = [
    create_call_json_2.default, create_call_json_1.default
];
const getCreateCallDeployment = (filter) => {
    return (0, utils_1$u.findDeployment)(filter, createCallDeployments);
};
libs.getCreateCallDeployment = getCreateCallDeployment;
const signMessageLibDeployments = [
    sign_message_lib_json_2.default, sign_message_lib_json_1.default
];
const getSignMessageLibDeployment = (filter) => {
    return (0, utils_1$u.findDeployment)(filter, signMessageLibDeployments);
};
libs.getSignMessageLibDeployment = getSignMessageLibDeployment;

var handler = {};

var defaultAddress$4 = "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44";
var released$4 = true;
var contractName$4 = "DefaultCallbackHandler";
var version$5 = "1.1.1";
var networkAddresses$4 = {
	"1": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"4": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"5": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"42": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"88": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"100": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"246": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
	"73799": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44"
};
var abi$c = [
	{
		constant: true,
		inputs: [
		],
		name: "NAME",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC1155Received",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC1155BatchReceived",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC721Received",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "tokensReceived",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$0$2 = {
	defaultAddress: defaultAddress$4,
	released: released$4,
	contractName: contractName$4,
	version: version$5,
	networkAddresses: networkAddresses$4,
	abi: abi$c
};

var defaultAddress$3 = "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4";
var released$3 = true;
var contractName$3 = "CompatibilityFallbackHandler";
var version$4 = "1.3.0";
var networkAddresses$3 = {
	"1": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"3": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"4": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"5": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"10": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"11": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"12": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"18": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"25": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"28": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"30": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"31": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"39": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"40": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"41": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"42": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"44": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"46": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"50": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"51": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"56": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"57": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"61": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"63": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"69": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"71": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"81": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"82": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"83": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"97": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"100": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"106": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"108": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"109": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"111": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"122": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"123": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"137": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"148": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"155": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"169": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"204": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"246": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"250": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"255": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"280": "0x2f870a80647BbC554F3a0EBD093f11B4d2a7492A",
	"288": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"291": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"300": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"321": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"322": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"324": "0x2f870a80647BbC554F3a0EBD093f11B4d2a7492A",
	"336": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"338": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"420": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"424": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"570": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"588": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"592": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"595": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"599": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"686": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"787": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"919": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1030": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1088": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1101": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1111": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1112": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1115": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1116": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1230": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1231": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1284": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1285": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1287": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1294": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1442": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1559": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1663": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1807": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1890": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1891": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1984": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1998": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2001": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2002": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2019": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2020": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2021": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2221": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2222": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"2358": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"3737": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"4002": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"4337": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"4460": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"4689": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"4918": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"4919": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"5000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"5001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"5003": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"5700": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"6102": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"7001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"7332": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"7341": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"7700": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"8192": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"8194": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"8217": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"8453": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"9000": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"9001": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"9728": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"10000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"10001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"10081": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"10200": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"10243": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"11235": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"11437": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"11891": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"12357": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"13337": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"17000": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"17172": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"18231": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"23294": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"23295": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"34443": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"42161": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"42170": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"42220": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"43113": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"43114": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"43288": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"44787": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"45000": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"47805": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"54211": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"56288": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"57000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"58008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"59140": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"59144": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"71401": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"71402": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"73799": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"80001": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"80085": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"84531": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"84532": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"167008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"200101": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"200202": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"333999": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"421611": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"421613": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"421614": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"534351": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"534352": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"534353": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"622277": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"713715": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"7777777": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"11155111": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"11155420": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"222000222": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"245022926": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"245022934": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"333000333": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"999999999": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1313161554": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1313161555": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"1666600000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"1666700000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
	"11297108099": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
	"11297108109": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4"
};
var abi$b = [
	{
		inputs: [
		],
		name: "NAME",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract GnosisSafe",
				name: "safe",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHashForSafe",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getModules",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC1155BatchReceived",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC1155Received",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC721Received",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "targetContract",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "calldataPayload",
				type: "bytes"
			}
		],
		name: "simulate",
		outputs: [
			{
				internalType: "bytes",
				name: "response",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "tokensReceived",
		outputs: [
		],
		stateMutability: "pure",
		type: "function"
	}
];
var require$$1$2 = {
	defaultAddress: defaultAddress$3,
	released: released$3,
	contractName: contractName$3,
	version: version$4,
	networkAddresses: networkAddresses$3,
	abi: abi$b
};

var defaultAddress$2 = "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99";
var released$2 = true;
var contractName$2 = "CompatibilityFallbackHandler";
var version$3 = "1.4.1";
var networkAddresses$2 = {
	"1": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"5": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"10": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"56": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"71": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"97": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"100": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"137": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"1030": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"1101": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"1442": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"4337": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"8192": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"8194": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"8453": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"10243": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"11235": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"13337": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"17000": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"42161": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"42220": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"54211": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"80001": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"84531": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"84532": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
	"11155111": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99"
};
var abi$a = [
	{
		inputs: [
			{
				internalType: "contract Safe",
				name: "safe",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "encodeMessageDataForSafe",
		outputs: [
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract Safe",
				name: "safe",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "message",
				type: "bytes"
			}
		],
		name: "getMessageHashForSafe",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getModules",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_dataHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC1155BatchReceived",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC1155Received",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "onERC721Received",
		outputs: [
			{
				internalType: "bytes4",
				name: "",
				type: "bytes4"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "targetContract",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "calldataPayload",
				type: "bytes"
			}
		],
		name: "simulate",
		outputs: [
			{
				internalType: "bytes",
				name: "response",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "",
				type: "bytes"
			}
		],
		name: "tokensReceived",
		outputs: [
		],
		stateMutability: "pure",
		type: "function"
	}
];
var require$$2 = {
	defaultAddress: defaultAddress$2,
	released: released$2,
	contractName: contractName$2,
	version: version$3,
	networkAddresses: networkAddresses$2,
	abi: abi$a
};

var __importDefault$U = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(handler, "__esModule", { value: true });
handler.getFallbackHandlerDeployment = handler.getCompatibilityFallbackHandlerDeployment = handler.getDefaultCallbackHandlerDeployment = void 0;
const default_callback_handler_json_1 = __importDefault$U(require$$0$2);
const compatibility_fallback_handler_json_1 = __importDefault$U(require$$1$2);
const compatibility_fallback_handler_json_2 = __importDefault$U(require$$2);
const utils_1$t = utils$h;
// This is a sorted array (by preference)
const defaultCallbackHandlerDeployments = [
    default_callback_handler_json_1.default
];
const getDefaultCallbackHandlerDeployment = (filter) => {
    return (0, utils_1$t.findDeployment)(filter, defaultCallbackHandlerDeployments);
};
handler.getDefaultCallbackHandlerDeployment = getDefaultCallbackHandlerDeployment;
// This is a sorted array (by preference)
const compatFallbackHandlerDeployments = [
    compatibility_fallback_handler_json_2.default, compatibility_fallback_handler_json_1.default
];
const getCompatibilityFallbackHandlerDeployment = (filter) => {
    return (0, utils_1$t.findDeployment)(filter, compatFallbackHandlerDeployments);
};
handler.getCompatibilityFallbackHandlerDeployment = getCompatibilityFallbackHandlerDeployment;
// This is a sorted array (by preference)
const fallbackHandlerDeployments = [
    compatibility_fallback_handler_json_2.default, compatibility_fallback_handler_json_1.default, default_callback_handler_json_1.default
];
const getFallbackHandlerDeployment = (filter) => {
    return (0, utils_1$t.findDeployment)(filter, fallbackHandlerDeployments);
};
handler.getFallbackHandlerDeployment = getFallbackHandlerDeployment;

var accessors = {};

var defaultAddress$1 = "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da";
var released$1 = true;
var contractName$1 = "SimulateTxAccessor";
var version$2 = "1.3.0";
var networkAddresses$1 = {
	"1": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"3": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"4": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"5": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"10": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"11": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"12": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"18": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"25": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"28": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"30": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"31": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"39": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"40": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"41": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"42": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"44": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"46": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"50": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"51": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"56": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"57": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"61": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"63": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"69": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"71": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"81": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"82": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"83": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"97": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"100": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"106": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"108": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"109": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"111": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"122": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"123": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"137": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"148": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"155": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"169": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"204": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"246": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"250": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"255": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"280": "0x4191E2e12E8BC5002424CE0c51f9947b02675a44",
	"288": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"291": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"300": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"321": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"322": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"324": "0x4191E2e12E8BC5002424CE0c51f9947b02675a44",
	"336": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"338": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"420": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"424": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"570": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"588": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"592": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"595": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"599": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"686": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"787": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"919": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1030": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1088": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1101": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1111": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1112": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1115": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1116": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1230": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1231": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1284": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1285": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1287": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1294": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1442": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1559": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1663": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1807": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1890": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1891": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1984": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1998": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2001": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2002": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2019": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2020": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2021": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2221": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2222": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"2358": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"3737": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"4002": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"4337": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"4460": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"4689": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"4918": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"4919": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"5000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"5001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"5003": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"5700": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"6102": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"7001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"7332": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"7341": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"7700": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"8192": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"8194": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"8217": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"8453": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"9000": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"9001": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"9728": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"10000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"10001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"10081": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"10200": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"10243": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"11235": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"11437": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"11891": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"12357": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"13337": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"17000": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"17172": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"18231": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"23294": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"23295": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"34443": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"42161": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"42170": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"42220": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"43113": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"43114": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"43288": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"44787": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"45000": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"47805": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"54211": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"56288": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"57000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"58008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"59140": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"59144": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"71401": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"71402": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"73799": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"80001": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"80085": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"84531": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"84532": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"167008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"200101": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"200202": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"333999": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"421611": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"421613": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"421614": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"534351": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"534352": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"534353": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"622277": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"713715": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"7777777": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"11155111": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"11155420": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"222000222": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"245022926": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"245022934": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"333000333": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"999999999": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1313161554": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1313161555": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"1666600000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"1666700000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
	"11297108099": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
	"11297108109": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da"
};
var abi$9 = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "simulate",
		outputs: [
			{
				internalType: "uint256",
				name: "estimate",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$0$1 = {
	defaultAddress: defaultAddress$1,
	released: released$1,
	contractName: contractName$1,
	version: version$2,
	networkAddresses: networkAddresses$1,
	abi: abi$9
};

var defaultAddress = "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199";
var released = true;
var contractName = "SimulateTxAccessor";
var version$1 = "1.4.1";
var networkAddresses = {
	"1": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"5": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"10": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"56": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"71": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"97": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"100": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"137": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"1030": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"1101": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"1442": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"4337": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"8192": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"8194": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"8453": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"10243": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"11235": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"13337": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"17000": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"42161": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"42220": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"54211": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"80001": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"84531": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"84532": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
	"11155111": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199"
};
var abi$8 = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			},
			{
				internalType: "enum Enum.Operation",
				name: "operation",
				type: "uint8"
			}
		],
		name: "simulate",
		outputs: [
			{
				internalType: "uint256",
				name: "estimate",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			},
			{
				internalType: "bytes",
				name: "returnData",
				type: "bytes"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1 = {
	defaultAddress: defaultAddress,
	released: released,
	contractName: contractName,
	version: version$1,
	networkAddresses: networkAddresses,
	abi: abi$8
};

var __importDefault$T = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(accessors, "__esModule", { value: true });
accessors.getSimulateTxAccessorDeployment = void 0;
const simulate_tx_accessor_json_1 = __importDefault$T(require$$0$1);
const simulate_tx_accessor_json_2 = __importDefault$T(require$$1$1);
const utils_1$s = utils$h;
// This is a sorted array (newest to oldest)
const accessorDeployments = [
    simulate_tx_accessor_json_2.default, simulate_tx_accessor_json_1.default
];
const getSimulateTxAccessorDeployment = (filter) => {
    return (0, utils_1$s.findDeployment)(filter, accessorDeployments);
};
accessors.getSimulateTxAccessorDeployment = getSimulateTxAccessorDeployment;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(types$5, exports);
	__exportStar(safes, exports);
	__exportStar(factories, exports);
	__exportStar(libs, exports);
	__exportStar(handler, exports);
	__exportStar(accessors, exports); 
} (dist$5));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.mapReceipt = exports.createLibInterface = exports.createLibAddress = exports.createLibDeployment = void 0;
	const abi_1 = require$$0$9;
	const address_1 = require$$0$a;
	const safe_deployments_1 = dist$5;
	exports.createLibDeployment = (0, safe_deployments_1.getCreateCallDeployment)();
	exports.createLibAddress = exports.createLibDeployment.defaultAddress;
	exports.createLibInterface = new abi_1.Interface(exports.createLibDeployment.abi);
	const mapStatus = (receipt) => {
	    // Search for ExecutionSuccess event (see https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/GnosisSafe.sol#L49)
	    const success = receipt.logs.find((log) => log.topics[0] === '0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e');
	    return !!success ? 1 : 0;
	};
	const mapContractAddress = (receipt, safeTx) => {
	    if (safeTx.to.toLowerCase() === exports.createLibAddress.toLowerCase()) {
	        // Search for ContractCreation event (see https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/libraries/CreateCall.sol#L7)
	        const creationLog = receipt.logs.find((log) => log.topics[0] === '0x4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511');
	        if (creationLog)
	            return (0, address_1.getAddress)('0x' + creationLog.data.slice(creationLog.data.length - 40));
	    }
	    return receipt.contractAddress;
	};
	const mapReceipt = (receipt, safeTx) => {
	    // Update status with Safe tx status and extract created contract
	    receipt.status = mapStatus(receipt);
	    receipt.contractAddress = mapContractAddress(receipt, safeTx);
	    return receipt;
	};
	exports.mapReceipt = mapReceipt;
	
} (utils$i));

Object.defineProperty(signer$1, "__esModule", { value: true });
signer$1.SafeEthersSigner = void 0;
const abstract_signer_1$1 = require$$0$6;
const bignumber_1$7 = require$$0$7;
const safe_core_sdk_types_1$2 = src$5;
const utils_1$r = utils$i;
const sleep = (duration) => new Promise((resolve) => setTimeout(resolve, duration));
class SafeEthersSigner extends abstract_signer_1$1.VoidSigner {
    /**
     * Creates an instance of the SafeEthersSigner.
     * @param safe - Safe that should be used
     * @param service - Services to which the transactions should be proposed to
     * @param provider - (Optional) Provider that should be used for blockchain interactions. By default the provider from the signer is used.
     * @param options - (Optional) Additional options (e.g. polling delay when waiting for a transaction to be mined)
     * @returns The SafeEthersSigner instance
     */
    constructor(safe, service, provider, options) {
        super(safe.getAddress(), provider);
        this.service = service;
        this.safe = safe;
        this.options = options;
    }
    async buildTransactionResponse(safeTxHash, safeTx) {
        const connectedSafe = await this.safe;
        const connectedService = this.service;
        return {
            to: safeTx.to,
            value: bignumber_1$7.BigNumber.from(safeTx.value),
            data: safeTx.data,
            operation: safeTx.operation,
            gasLimit: bignumber_1$7.BigNumber.from(safeTx.safeTxGas),
            gasPrice: bignumber_1$7.BigNumber.from(0),
            nonce: safeTx.nonce,
            chainId: await connectedSafe.getChainId(),
            hash: safeTxHash,
            from: this.address,
            confirmations: 0,
            wait: async (confirmations) => {
                var _a, _b;
                while (true) {
                    try {
                        const txDetails = await connectedService.getSafeTxDetails(safeTxHash);
                        if (txDetails.transactionHash) {
                            this._checkProvider('sendTransaction');
                            const receipt = await this.provider.waitForTransaction(txDetails.transactionHash, confirmations);
                            return (0, utils_1$r.mapReceipt)(receipt, safeTx);
                        }
                    }
                    catch (e) { }
                    await sleep((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.pollingDelay) !== null && _b !== void 0 ? _b : 5000);
                }
            }
        };
    }
    /**
     * Populates all fields in a transaction, signs it and sends it to the Safe transaction service
     *
     * @param transaction - The transaction what should be send
     * @returns A promise that resolves to a SafeTransactionReponse, that contains all the information of the transaction.
     */
    async sendTransaction(transaction) {
        var _a, _b, _c;
        const tx = await transaction;
        let operation = safe_core_sdk_types_1$2.OperationType.Call;
        let to = await tx.to;
        let data = (_b = (_a = (await tx.data)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '0x';
        let value = bignumber_1$7.BigNumber.from((_c = (await tx.value)) !== null && _c !== void 0 ? _c : 0);
        if (!to) {
            to = utils_1$r.createLibAddress;
            data = utils_1$r.createLibInterface.encodeFunctionData('performCreate', [value, data]);
            value = bignumber_1$7.BigNumber.from(0);
            operation = safe_core_sdk_types_1$2.OperationType.DelegateCall;
        }
        const baseTx = {
            to: to,
            data,
            value: value.toString(),
            operation
        };
        const safeTxGas = await this.service.estimateSafeTx(this.address, baseTx);
        const connectedSafe = await this.safe;
        const safeTransactionData = {
            ...baseTx,
            safeTxGas: safeTxGas.toNumber()
        };
        const safeTx = await connectedSafe.createTransaction({ safeTransactionData });
        const safeTxHash = await connectedSafe.getTransactionHash(safeTx);
        const signature = await connectedSafe.signTransactionHash(safeTxHash);
        await this.service.proposeTx(this.address, safeTxHash, safeTx, signature);
        // TODO: maybe use original tx information
        return this.buildTransactionResponse(safeTxHash, safeTx.data);
    }
}
signer$1.SafeEthersSigner = SafeEthersSigner;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(service, exports);
	__exportStar(signer$1, exports);
	
} (src$6));

var src$4 = {};

var Safe$1 = {};

var utils$g = {};

var config$1 = {};

Object.defineProperty(config$1, "__esModule", { value: true });
config$1.safeDeploymentsL1ChainIds = config$1.safeDeploymentsVersions = config$1.SAFE_BASE_VERSION = config$1.DEFAULT_SAFE_VERSION = void 0;
config$1.DEFAULT_SAFE_VERSION = '1.3.0';
config$1.SAFE_BASE_VERSION = '1.0.0';
config$1.safeDeploymentsVersions = {
    '1.4.1': {
        safeMasterCopyVersion: '1.4.1',
        safeMasterCopyL2Version: '1.4.1',
        safeProxyFactoryVersion: '1.4.1',
        compatibilityFallbackHandler: '1.4.1',
        multiSendVersion: '1.4.1',
        multiSendCallOnlyVersion: '1.4.1',
        signMessageLibVersion: '1.4.1',
        createCallVersion: '1.4.1'
    },
    '1.3.0': {
        safeMasterCopyVersion: '1.3.0',
        safeMasterCopyL2Version: '1.3.0',
        safeProxyFactoryVersion: '1.3.0',
        compatibilityFallbackHandler: '1.3.0',
        multiSendVersion: '1.3.0',
        multiSendCallOnlyVersion: '1.3.0',
        signMessageLibVersion: '1.3.0',
        createCallVersion: '1.3.0'
    },
    '1.2.0': {
        safeMasterCopyVersion: '1.2.0',
        safeMasterCopyL2Version: undefined,
        safeProxyFactoryVersion: '1.1.1',
        compatibilityFallbackHandler: '1.3.0',
        multiSendVersion: '1.1.1',
        multiSendCallOnlyVersion: '1.3.0',
        signMessageLibVersion: '1.3.0',
        createCallVersion: '1.3.0'
    },
    '1.1.1': {
        safeMasterCopyVersion: '1.1.1',
        safeMasterCopyL2Version: undefined,
        safeProxyFactoryVersion: '1.1.1',
        compatibilityFallbackHandler: '1.3.0',
        multiSendVersion: '1.1.1',
        multiSendCallOnlyVersion: '1.3.0',
        signMessageLibVersion: '1.3.0',
        createCallVersion: '1.3.0'
    },
    '1.0.0': {
        safeMasterCopyVersion: '1.0.0',
        safeMasterCopyL2Version: undefined,
        safeProxyFactoryVersion: '1.0.0',
        compatibilityFallbackHandler: '1.3.0',
        multiSendVersion: '1.1.1',
        multiSendCallOnlyVersion: '1.3.0',
        signMessageLibVersion: '1.3.0',
        createCallVersion: '1.3.0'
    }
};
config$1.safeDeploymentsL1ChainIds = [
    1 // Ethereum Mainnet
];

var constants$4 = {};

Object.defineProperty(constants$4, "__esModule", { value: true });
constants$4.SENTINEL_ADDRESS = constants$4.EMPTY_DATA = constants$4.ZERO_ADDRESS = void 0;
constants$4.ZERO_ADDRESS = `0x${'0'.repeat(40)}`;
constants$4.EMPTY_DATA = '0x';
constants$4.SENTINEL_ADDRESS = '0x0000000000000000000000000000000000000001';

var memoized = {};

Object.defineProperty(memoized, "__esModule", { value: true });
memoized.createMemoizedFunction = void 0;
function createMemoizedFunction(callback, cache = {}) {
    return (...args) => {
        const key = JSON.stringify(args);
        cache[key] = cache[key] || callback(...args);
        return cache[key];
    };
}
memoized.createMemoizedFunction = createMemoizedFunction;

var dist$4 = {};

var constants$3 = {};

var externals = {};

var dist$3 = {};

var __importDefault$S = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(dist$3, "__esModule", { value: true });
dist$3.getLength = dist$3.decode = dist$3.encode = void 0;
const bn_js_1$1 = __importDefault$S(bnExports$2);
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode$1(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode$1(input[i]));
        }
        const buf = Buffer.concat(output);
        return Buffer.concat([encodeLength$1(buf.length, 192), buf]);
    }
    else {
        const inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128
            ? inputBuf
            : Buffer.concat([encodeLength$1(inputBuf.length, 128), inputBuf]);
    }
}
dist$3.encode = encode$1;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
    if (v[0] === '0' && v[1] === '0') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength$1(len, offset) {
    if (len < 56) {
        return Buffer.from([len + offset]);
    }
    else {
        const hexLength = intToHex(len);
        const lLength = hexLength.length / 2;
        const firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode$1(input, stream = false) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    const inputBuffer = toBuffer(input);
    const decoded = _decode$1(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
dist$3.decode = decode$1;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    const inputBuffer = toBuffer(input);
    const firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    }
    else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    }
    else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    }
    else {
        // a list  over 55 bytes long
        const llength = firstByte - 0xf6;
        const length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length;
    }
}
dist$3.getLength = getLength;
/** Decode an input with RLP */
function _decode$1(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        }
        else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP: not enough bytes for string');
        }
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
            d = _decode$1(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while (innerRemainder.length) {
            d = _decode$1(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed$4(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */
function stripHexPrefix$5(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed$4(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven$3(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
    const hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed$4(v)) {
                return Buffer.from(padToEven$3(stripHexPrefix$5(v)), 'hex');
            }
            else {
                return Buffer.from(v);
            }
        }
        else if (typeof v === 'number' || typeof v === 'bigint') {
            if (!v) {
                return Buffer.from([]);
            }
            else {
                return intToBuffer(v);
            }
        }
        else if (v === null || v === undefined) {
            return Buffer.from([]);
        }
        else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        }
        else if (bn_js_1$1.default.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}

/**
 * Re-exports commonly used modules:
 * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).
 * @packageDocumentation
 */
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault$R = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(externals, "__esModule", { value: true });
externals.rlp = externals.BN = void 0;
const bn_js_1 = __importDefault$R(bnExports$2);
externals.BN = bn_js_1.default;
const rlp = __importStar(dist$3);
externals.rlp = rlp;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
	const buffer_1 = require$$0$b;
	const externals_1 = externals;
	/**
	 * 2^64-1
	 */
	exports.MAX_UINT64 = new externals_1.BN('ffffffffffffffff', 16);
	/**
	 * The max integer that the evm can handle (2^256-1)
	 */
	exports.MAX_INTEGER = new externals_1.BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
	/**
	 * 2^256
	 */
	exports.TWO_POW256 = new externals_1.BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
	/**
	 * Keccak-256 hash of null
	 */
	exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
	/**
	 * Keccak-256 hash of null
	 */
	exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');
	/**
	 * Keccak-256 of an RLP of an empty array
	 */
	exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
	/**
	 * Keccak-256 of an RLP of an empty array
	 */
	exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
	/**
	 * Keccak-256 hash of the RLP of null
	 */
	exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
	/**
	 * Keccak-256 hash of the RLP of null
	 */
	exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');
	
} (constants$3));

var account$1 = {};

var secp256k1$4 = {};

var secp256k1$3 = {exports: {}};

var lib$2;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$2;
	hasRequiredLib = 1;
	const errors = {
	  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
	  TWEAK_ADD:
	    'The tweak was out of range or the resulted private key is invalid',
	  TWEAK_MUL: 'The tweak was out of range or equal to zero',
	  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
	  SECKEY_INVALID: 'Private Key is invalid',
	  PUBKEY_PARSE: 'Public Key could not be parsed',
	  PUBKEY_SERIALIZE: 'Public Key serialization error',
	  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
	  SIG_PARSE: 'Signature could not be parsed',
	  SIGN: 'The nonce generation function failed, or the private key was invalid',
	  RECOVER: 'Public key could not be recover',
	  ECDH: 'Scalar was invalid (zero or overflow)'
	};

	function assert (cond, msg) {
	  if (!cond) throw new Error(msg)
	}

	function isUint8Array (name, value, length) {
	  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);

	  if (length !== undefined) {
	    if (Array.isArray(length)) {
	      const numbers = length.join(', ');
	      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
	      assert(length.includes(value.length), msg);
	    } else {
	      const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
	      assert(value.length === length, msg);
	    }
	  }
	}

	function isCompressed (value) {
	  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');
	}

	function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
	  if (typeof output === 'function') output = output(length);
	  isUint8Array('output', output, length);
	  return output
	}

	function toTypeString (value) {
	  return Object.prototype.toString.call(value).slice(8, -1)
	}

	lib$2 = (secp256k1) => {
	  return {
	    contextRandomize (seed) {
	      assert(
	        seed === null || seed instanceof Uint8Array,
	        'Expected seed to be an Uint8Array or null'
	      );
	      if (seed !== null) isUint8Array('seed', seed, 32);

	      switch (secp256k1.contextRandomize(seed)) {
	        case 1:
	          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
	      }
	    },

	    privateKeyVerify (seckey) {
	      isUint8Array('private key', seckey, 32);

	      return secp256k1.privateKeyVerify(seckey) === 0
	    },

	    privateKeyNegate (seckey) {
	      isUint8Array('private key', seckey, 32);

	      switch (secp256k1.privateKeyNegate(seckey)) {
	        case 0:
	          return seckey
	        case 1:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    privateKeyTweakAdd (seckey, tweak) {
	      isUint8Array('private key', seckey, 32);
	      isUint8Array('tweak', tweak, 32);

	      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
	        case 0:
	          return seckey
	        case 1:
	          throw new Error(errors.TWEAK_ADD)
	      }
	    },

	    privateKeyTweakMul (seckey, tweak) {
	      isUint8Array('private key', seckey, 32);
	      isUint8Array('tweak', tweak, 32);

	      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
	        case 0:
	          return seckey
	        case 1:
	          throw new Error(errors.TWEAK_MUL)
	      }
	    },

	    publicKeyVerify (pubkey) {
	      isUint8Array('public key', pubkey, [33, 65]);

	      return secp256k1.publicKeyVerify(pubkey) === 0
	    },

	    publicKeyCreate (seckey, compressed = true, output) {
	      isUint8Array('private key', seckey, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyCreate(output, seckey)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.SECKEY_INVALID)
	        case 2:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyConvert (pubkey, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyConvert(output, pubkey)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyNegate (pubkey, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyNegate(output, pubkey)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	        case 3:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyCombine (pubkeys, compressed = true, output) {
	      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');
	      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');
	      for (const pubkey of pubkeys) {
	        isUint8Array('public key', pubkey, [33, 65]);
	      }
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.PUBKEY_COMBINE)
	        case 3:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isUint8Array('tweak', tweak, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.TWEAK_ADD)
	      }
	    },

	    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isUint8Array('tweak', tweak, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.TWEAK_MUL)
	      }
	    },

	    signatureNormalize (sig) {
	      isUint8Array('signature', sig, 64);

	      switch (secp256k1.signatureNormalize(sig)) {
	        case 0:
	          return sig
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	      }
	    },

	    signatureExport (sig, output) {
	      isUint8Array('signature', sig, 64);
	      output = getAssertedOutput(output, 72);

	      const obj = { output, outputlen: 72 };
	      switch (secp256k1.signatureExport(obj, sig)) {
	        case 0:
	          return output.slice(0, obj.outputlen)
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    signatureImport (sig, output) {
	      isUint8Array('signature', sig);
	      output = getAssertedOutput(output, 64);

	      switch (secp256k1.signatureImport(output, sig)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    ecdsaSign (msg32, seckey, options = {}, output) {
	      isUint8Array('message', msg32, 32);
	      isUint8Array('private key', seckey, 32);
	      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
	      if (options.data !== undefined) isUint8Array('options.data', options.data);
	      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');
	      output = getAssertedOutput(output, 64);

	      const obj = { signature: output, recid: null };
	      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
	        case 0:
	          return obj
	        case 1:
	          throw new Error(errors.SIGN)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    ecdsaVerify (sig, msg32, pubkey) {
	      isUint8Array('signature', sig, 64);
	      isUint8Array('message', msg32, 32);
	      isUint8Array('public key', pubkey, [33, 65]);

	      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
	        case 0:
	          return true
	        case 3:
	          return false
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.PUBKEY_PARSE)
	      }
	    },

	    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
	      isUint8Array('signature', sig, 64);
	      assert(
	        toTypeString(recid) === 'Number' &&
	          recid >= 0 &&
	          recid <= 3,
	        'Expected recovery id to be a Number within interval [0, 3]'
	      );
	      isUint8Array('message', msg32, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.RECOVER)
	        case 3:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    ecdh (pubkey, seckey, options = {}, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isUint8Array('private key', seckey, 32);
	      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
	      if (options.data !== undefined) isUint8Array('options.data', options.data);
	      if (options.hashfn !== undefined) {
	        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');
	        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);
	        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);
	        isUint8Array('output', output);
	      } else {
	        output = getAssertedOutput(output, 32);
	      }

	      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.ECDH)
	      }
	    }
	  }
	};
	return lib$2;
}

var bindings$1;
var hasRequiredBindings$1;

function requireBindings$1 () {
	if (hasRequiredBindings$1) return bindings$1;
	hasRequiredBindings$1 = 1;
	const addon = requireNodeGypBuild()(__dirname);
	bindings$1 = requireLib()(new addon.Secp256k1());
	return bindings$1;
}

var elliptic$2 = {};

var name = "elliptic";
var version = "6.5.4";
var description = "EC cryptography";
var main = "lib/elliptic.js";
var files = [
	"lib"
];
var scripts = {
	lint: "eslint lib test",
	"lint:fix": "npm run lint -- --fix",
	unit: "istanbul test _mocha --reporter=spec test/index.js",
	test: "npm run lint && npm run unit",
	version: "grunt dist && git add dist/"
};
var repository = {
	type: "git",
	url: "git@github.com:indutny/elliptic"
};
var keywords = [
	"EC",
	"Elliptic",
	"curve",
	"Cryptography"
];
var author = "Fedor Indutny <fedor@indutny.com>";
var license = "MIT";
var bugs = {
	url: "https://github.com/indutny/elliptic/issues"
};
var homepage = "https://github.com/indutny/elliptic";
var devDependencies = {
	brfs: "^2.0.2",
	coveralls: "^3.1.0",
	eslint: "^7.6.0",
	grunt: "^1.2.1",
	"grunt-browserify": "^5.3.0",
	"grunt-cli": "^1.3.2",
	"grunt-contrib-connect": "^3.0.0",
	"grunt-contrib-copy": "^1.0.0",
	"grunt-contrib-uglify": "^5.0.0",
	"grunt-mocha-istanbul": "^5.0.2",
	"grunt-saucelabs": "^9.0.1",
	istanbul: "^0.4.5",
	mocha: "^8.0.1"
};
var dependencies = {
	"bn.js": "^4.11.9",
	brorand: "^1.1.0",
	"hash.js": "^1.0.0",
	"hmac-drbg": "^1.0.1",
	inherits: "^2.0.4",
	"minimalistic-assert": "^1.0.1",
	"minimalistic-crypto-utils": "^1.0.1"
};
var require$$0 = {
	name: name,
	version: version,
	description: description,
	main: main,
	files: files,
	scripts: scripts,
	repository: repository,
	keywords: keywords,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage,
	devDependencies: devDependencies,
	dependencies: dependencies
};

var utils$f = {};

var bn$2 = {exports: {}};

bn$2.exports;

var hasRequiredBn;

function requireBn () {
	if (hasRequiredBn) return bn$2.exports;
	hasRequiredBn = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = require('buffer').Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & ~0x1fff) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, commonjsGlobal); 
	} (bn$2));
	return bn$2.exports;
}

var utils$e = {};

var hasRequiredUtils$4;

function requireUtils$4 () {
	if (hasRequiredUtils$4) return utils$e;
	hasRequiredUtils$4 = 1;
	(function (exports) {

		var utils = exports;

		function toArray(msg, enc) {
		  if (Array.isArray(msg))
		    return msg.slice();
		  if (!msg)
		    return [];
		  var res = [];
		  if (typeof msg !== 'string') {
		    for (var i = 0; i < msg.length; i++)
		      res[i] = msg[i] | 0;
		    return res;
		  }
		  if (enc === 'hex') {
		    msg = msg.replace(/[^a-z0-9]+/ig, '');
		    if (msg.length % 2 !== 0)
		      msg = '0' + msg;
		    for (var i = 0; i < msg.length; i += 2)
		      res.push(parseInt(msg[i] + msg[i + 1], 16));
		  } else {
		    for (var i = 0; i < msg.length; i++) {
		      var c = msg.charCodeAt(i);
		      var hi = c >> 8;
		      var lo = c & 0xff;
		      if (hi)
		        res.push(hi, lo);
		      else
		        res.push(lo);
		    }
		  }
		  return res;
		}
		utils.toArray = toArray;

		function zero2(word) {
		  if (word.length === 1)
		    return '0' + word;
		  else
		    return word;
		}
		utils.zero2 = zero2;

		function toHex(msg) {
		  var res = '';
		  for (var i = 0; i < msg.length; i++)
		    res += zero2(msg[i].toString(16));
		  return res;
		}
		utils.toHex = toHex;

		utils.encode = function encode(arr, enc) {
		  if (enc === 'hex')
		    return toHex(arr);
		  else
		    return arr;
		}; 
	} (utils$e));
	return utils$e;
}

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$f;
	hasRequiredUtils$3 = 1;
	(function (exports) {

		var utils = exports;
		var BN = requireBn();
		var minAssert = minimalisticAssert;
		var minUtils = requireUtils$4();

		utils.assert = minAssert;
		utils.toArray = minUtils.toArray;
		utils.zero2 = minUtils.zero2;
		utils.toHex = minUtils.toHex;
		utils.encode = minUtils.encode;

		// Represent num in a w-NAF form
		function getNAF(num, w, bits) {
		  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
		  naf.fill(0);

		  var ws = 1 << (w + 1);
		  var k = num.clone();

		  for (var i = 0; i < naf.length; i++) {
		    var z;
		    var mod = k.andln(ws - 1);
		    if (k.isOdd()) {
		      if (mod > (ws >> 1) - 1)
		        z = (ws >> 1) - mod;
		      else
		        z = mod;
		      k.isubn(z);
		    } else {
		      z = 0;
		    }

		    naf[i] = z;
		    k.iushrn(1);
		  }

		  return naf;
		}
		utils.getNAF = getNAF;

		// Represent k1, k2 in a Joint Sparse Form
		function getJSF(k1, k2) {
		  var jsf = [
		    [],
		    [],
		  ];

		  k1 = k1.clone();
		  k2 = k2.clone();
		  var d1 = 0;
		  var d2 = 0;
		  var m8;
		  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
		    // First phase
		    var m14 = (k1.andln(3) + d1) & 3;
		    var m24 = (k2.andln(3) + d2) & 3;
		    if (m14 === 3)
		      m14 = -1;
		    if (m24 === 3)
		      m24 = -1;
		    var u1;
		    if ((m14 & 1) === 0) {
		      u1 = 0;
		    } else {
		      m8 = (k1.andln(7) + d1) & 7;
		      if ((m8 === 3 || m8 === 5) && m24 === 2)
		        u1 = -m14;
		      else
		        u1 = m14;
		    }
		    jsf[0].push(u1);

		    var u2;
		    if ((m24 & 1) === 0) {
		      u2 = 0;
		    } else {
		      m8 = (k2.andln(7) + d2) & 7;
		      if ((m8 === 3 || m8 === 5) && m14 === 2)
		        u2 = -m24;
		      else
		        u2 = m24;
		    }
		    jsf[1].push(u2);

		    // Second phase
		    if (2 * d1 === u1 + 1)
		      d1 = 1 - d1;
		    if (2 * d2 === u2 + 1)
		      d2 = 1 - d2;
		    k1.iushrn(1);
		    k2.iushrn(1);
		  }

		  return jsf;
		}
		utils.getJSF = getJSF;

		function cachedProperty(obj, name, computer) {
		  var key = '_' + name;
		  obj.prototype[name] = function cachedProperty() {
		    return this[key] !== undefined ? this[key] :
		      this[key] = computer.call(this);
		  };
		}
		utils.cachedProperty = cachedProperty;

		function parseBytes(bytes) {
		  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
		    bytes;
		}
		utils.parseBytes = parseBytes;

		function intFromLE(bytes) {
		  return new BN(bytes, 'hex', 'le');
		}
		utils.intFromLE = intFromLE; 
	} (utils$f));
	return utils$f;
}

var brorand = {exports: {}};

var hasRequiredBrorand;

function requireBrorand () {
	if (hasRequiredBrorand) return brorand.exports;
	hasRequiredBrorand = 1;
	var r;

	brorand.exports = function rand(len) {
	  if (!r)
	    r = new Rand(null);

	  return r.generate(len);
	};

	function Rand(rand) {
	  this.rand = rand;
	}
	brorand.exports.Rand = Rand;

	Rand.prototype.generate = function generate(len) {
	  return this._rand(len);
	};

	// Emulate crypto API using randy
	Rand.prototype._rand = function _rand(n) {
	  if (this.rand.getBytes)
	    return this.rand.getBytes(n);

	  var res = new Uint8Array(n);
	  for (var i = 0; i < res.length; i++)
	    res[i] = this.rand.getByte();
	  return res;
	};

	if (typeof self === 'object') {
	  if (self.crypto && self.crypto.getRandomValues) {
	    // Modern browsers
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      self.crypto.getRandomValues(arr);
	      return arr;
	    };
	  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
	    // IE
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      self.msCrypto.getRandomValues(arr);
	      return arr;
	    };

	  // Safari's WebWorkers do not have `crypto`
	  } else if (typeof window === 'object') {
	    // Old junk
	    Rand.prototype._rand = function() {
	      throw new Error('Not implemented yet');
	    };
	  }
	} else {
	  // Node.js or Web worker with no crypto support
	  try {
	    var crypto = require('crypto');
	    if (typeof crypto.randomBytes !== 'function')
	      throw new Error('Not supported');

	    Rand.prototype._rand = function _rand(n) {
	      return crypto.randomBytes(n);
	    };
	  } catch (e) {
	  }
	}
	return brorand.exports;
}

var curve$1 = {};

var base;
var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base;
	hasRequiredBase = 1;

	var BN = requireBn();
	var utils = requireUtils$3();
	var getNAF = utils.getNAF;
	var getJSF = utils.getJSF;
	var assert = utils.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new BN(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

	  // Useful for many curves
	  this.zero = new BN(0).toRed(this.red);
	  this.one = new BN(1).toRed(this.red);
	  this.two = new BN(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new BN(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);

	  this._bitLength = this.n ? this.n.bitLength() : 0;

	  // Generalized Greg Maxwell's trick
	  var adjustCount = this.n && this.p.div(this.n);
	  if (!adjustCount || adjustCount.cmpn(100) > 0) {
	    this.redN = null;
	  } else {
	    this._maxwellTrick = true;
	    this.redN = this.n.toRed(this.red);
	  }
	}
	base = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1, this._bitLength);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  var j;
	  var nafW;
	  for (j = 0; j < naf.length; j += doubles.step) {
	    nafW = 0;
	    for (var l = j + doubles.step - 1; l >= j; l--)
	      nafW = (nafW << 1) + naf[l];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (j = 0; j < repr.length; j++) {
	      nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w, this._bitLength);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var l = 0; i >= 0 && naf[i] === 0; i--)
	      l++;
	    if (i >= 0)
	      l++;
	    acc = acc.dblp(l);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	  points,
	  coeffs,
	  len,
	  jacobianResult) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  var i;
	  var j;
	  var p;
	  for (i = 0; i < len; i++) {
	    p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
	      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b], /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3,  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (j = 0; j < len; j++) {
	      var z = tmp[j];
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (i = 0; i < len; i++)
	    wnd[i] = null;

	  if (jacobianResult)
	    return acc;
	  else
	    return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils.toArray(bytes, enc);

	  var len = this.p.byteLength();

	  // uncompressed, hybrid-odd, hybrid-even
	  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
	      bytes.length - 1 === 2 * len) {
	    if (bytes[0] === 0x06)
	      assert(bytes[bytes.length - 1] % 2 === 0);
	    else if (bytes[0] === 0x07)
	      assert(bytes[bytes.length - 1] % 2 === 1);

	    var res =  this.point(bytes.slice(1, 1 + len),
	      bytes.slice(1 + len, 1 + 2 * len));

	    return res;
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null,
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles,
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res,
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};
	return base;
}

var short;
var hasRequiredShort;

function requireShort () {
	if (hasRequiredShort) return short;
	hasRequiredShort = 1;

	var utils = requireUtils$3();
	var BN = requireBn();
	var inherits = inheritsExports;
	var Base = requireBase();

	var assert = utils.assert;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits(ShortCurve, Base);
	short = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new BN(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new BN(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new BN(vec.a, 16),
	        b: new BN(vec.b, 16),
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis,
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : BN.mont(num);
	  var tinv = new BN(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new BN(1);
	  var y1 = new BN(0);
	  var x2 = new BN(0);
	  var y2 = new BN(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 },
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
	      var npoints = this._endoWnafT1;
	      var ncoeffs = this._endoWnafT2;
	      for (var i = 0; i < points.length; i++) {
	        var split = this._endoSplit(coeffs[i]);
	        var p = points[i];
	        var beta = p._getBeta();

	        if (split.k1.negative) {
	          split.k1.ineg();
	          p = p.neg(true);
	        }
	        if (split.k2.negative) {
	          split.k2.ineg();
	          beta = beta.neg(true);
	        }

	        npoints[i * 2] = p;
	        npoints[i * 2 + 1] = beta;
	        ncoeffs[i * 2] = split.k1;
	        ncoeffs[i * 2 + 1] = split.k2;
	      }
	      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

	      // Clean-up references to points and coefficients
	      for (var j = 0; j < i * 2; j++) {
	        npoints[j] = null;
	        ncoeffs[j] = null;
	      }
	      return res;
	    };

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits(Point, Base.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul),
	      },
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1),
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1),
	    },
	  } ];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point)),
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point)),
	    },
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new BN(k, 16);
	  if (this.isInfinity())
	    return this;
	  else if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs, true);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate),
	      },
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new BN(0);
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = new BN(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits(JPoint, Base.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  var i;
	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new BN(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.eqXToP = function eqXToP(x) {
	  var zs = this.z.redSqr();
	  var rx = x.toRed(this.curve.red).redMul(zs);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(zs);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};
	return short;
}

var mont;
var hasRequiredMont;

function requireMont () {
	if (hasRequiredMont) return mont;
	hasRequiredMont = 1;

	var BN = requireBn();
	var inherits = inheritsExports;
	var Base = requireBase();

	var utils = requireUtils$3();

	function MontCurve(conf) {
	  Base.call(this, 'mont', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.i4 = new BN(4).toRed(this.red).redInvm();
	  this.two = new BN(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits(MontCurve, Base);
	mont = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point(curve, x, z) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new BN(x, 16);
	    this.z = new BN(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits(Point, Base.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	Point.prototype.precompute = function precompute() {
	  // No-op
	};

	Point.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1] || curve.one);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.jumlAdd = function jumlAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};
	return mont;
}

var edwards;
var hasRequiredEdwards;

function requireEdwards () {
	if (hasRequiredEdwards) return edwards;
	hasRequiredEdwards = 1;

	var utils = requireUtils$3();
	var BN = requireBn();
	var inherits = inheritsExports;
	var Base = requireBase();

	var assert = utils.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'edwards', conf);

	  this.a = new BN(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new BN(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new BN(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits(EdwardsCurve, Base);
	edwards = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y2 = rhs.redMul(lhs.redInvm());
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new BN(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.c2);
	  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.fromRed().isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = z ? new BN(z, 16) : this.curve.one;
	    this.t = t && new BN(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits(Point, Base.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	    (this.y.cmp(this.z) === 0 ||
	    (this.zOne && this.y.cmp(this.curve.c) === 0));
	};

	Point.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  var e;
	  var h;
	  var j;
	  if (this.curve.twisted) {
	    // E = a * C
	    e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      h = this.z.redSqr();
	      // J = F - 2 * H
	      j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    e = c.redAdd(d);
	    // H = (c * Z1)^2
	    h = this.curve._mulC(this.z).redSqr();
	    // J = E - 2 * H
	    j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	    this.y,
	    this.z,
	    this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	Point.prototype.eqXToP = function eqXToP(x) {
	  var rx = x.toRed(this.curve.red).redMul(this.z);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(this.z);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;
	return edwards;
}

var hasRequiredCurve;

function requireCurve () {
	if (hasRequiredCurve) return curve$1;
	hasRequiredCurve = 1;
	(function (exports) {

		var curve = exports;

		curve.base = requireBase();
		curve.short = requireShort();
		curve.mont = requireMont();
		curve.edwards = requireEdwards(); 
	} (curve$1));
	return curve$1;
}

var curves = {};

var secp256k1$2;
var hasRequiredSecp256k1;

function requireSecp256k1 () {
	if (hasRequiredSecp256k1) return secp256k1$2;
	hasRequiredSecp256k1 = 1;
	secp256k1$2 = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
	      ],
	    ],
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
	      ],
	    ],
	  },
	};
	return secp256k1$2;
}

var hasRequiredCurves;

function requireCurves () {
	if (hasRequiredCurves) return curves;
	hasRequiredCurves = 1;
	(function (exports) {

		var curves = exports;

		var hash = hash$2;
		var curve = requireCurve();
		var utils = requireUtils$3();

		var assert = utils.assert;

		function PresetCurve(options) {
		  if (options.type === 'short')
		    this.curve = new curve.short(options);
		  else if (options.type === 'edwards')
		    this.curve = new curve.edwards(options);
		  else
		    this.curve = new curve.mont(options);
		  this.g = this.curve.g;
		  this.n = this.curve.n;
		  this.hash = options.hash;

		  assert(this.g.validate(), 'Invalid curve');
		  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
		}
		curves.PresetCurve = PresetCurve;

		function defineCurve(name, options) {
		  Object.defineProperty(curves, name, {
		    configurable: true,
		    enumerable: true,
		    get: function() {
		      var curve = new PresetCurve(options);
		      Object.defineProperty(curves, name, {
		        configurable: true,
		        enumerable: true,
		        value: curve,
		      });
		      return curve;
		    },
		  });
		}

		defineCurve('p192', {
		  type: 'short',
		  prime: 'p192',
		  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
		  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
		  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
		    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
		  ],
		});

		defineCurve('p224', {
		  type: 'short',
		  prime: 'p224',
		  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
		  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
		  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
		    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
		  ],
		});

		defineCurve('p256', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
		  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
		  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
		  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
		    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
		  ],
		});

		defineCurve('p384', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 ffffffff',
		  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 fffffffc',
		  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
		     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
		  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
		     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
		  hash: hash.sha384,
		  gRed: false,
		  g: [
		    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
		    '5502f25d bf55296c 3a545e38 72760ab7',
		    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
		    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
		  ],
		});

		defineCurve('p521', {
		  type: 'short',
		  prime: null,
		  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff',
		  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff fffffffc',
		  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
		     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
		     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
		  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
		     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
		  hash: hash.sha512,
		  gRed: false,
		  g: [
		    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
		    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
		    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
		    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
		    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
		    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
		  ],
		});

		defineCurve('curve25519', {
		  type: 'mont',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '76d06',
		  b: '1',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '9',
		  ],
		});

		defineCurve('ed25519', {
		  type: 'edwards',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '-1',
		  c: '1',
		  // -121665 * (121666^(-1)) (mod P)
		  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

		    // 4/5
		    '6666666666666666666666666666666666666666666666666666666666666658',
		  ],
		});

		var pre;
		try {
		  pre = requireSecp256k1();
		} catch (e) {
		  pre = undefined;
		}

		defineCurve('secp256k1', {
		  type: 'short',
		  prime: 'k256',
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
		  a: '0',
		  b: '7',
		  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
		  h: '1',
		  hash: hash.sha256,

		  // Precomputed endomorphism
		  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
		  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
		  basis: [
		    {
		      a: '3086d221a7d46bcde86c90e49284eb15',
		      b: '-e4437ed6010e88286f547fa90abfe4c3',
		    },
		    {
		      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
		      b: '3086d221a7d46bcde86c90e49284eb15',
		    },
		  ],

		  gRed: false,
		  g: [
		    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
		    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
		    pre,
		  ],
		}); 
	} (curves));
	return curves;
}

var hmacDrbg;
var hasRequiredHmacDrbg;

function requireHmacDrbg () {
	if (hasRequiredHmacDrbg) return hmacDrbg;
	hasRequiredHmacDrbg = 1;

	var hash = hash$2;
	var utils = requireUtils$4();
	var assert = minimalisticAssert;

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this._reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
	  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
	  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	hmacDrbg = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this._reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils.toArray(entropy, entropyEnc);
	  add = utils.toArray(add, addEnc);

	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this._reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this._reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils.toArray(add, addEnc || 'hex');
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this._reseed++;
	  return utils.encode(res, enc);
	};
	return hmacDrbg;
}

var key$1;
var hasRequiredKey$1;

function requireKey$1 () {
	if (hasRequiredKey$1) return key$1;
	hasRequiredKey$1 = 1;

	var BN = requireBn();
	var utils = requireUtils$3();
	var assert = utils.assert;

	function KeyPair(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	key$1 = KeyPair;

	KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair)
	    return pub;

	  return new KeyPair(ec, {
	    pub: pub,
	    pubEnc: enc,
	  });
	};

	KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair)
	    return priv;

	  return new KeyPair(ec, {
	    priv: priv,
	    privEnc: enc,
	  });
	};

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new BN(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    // Montgomery points only have an `x` coordinate.
	    // Weierstrass/Edwards points on the other hand have both `x` and
	    // `y` coordinates.
	    if (this.ec.curve.type === 'mont') {
	      assert(key.x, 'Need x coordinate');
	    } else if (this.ec.curve.type === 'short' ||
	               this.ec.curve.type === 'edwards') {
	      assert(key.x && key.y, 'Need both x and y coordinate');
	    }
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  if(!pub.validate()) {
	    assert(pub.validate(), 'public point not validated');
	  }
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};
	return key$1;
}

var signature$3;
var hasRequiredSignature$1;

function requireSignature$1 () {
	if (hasRequiredSignature$1) return signature$3;
	hasRequiredSignature$1 = 1;

	var BN = requireBn();

	var utils = requireUtils$3();
	var assert = utils.assert;

	function Signature(options, enc) {
	  if (options instanceof Signature)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert(options.r && options.s, 'Signature without r or s');
	  this.r = new BN(options.r, 16);
	  this.s = new BN(options.s, 16);
	  if (options.recoveryParam === undefined)
	    this.recoveryParam = null;
	  else
	    this.recoveryParam = options.recoveryParam;
	}
	signature$3 = Signature;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;

	  // Indefinite length or overflow
	  if (octetLen === 0 || octetLen > 4) {
	    return false;
	  }

	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	    val >>>= 0;
	  }

	  // Leading zeroes
	  if (val <= 0x7f) {
	    return false;
	  }

	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if (len === false) {
	    return false;
	  }
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  if (rlen === false) {
	    return false;
	  }
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (slen === false) {
	    return false;
	  }
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0) {
	    if (r[1] & 0x80) {
	      r = r.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }
	  if (s[0] === 0) {
	    if (s[1] & 0x80) {
	      s = s.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }

	  this.r = new BN(r);
	  this.s = new BN(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils.encode(res, enc);
	};
	return signature$3;
}

var ec;
var hasRequiredEc;

function requireEc () {
	if (hasRequiredEc) return ec;
	hasRequiredEc = 1;

	var BN = requireBn();
	var HmacDRBG = requireHmacDrbg();
	var utils = requireUtils$3();
	var curves = requireCurves();
	var rand = requireBrorand();
	var assert = utils.assert;

	var KeyPair = requireKey$1();
	var Signature = requireSignature$1();

	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert(Object.prototype.hasOwnProperty.call(curves, options),
	      'Unknown curve ' + options);

	    options = curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.ushrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	ec = EC;

	EC.prototype.keyPair = function keyPair(options) {
	  return new KeyPair(this, options);
	};

	EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
	  return KeyPair.fromPrivate(this, priv, enc);
	};

	EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
	  return KeyPair.fromPublic(this, pub, enc);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new HmacDRBG({
	    hash: this.hash,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	    entropy: options.entropy || rand(this.hash.hmacStrength),
	    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
	    nonce: this.n.toArray(),
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new BN(2));
	  for (;;) {
	    var priv = new BN(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyFromPrivate(priv);
	  }
	};

	EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.ushrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, enc, options) {
	  if (typeof enc === 'object') {
	    options = enc;
	    enc = null;
	  }
	  if (!options)
	    options = {};

	  key = this.keyFromPrivate(key, enc);
	  msg = this._truncateToN(new BN(msg, 16));

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray('be', bytes);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray('be', bytes);

	  // Instantiate Hmac_DRBG
	  var drbg = new HmacDRBG({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new BN(1));

	  for (var iter = 0; ; iter++) {
	    var k = options.k ?
	      options.k(iter) :
	      new BN(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var kpX = kp.getX();
	    var r = kpX.umod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
	    s = s.umod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
	                        (kpX.cmp(r) !== 0 ? 2 : 0);

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0) {
	      s = this.n.sub(s);
	      recoveryParam ^= 1;
	    }

	    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
	  }
	};

	EC.prototype.verify = function verify(msg, signature, key, enc) {
	  msg = this._truncateToN(new BN(msg, 16));
	  key = this.keyFromPublic(key, enc);
	  signature = new Signature(signature, 'hex');

	  // Perform primitive values validation
	  var r = signature.r;
	  var s = signature.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).umod(this.n);
	  var u2 = sinv.mul(r).umod(this.n);
	  var p;

	  if (!this.curve._maxwellTrick) {
	    p = this.g.mulAdd(u1, key.getPublic(), u2);
	    if (p.isInfinity())
	      return false;

	    return p.getX().umod(this.n).cmp(r) === 0;
	  }

	  // NOTE: Greg Maxwell's trick, inspired by:
	  // https://git.io/vad3K

	  p = this.g.jmulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  // Compare `p.x` of Jacobian point with `r`,
	  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
	  // inverse of `p.z^2`
	  return p.eqXToP(r);
	};

	EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
	  assert((3 & j) === j, 'The recovery param is more than two bits');
	  signature = new Signature(signature, enc);

	  var n = this.n;
	  var e = new BN(msg);
	  var r = signature.r;
	  var s = signature.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = j & 1;
	  var isSecondKey = j >> 1;
	  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
	    throw new Error('Unable to find sencond key candinate');

	  // 1.1. Let x = r + jn.
	  if (isSecondKey)
	    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
	  else
	    r = this.curve.pointFromX(r, isYOdd);

	  var rInv = signature.r.invm(n);
	  var s1 = n.sub(e).mul(rInv).umod(n);
	  var s2 = s.mul(rInv).umod(n);

	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  return this.g.mulAdd(s1, r, s2);
	};

	EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
	  signature = new Signature(signature, enc);
	  if (signature.recoveryParam !== null)
	    return signature.recoveryParam;

	  for (var i = 0; i < 4; i++) {
	    var Qprime;
	    try {
	      Qprime = this.recoverPubKey(e, signature, i);
	    } catch (e) {
	      continue;
	    }

	    if (Qprime.eq(Q))
	      return i;
	  }
	  throw new Error('Unable to find valid recovery factor');
	};
	return ec;
}

var key;
var hasRequiredKey;

function requireKey () {
	if (hasRequiredKey) return key;
	hasRequiredKey = 1;

	var utils = requireUtils$3();
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var cachedProperty = utils.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes(params.pub);
	}

	KeyPair.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair)
	    return pub;
	  return new KeyPair(eddsa, { pub: pub });
	};

	KeyPair.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair)
	    return secret;
	  return new KeyPair(eddsa, { secret: secret });
	};

	KeyPair.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty(KeyPair, 'pub', function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty(KeyPair, 'privBytes', function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty(KeyPair, 'priv', function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty(KeyPair, 'hash', function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair.prototype.sign = function sign(message) {
	  assert(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair.prototype.getSecret = function getSecret(enc) {
	  assert(this._secret, 'KeyPair is public only');
	  return utils.encode(this.secret(), enc);
	};

	KeyPair.prototype.getPublic = function getPublic(enc) {
	  return utils.encode(this.pubBytes(), enc);
	};

	key = KeyPair;
	return key;
}

var signature$2;
var hasRequiredSignature;

function requireSignature () {
	if (hasRequiredSignature) return signature$2;
	hasRequiredSignature = 1;

	var BN = requireBn();
	var utils = requireUtils$3();
	var assert = utils.assert;
	var cachedProperty = utils.cachedProperty;
	var parseBytes = utils.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes(sig);

	  if (Array.isArray(sig)) {
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength),
	    };
	  }

	  assert(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof BN)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty(Signature, 'S', function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty(Signature, 'R', function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty(Signature, 'Rencoded', function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty(Signature, 'Sencoded', function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature.prototype.toHex = function toHex() {
	  return utils.encode(this.toBytes(), 'hex').toUpperCase();
	};

	signature$2 = Signature;
	return signature$2;
}

var eddsa;
var hasRequiredEddsa;

function requireEddsa () {
	if (hasRequiredEddsa) return eddsa;
	hasRequiredEddsa = 1;

	var hash = hash$2;
	var curves = requireCurves();
	var utils = requireUtils$3();
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var KeyPair = requireKey();
	var Signature = requireSignature();

	function EDDSA(curve) {
	  assert(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  curve = curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash.sha512;
	}

	eddsa = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	    .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes(message);
	  sig = this.makeSignature(sig);
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return KeyPair.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return KeyPair.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof Signature)
	    return sig;
	  return new Signature(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};
	return eddsa;
}

var hasRequiredElliptic$2;

function requireElliptic$2 () {
	if (hasRequiredElliptic$2) return elliptic$2;
	hasRequiredElliptic$2 = 1;
	(function (exports) {

		var elliptic = exports;

		elliptic.version = require$$0.version;
		elliptic.utils = requireUtils$3();
		elliptic.rand = requireBrorand();
		elliptic.curve = requireCurve();
		elliptic.curves = requireCurves();

		// Protocols
		elliptic.ec = requireEc();
		elliptic.eddsa = requireEddsa(); 
	} (elliptic$2));
	return elliptic$2;
}

var elliptic$1;
var hasRequiredElliptic$1;

function requireElliptic$1 () {
	if (hasRequiredElliptic$1) return elliptic$1;
	hasRequiredElliptic$1 = 1;
	const EC = requireElliptic$2().ec;

	const ec = new EC('secp256k1');
	const ecparams = ec.curve;

	// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
	// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
	const BN = ecparams.n.constructor;

	function loadCompressedPublicKey (first, xbuf) {
	  let x = new BN(xbuf);

	  // overflow
	  if (x.cmp(ecparams.p) >= 0) return null
	  x = x.toRed(ecparams.red);

	  // compute corresponding Y
	  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
	  if ((first === 0x03) !== y.isOdd()) y = y.redNeg();

	  return ec.keyPair({ pub: { x: x, y: y } })
	}

	function loadUncompressedPublicKey (first, xbuf, ybuf) {
	  let x = new BN(xbuf);
	  let y = new BN(ybuf);

	  // overflow
	  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

	  x = x.toRed(ecparams.red);
	  y = y.toRed(ecparams.red);

	  // is odd flag
	  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

	  // x*x*x + b = y*y
	  const x3 = x.redSqr().redIMul(x);
	  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

	  return ec.keyPair({ pub: { x: x, y: y } })
	}

	function loadPublicKey (pubkey) {
	  // length should be validated in interface
	  const first = pubkey[0];
	  switch (first) {
	    case 0x02:
	    case 0x03:
	      if (pubkey.length !== 33) return null
	      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
	    case 0x04:
	    case 0x06:
	    case 0x07:
	      if (pubkey.length !== 65) return null
	      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
	    default:
	      return null
	  }
	}

	function savePublicKey (output, point) {
	  const pubkey = point.encode(null, output.length === 33);
	  // Loop should be faster because we do not need create extra Uint8Array
	  // output.set(new Uint8Array(pubkey))
	  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i];
	}

	elliptic$1 = {
	  contextRandomize () {
	    return 0
	  },

	  privateKeyVerify (seckey) {
	    const bn = new BN(seckey);
	    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
	  },

	  privateKeyNegate (seckey) {
	    const bn = new BN(seckey);
	    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);
	    seckey.set(negate);
	    return 0
	  },

	  privateKeyTweakAdd (seckey, tweak) {
	    const bn = new BN(tweak);
	    if (bn.cmp(ecparams.n) >= 0) return 1

	    bn.iadd(new BN(seckey));
	    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
	    if (bn.isZero()) return 1

	    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
	    seckey.set(tweaked);

	    return 0
	  },

	  privateKeyTweakMul (seckey, tweak) {
	    let bn = new BN(tweak);
	    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

	    bn.imul(new BN(seckey));
	    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);

	    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
	    seckey.set(tweaked);

	    return 0
	  },

	  publicKeyVerify (pubkey) {
	    const pair = loadPublicKey(pubkey);
	    return pair === null ? 1 : 0
	  },

	  publicKeyCreate (output, seckey) {
	    const bn = new BN(seckey);
	    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

	    const point = ec.keyFromPrivate(seckey).getPublic();
	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyConvert (output, pubkey) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    const point = pair.getPublic();
	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyNegate (output, pubkey) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    const point = pair.getPublic();
	    point.y = point.y.redNeg();
	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyCombine (output, pubkeys) {
	    const pairs = new Array(pubkeys.length);
	    for (let i = 0; i < pubkeys.length; ++i) {
	      pairs[i] = loadPublicKey(pubkeys[i]);
	      if (pairs[i] === null) return 1
	    }

	    let point = pairs[0].getPublic();
	    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);
	    if (point.isInfinity()) return 2

	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyTweakAdd (output, pubkey, tweak) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    tweak = new BN(tweak);
	    if (tweak.cmp(ecparams.n) >= 0) return 2

	    const point = pair.getPublic().add(ecparams.g.mul(tweak));
	    if (point.isInfinity()) return 2

	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyTweakMul (output, pubkey, tweak) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    tweak = new BN(tweak);
	    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

	    const point = pair.getPublic().mul(tweak);
	    savePublicKey(output, point);

	    return 0
	  },

	  signatureNormalize (sig) {
	    const r = new BN(sig.subarray(0, 32));
	    const s = new BN(sig.subarray(32, 64));
	    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

	    if (s.cmp(ec.nh) === 1) {
	      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);
	    }

	    return 0
	  },

	  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
	  // Adapted for Uint8Array instead Buffer
	  signatureExport (obj, sig) {
	    const sigR = sig.subarray(0, 32);
	    const sigS = sig.subarray(32, 64);
	    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
	    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

	    const { output } = obj;

	    // Prepare R
	    let r = output.subarray(4, 4 + 33);
	    r[0] = 0x00;
	    r.set(sigR, 1);

	    let lenR = 33;
	    let posR = 0;
	    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

	    r = r.subarray(posR);
	    if (r[0] & 0x80) return 1
	    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

	    // Prepare S
	    let s = output.subarray(6 + 33, 6 + 33 + 33);
	    s[0] = 0x00;
	    s.set(sigS, 1);

	    let lenS = 33;
	    let posS = 0;
	    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

	    s = s.subarray(posS);
	    if (s[0] & 0x80) return 1
	    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

	    // Set output length for return
	    obj.outputlen = 6 + lenR + lenS;

	    // Output in specified format
	    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
	    output[0] = 0x30;
	    output[1] = obj.outputlen - 2;
	    output[2] = 0x02;
	    output[3] = r.length;
	    output.set(r, 4);
	    output[4 + lenR] = 0x02;
	    output[5 + lenR] = s.length;
	    output.set(s, 6 + lenR);

	    return 0
	  },

	  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
	  // Adapted for Uint8Array instead Buffer
	  signatureImport (output, sig) {
	    if (sig.length < 8) return 1
	    if (sig.length > 72) return 1
	    if (sig[0] !== 0x30) return 1
	    if (sig[1] !== sig.length - 2) return 1
	    if (sig[2] !== 0x02) return 1

	    const lenR = sig[3];
	    if (lenR === 0) return 1
	    if (5 + lenR >= sig.length) return 1
	    if (sig[4 + lenR] !== 0x02) return 1

	    const lenS = sig[5 + lenR];
	    if (lenS === 0) return 1
	    if ((6 + lenR + lenS) !== sig.length) return 1

	    if (sig[4] & 0x80) return 1
	    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

	    if (sig[lenR + 6] & 0x80) return 1
	    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

	    let sigR = sig.subarray(4, 4 + lenR);
	    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);
	    if (sigR.length > 32) return 1

	    let sigS = sig.subarray(6 + lenR);
	    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);
	    if (sigS.length > 32) throw new Error('S length is too long')

	    let r = new BN(sigR);
	    if (r.cmp(ecparams.n) >= 0) r = new BN(0);

	    let s = new BN(sig.subarray(6 + lenR));
	    if (s.cmp(ecparams.n) >= 0) s = new BN(0);

	    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);
	    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);

	    return 0
	  },

	  ecdsaSign (obj, message, seckey, data, noncefn) {
	    if (noncefn) {
	      const _noncefn = noncefn;
	      noncefn = (counter) => {
	        const nonce = _noncefn(message, seckey, null, data, counter);

	        const isValid = nonce instanceof Uint8Array && nonce.length === 32;
	        if (!isValid) throw new Error('This is the way')

	        return new BN(nonce)
	      };
	    }

	    const d = new BN(seckey);
	    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

	    let sig;
	    try {
	      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
	    } catch (err) {
	      return 1
	    }

	    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);
	    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);
	    obj.recid = sig.recoveryParam;

	    return 0
	  },

	  ecdsaVerify (sig, msg32, pubkey) {
	    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };

	    const sigr = new BN(sigObj.r);
	    const sigs = new BN(sigObj.s);
	    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
	    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 2

	    const point = pair.getPublic();
	    const isValid = ec.verify(msg32, sigObj, point);
	    return isValid ? 0 : 3
	  },

	  ecdsaRecover (output, sig, recid, msg32) {
	    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };

	    const sigr = new BN(sigObj.r);
	    const sigs = new BN(sigObj.s);
	    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

	    if (sigr.isZero() || sigs.isZero()) return 2

	    // Can throw `throw new Error('Unable to find sencond key candinate');`
	    let point;
	    try {
	      point = ec.recoverPubKey(msg32, sigObj, recid);
	    } catch (err) {
	      return 2
	    }

	    savePublicKey(output, point);

	    return 0
	  },

	  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    const scalar = new BN(seckey);
	    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

	    const point = pair.getPublic().mul(scalar);

	    if (hashfn === undefined) {
	      const data = point.encode(null, true);
	      const sha256 = ec.hash().update(data).digest();
	      for (let i = 0; i < 32; ++i) output[i] = sha256[i];
	    } else {
	      if (!xbuf) xbuf = new Uint8Array(32);
	      const x = point.getX().toArray('be', 32);
	      for (let i = 0; i < 32; ++i) xbuf[i] = x[i];

	      if (!ybuf) ybuf = new Uint8Array(32);
	      const y = point.getY().toArray('be', 32);
	      for (let i = 0; i < 32; ++i) ybuf[i] = y[i];

	      const hash = hashfn(xbuf, ybuf, data);

	      const isValid = hash instanceof Uint8Array && hash.length === output.length;
	      if (!isValid) return 2

	      output.set(hash);
	    }

	    return 0
	  }
	};
	return elliptic$1;
}

var elliptic;
var hasRequiredElliptic;

function requireElliptic () {
	if (hasRequiredElliptic) return elliptic;
	hasRequiredElliptic = 1;
	elliptic = requireLib()(requireElliptic$1());
	return elliptic;
}

try {
  secp256k1$3.exports = requireBindings$1();
} catch (err) {
  secp256k1$3.exports = requireElliptic();
}

var secp256k1Exports = secp256k1$3.exports;

var random = {};

var randombytes$2 = require$$0$c.randomBytes;

Object.defineProperty(random, "__esModule", { value: true });
var randombytes$1 = randombytes$2;
function getRandomBytes(bytes) {
    return new Promise(function (resolve, reject) {
        randombytes$1(bytes, function (err, resp) {
            if (err) {
                reject(err);
                return;
            }
            resolve(resp);
        });
    });
}
random.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes) {
    return randombytes$1(bytes);
}
random.getRandomBytesSync = getRandomBytesSync;

(function (exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	var secp256k1_1 = secp256k1Exports;
	var random_1 = random;
	var SECP256K1_PRIVATE_KEY_SIZE = 32;
	function createPrivateKey() {
	    return __awaiter(this, void 0, void 0, function () {
	        var pk;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
	                case 1:
	                    pk = _a.sent();
	                    if (secp256k1_1.privateKeyVerify(pk)) {
	                        return [2 /*return*/, pk];
	                    }
	                    return [3 /*break*/, 0];
	                case 2: return [2 /*return*/];
	            }
	        });
	    });
	}
	exports.createPrivateKey = createPrivateKey;
	function createPrivateKeySync() {
	    while (true) {
	        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
	        if (secp256k1_1.privateKeyVerify(pk)) {
	            return pk;
	        }
	    }
	}
	exports.createPrivateKeySync = createPrivateKeySync;
	__export(secp256k1Exports);
	
} (secp256k1$4));

var internal$1 = {};

/*
The MIT License

Copyright (c) 2016 Nick Dodson. nickdodson.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
 */
Object.defineProperty(internal$1, "__esModule", { value: true });
internal$1.isHexString = internal$1.getKeys = internal$1.fromAscii = internal$1.fromUtf8 = internal$1.toAscii = internal$1.arrayContainsArray = internal$1.getBinarySize = internal$1.padToEven = internal$1.stripHexPrefix = internal$1.isHexPrefixed = void 0;
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param str the string input value
 * @return a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
function isHexPrefixed$3(str) {
    if (typeof str !== 'string') {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
    }
    return str[0] === '0' && str[1] === 'x';
}
internal$1.isHexPrefixed = isHexPrefixed$3;
/**
 * Removes '0x' from a given `String` if present
 * @param str the string value
 * @returns the string without 0x prefix
 */
const stripHexPrefix$4 = (str) => {
    if (typeof str !== 'string')
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
    return isHexPrefixed$3(str) ? str.slice(2) : str;
};
internal$1.stripHexPrefix = stripHexPrefix$4;
/**
 * Pads a `String` to have an even length
 * @param value
 * @return output
 */
function padToEven$2(value) {
    let a = value;
    if (typeof a !== 'string') {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
    }
    if (a.length % 2)
        a = `0${a}`;
    return a;
}
internal$1.padToEven = padToEven$2;
/**
 * Get the binary size of a string
 * @param str
 * @returns the number of bytes contained within the string
 */
function getBinarySize$1(str) {
    if (typeof str !== 'string') {
        throw new Error(`[getBinarySize] method requires input type 'string', recieved ${typeof str}`);
    }
    return Buffer.byteLength(str, 'utf8');
}
internal$1.getBinarySize = getBinarySize$1;
/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param superset
 * @param subset
 *
 */
function arrayContainsArray$1(superset, subset, some) {
    if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
    }
    if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
    }
    return subset[some ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);
}
internal$1.arrayContainsArray = arrayContainsArray$1;
/**
 * Should be called to get ascii from its hex representation
 *
 * @param string in hex
 * @returns ascii string representation of hex value
 */
function toAscii$1(hex) {
    let str = '';
    let i = 0;
    const l = hex.length;
    if (hex.substring(0, 2) === '0x')
        i = 2;
    for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }
    return str;
}
internal$1.toAscii = toAscii$1;
/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @param string
 * @param optional padding
 * @returns hex representation of input string
 */
function fromUtf8$1(stringValue) {
    const str = Buffer.from(stringValue, 'utf8');
    return `0x${padToEven$2(str.toString('hex')).replace(/^0+|0+$/g, '')}`;
}
internal$1.fromUtf8 = fromUtf8$1;
/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @param  string
 * @param  optional padding
 * @returns  hex representation of input string
 */
function fromAscii$1(stringValue) {
    let hex = '';
    for (let i = 0; i < stringValue.length; i++) {
        const code = stringValue.charCodeAt(i);
        const n = code.toString(16);
        hex += n.length < 2 ? `0${n}` : n;
    }
    return `0x${hex}`;
}
internal$1.fromAscii = fromAscii$1;
/**
 * Returns the keys from an array of objects.
 * @example
 * ```js
 * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']
 *````
 * @param  params
 * @param  key
 * @param  allowEmpty
 * @returns output just a simple array of output keys
 */
function getKeys$1(params, key, allowEmpty) {
    if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
    }
    if (typeof key !== 'string') {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
    }
    const result = [];
    for (let i = 0; i < params.length; i++) {
        let value = params[i][key];
        if (allowEmpty && !value) {
            value = '';
        }
        else if (typeof value !== 'string') {
            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
        }
        result.push(value);
    }
    return result;
}
internal$1.getKeys = getKeys$1;
/**
 * Is the string a hex string.
 *
 * @param  value
 * @param  length
 * @returns  output the string is a hex string
 */
function isHexString$1(value, length) {
    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
    if (length && value.length !== 2 + 2 * length)
        return false;
    return true;
}
internal$1.isHexString = isHexString$1;

var bytes$2 = {};

var helpers$1 = {};

Object.defineProperty(helpers$1, "__esModule", { value: true });
helpers$1.assertIsString = helpers$1.assertIsArray = helpers$1.assertIsBuffer = helpers$1.assertIsHexString = void 0;
const internal_1$2 = internal$1;
/**
 * Throws if a string is not hex prefixed
 * @param {string} input string to check hex prefix of
 */
const assertIsHexString$1 = function (input) {
    if (!(0, internal_1$2.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers$1.assertIsHexString = assertIsHexString$1;
/**
 * Throws if input is not a buffer
 * @param {Buffer} input value to check
 */
const assertIsBuffer$1 = function (input) {
    if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers$1.assertIsBuffer = assertIsBuffer$1;
/**
 * Throws if input is not an array
 * @param {number[]} input value to check
 */
const assertIsArray$1 = function (input) {
    if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers$1.assertIsArray = assertIsArray$1;
/**
 * Throws if input is not a string
 * @param {string} input value to check
 */
const assertIsString$1 = function (input) {
    if (typeof input !== 'string') {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers$1.assertIsString = assertIsString$1;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
	const externals_1 = externals;
	const internal_1 = internal$1;
	const helpers_1 = helpers$1;
	/**
	 * Converts a `Number` into a hex `String`
	 * @param {Number} i
	 * @return {String}
	 */
	const intToHex = function (i) {
	    if (!Number.isSafeInteger(i) || i < 0) {
	        throw new Error(`Received an invalid integer type: ${i}`);
	    }
	    return `0x${i.toString(16)}`;
	};
	exports.intToHex = intToHex;
	/**
	 * Converts an `Number` to a `Buffer`
	 * @param {Number} i
	 * @return {Buffer}
	 */
	const intToBuffer = function (i) {
	    const hex = (0, exports.intToHex)(i);
	    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');
	};
	exports.intToBuffer = intToBuffer;
	/**
	 * Returns a buffer filled with 0s.
	 * @param bytes the number of bytes the buffer should be
	 */
	const zeros = function (bytes) {
	    return Buffer.allocUnsafe(bytes).fill(0);
	};
	exports.zeros = zeros;
	/**
	 * Pads a `Buffer` with zeros till it has `length` bytes.
	 * Truncates the beginning or end of input if its length exceeds `length`.
	 * @param msg the value to pad (Buffer)
	 * @param length the number of bytes the output should be
	 * @param right whether to start padding form the left or right
	 * @return (Buffer)
	 */
	const setLength = function (msg, length, right) {
	    const buf = (0, exports.zeros)(length);
	    if (right) {
	        if (msg.length < length) {
	            msg.copy(buf);
	            return buf;
	        }
	        return msg.slice(0, length);
	    }
	    else {
	        if (msg.length < length) {
	            msg.copy(buf, length - msg.length);
	            return buf;
	        }
	        return msg.slice(-length);
	    }
	};
	/**
	 * Left Pads a `Buffer` with leading zeros till it has `length` bytes.
	 * Or it truncates the beginning if it exceeds.
	 * @param msg the value to pad (Buffer)
	 * @param length the number of bytes the output should be
	 * @return (Buffer)
	 */
	const setLengthLeft = function (msg, length) {
	    (0, helpers_1.assertIsBuffer)(msg);
	    return setLength(msg, length, false);
	};
	exports.setLengthLeft = setLengthLeft;
	/**
	 * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.
	 * it truncates the end if it exceeds.
	 * @param msg the value to pad (Buffer)
	 * @param length the number of bytes the output should be
	 * @return (Buffer)
	 */
	const setLengthRight = function (msg, length) {
	    (0, helpers_1.assertIsBuffer)(msg);
	    return setLength(msg, length, true);
	};
	exports.setLengthRight = setLengthRight;
	/**
	 * Trims leading zeros from a `Buffer`, `String` or `Number[]`.
	 * @param a (Buffer|Array|String)
	 * @return (Buffer|Array|String)
	 */
	const stripZeros = function (a) {
	    let first = a[0];
	    while (a.length > 0 && first.toString() === '0') {
	        a = a.slice(1);
	        first = a[0];
	    }
	    return a;
	};
	/**
	 * Trims leading zeros from a `Buffer`.
	 * @param a (Buffer)
	 * @return (Buffer)
	 */
	const unpadBuffer = function (a) {
	    (0, helpers_1.assertIsBuffer)(a);
	    return stripZeros(a);
	};
	exports.unpadBuffer = unpadBuffer;
	/**
	 * Trims leading zeros from an `Array` (of numbers).
	 * @param a (number[])
	 * @return (number[])
	 */
	const unpadArray = function (a) {
	    (0, helpers_1.assertIsArray)(a);
	    return stripZeros(a);
	};
	exports.unpadArray = unpadArray;
	/**
	 * Trims leading zeros from a hex-prefixed `String`.
	 * @param a (String)
	 * @return (String)
	 */
	const unpadHexString = function (a) {
	    (0, helpers_1.assertIsHexString)(a);
	    a = (0, internal_1.stripHexPrefix)(a);
	    return stripZeros(a);
	};
	exports.unpadHexString = unpadHexString;
	/**
	 * Attempts to turn a value into a `Buffer`.
	 * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects
	 * with a `toArray()` or `toBuffer()` method.
	 * @param v the value
	 */
	const toBuffer = function (v) {
	    if (v === null || v === undefined) {
	        return Buffer.allocUnsafe(0);
	    }
	    if (Buffer.isBuffer(v)) {
	        return Buffer.from(v);
	    }
	    if (Array.isArray(v) || v instanceof Uint8Array) {
	        return Buffer.from(v);
	    }
	    if (typeof v === 'string') {
	        if (!(0, internal_1.isHexString)(v)) {
	            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
	        }
	        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');
	    }
	    if (typeof v === 'number') {
	        return (0, exports.intToBuffer)(v);
	    }
	    if (externals_1.BN.isBN(v)) {
	        if (v.isNeg()) {
	            throw new Error(`Cannot convert negative BN to buffer. Given: ${v}`);
	        }
	        return v.toArrayLike(Buffer);
	    }
	    if (v.toArray) {
	        // converts a BN to a Buffer
	        return Buffer.from(v.toArray());
	    }
	    if (v.toBuffer) {
	        return Buffer.from(v.toBuffer());
	    }
	    throw new Error('invalid type');
	};
	exports.toBuffer = toBuffer;
	/**
	 * Converts a `Buffer` to a `Number`.
	 * @param buf `Buffer` object to convert
	 * @throws If the input number exceeds 53 bits.
	 */
	const bufferToInt = function (buf) {
	    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();
	};
	exports.bufferToInt = bufferToInt;
	/**
	 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
	 * @param buf `Buffer` object to convert
	 */
	const bufferToHex = function (buf) {
	    buf = (0, exports.toBuffer)(buf);
	    return '0x' + buf.toString('hex');
	};
	exports.bufferToHex = bufferToHex;
	/**
	 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
	 * @param num Signed integer value
	 */
	const fromSigned = function (num) {
	    return new externals_1.BN(num).fromTwos(256);
	};
	exports.fromSigned = fromSigned;
	/**
	 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
	 * @param num
	 */
	const toUnsigned = function (num) {
	    return Buffer.from(num.toTwos(256).toArray());
	};
	exports.toUnsigned = toUnsigned;
	/**
	 * Adds "0x" to a given `String` if it does not already start with "0x".
	 */
	const addHexPrefix = function (str) {
	    if (typeof str !== 'string') {
	        return str;
	    }
	    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;
	};
	exports.addHexPrefix = addHexPrefix;
	/**
	 * Returns the utf8 string representation from a hex string.
	 *
	 * Examples:
	 *
	 * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'
	 * Input 2: '657468657265756d'
	 * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'
	 *
	 * Output (all 3 input variants): 'ethereum'
	 *
	 * Note that this method is not intended to be used with hex strings
	 * representing quantities in both big endian or little endian notation.
	 *
	 * @param string Hex string, should be `0x` prefixed
	 * @return Utf8 string
	 */
	const toUtf8 = function (hex) {
	    const zerosRegexp = /^(00)+|(00)+$/g;
	    hex = (0, internal_1.stripHexPrefix)(hex);
	    if (hex.length % 2 !== 0) {
	        throw new Error('Invalid non-even hex string input for toUtf8() provided');
	    }
	    const bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');
	    return bufferVal.toString('utf8');
	};
	exports.toUtf8 = toUtf8;
	/**
	 * Converts a `Buffer` or `Array` to JSON.
	 * @param ba (Buffer|Array)
	 * @return (Array|String|null)
	 */
	const baToJSON = function (ba) {
	    if (Buffer.isBuffer(ba)) {
	        return `0x${ba.toString('hex')}`;
	    }
	    else if (ba instanceof Array) {
	        const array = [];
	        for (let i = 0; i < ba.length; i++) {
	            array.push((0, exports.baToJSON)(ba[i]));
	        }
	        return array;
	    }
	};
	exports.baToJSON = baToJSON;
	/**
	 * Checks provided Buffers for leading zeroes and throws if found.
	 *
	 * Examples:
	 *
	 * Valid values: 0x1, 0x, 0x01, 0x1234
	 * Invalid values: 0x0, 0x00, 0x001, 0x0001
	 *
	 * Note: This method is useful for validating that RLP encoded integers comply with the rule that all
	 * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes
	 * @param values An object containing string keys and Buffer values
	 * @throws if any provided value is found to have leading zero bytes
	 */
	const validateNoLeadingZeroes = function (values) {
	    for (const [k, v] of Object.entries(values)) {
	        if (v !== undefined && v.length > 0 && v[0] === 0) {
	            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);
	        }
	    }
	};
	exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
	function arrToBufArr(arr) {
	    if (!Array.isArray(arr)) {
	        return Buffer.from(arr);
	    }
	    return arr.map((a) => arrToBufArr(a));
	}
	exports.arrToBufArr = arrToBufArr;
	function bufArrToArr(arr) {
	    if (!Array.isArray(arr)) {
	        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);
	    }
	    return arr.map((a) => bufArrToArr(a));
	}
	exports.bufArrToArr = bufArrToArr;
	
} (bytes$2));

var hash$1 = {};

var keccak$3 = {};

var hashUtils = {};

Object.defineProperty(hashUtils, "__esModule", { value: true });
function createHashFunction(hashConstructor) {
    return function (msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
    };
}
hashUtils.createHashFunction = createHashFunction;

var keccak$2 = {exports: {}};

var bindings;
var hasRequiredBindings;

function requireBindings () {
	if (hasRequiredBindings) return bindings;
	hasRequiredBindings = 1;
	const nativeAddon = requireNodeGypBuild()(__dirname);
	if (typeof nativeAddon !== 'function') {
	  // Some new runtimes (bun) don't support N-API
	  // but the build step incorrectly succeeds.
	  // The value should be a function, but in bun it returns
	  // an empty object {} so we use typeof to check that
	  // it is a function and throw otherwise.
	  // This throw will cause "keccak" import to fallback to JS.
	  throw new Error('Native add-on failed to load')
	}
	bindings = api(nativeAddon);
	return bindings;
}

try {
  keccak$2.exports = requireBindings();
} catch (err) {
  keccak$2.exports = js;
}

var keccakExports = keccak$2.exports;

Object.defineProperty(keccak$3, "__esModule", { value: true });
var hash_utils_1 = hashUtils;
var createKeccakHash = keccakExports;
keccak$3.keccak224 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak224");
});
keccak$3.keccak256 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak256");
});
keccak$3.keccak384 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak384");
});
keccak$3.keccak512 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak512");
});

var createHash = require$$0$c.createHash;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;
	const keccak_1 = keccak$3;
	const createHash$1 = createHash;
	const externals_1 = externals;
	const bytes_1 = bytes$2;
	const helpers_1 = helpers$1;
	/**
	 * Creates Keccak hash of a Buffer input
	 * @param a The input data (Buffer)
	 * @param bits (number = 256) The Keccak width
	 */
	const keccak = function (a, bits = 256) {
	    (0, helpers_1.assertIsBuffer)(a);
	    switch (bits) {
	        case 224: {
	            return (0, keccak_1.keccak224)(a);
	        }
	        case 256: {
	            return (0, keccak_1.keccak256)(a);
	        }
	        case 384: {
	            return (0, keccak_1.keccak384)(a);
	        }
	        case 512: {
	            return (0, keccak_1.keccak512)(a);
	        }
	        default: {
	            throw new Error(`Invald algorithm: keccak${bits}`);
	        }
	    }
	};
	exports.keccak = keccak;
	/**
	 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
	 * @param a The input data (Buffer)
	 */
	const keccak256 = function (a) {
	    return (0, exports.keccak)(a);
	};
	exports.keccak256 = keccak256;
	/**
	 * Creates Keccak hash of a utf-8 string input
	 * @param a The input data (String)
	 * @param bits (number = 256) The Keccak width
	 */
	const keccakFromString = function (a, bits = 256) {
	    (0, helpers_1.assertIsString)(a);
	    const buf = Buffer.from(a, 'utf8');
	    return (0, exports.keccak)(buf, bits);
	};
	exports.keccakFromString = keccakFromString;
	/**
	 * Creates Keccak hash of an 0x-prefixed string input
	 * @param a The input data (String)
	 * @param bits (number = 256) The Keccak width
	 */
	const keccakFromHexString = function (a, bits = 256) {
	    (0, helpers_1.assertIsHexString)(a);
	    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
	};
	exports.keccakFromHexString = keccakFromHexString;
	/**
	 * Creates Keccak hash of a number array input
	 * @param a The input data (number[])
	 * @param bits (number = 256) The Keccak width
	 */
	const keccakFromArray = function (a, bits = 256) {
	    (0, helpers_1.assertIsArray)(a);
	    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
	};
	exports.keccakFromArray = keccakFromArray;
	/**
	 * Creates SHA256 hash of an input.
	 * @param  a The input data (Buffer|Array|String)
	 */
	const _sha256 = function (a) {
	    a = (0, bytes_1.toBuffer)(a);
	    return createHash$1('sha256').update(a).digest();
	};
	/**
	 * Creates SHA256 hash of a Buffer input.
	 * @param a The input data (Buffer)
	 */
	const sha256 = function (a) {
	    (0, helpers_1.assertIsBuffer)(a);
	    return _sha256(a);
	};
	exports.sha256 = sha256;
	/**
	 * Creates SHA256 hash of a string input.
	 * @param a The input data (string)
	 */
	const sha256FromString = function (a) {
	    (0, helpers_1.assertIsString)(a);
	    return _sha256(a);
	};
	exports.sha256FromString = sha256FromString;
	/**
	 * Creates SHA256 hash of a number[] input.
	 * @param a The input data (number[])
	 */
	const sha256FromArray = function (a) {
	    (0, helpers_1.assertIsArray)(a);
	    return _sha256(a);
	};
	exports.sha256FromArray = sha256FromArray;
	/**
	 * Creates RIPEMD160 hash of the input.
	 * @param a The input data (Buffer|Array|String|Number)
	 * @param padded Whether it should be padded to 256 bits or not
	 */
	const _ripemd160 = function (a, padded) {
	    a = (0, bytes_1.toBuffer)(a);
	    const hash = createHash$1('rmd160').update(a).digest();
	    if (padded === true) {
	        return (0, bytes_1.setLengthLeft)(hash, 32);
	    }
	    else {
	        return hash;
	    }
	};
	/**
	 * Creates RIPEMD160 hash of a Buffer input.
	 * @param a The input data (Buffer)
	 * @param padded Whether it should be padded to 256 bits or not
	 */
	const ripemd160 = function (a, padded) {
	    (0, helpers_1.assertIsBuffer)(a);
	    return _ripemd160(a, padded);
	};
	exports.ripemd160 = ripemd160;
	/**
	 * Creates RIPEMD160 hash of a string input.
	 * @param a The input data (String)
	 * @param padded Whether it should be padded to 256 bits or not
	 */
	const ripemd160FromString = function (a, padded) {
	    (0, helpers_1.assertIsString)(a);
	    return _ripemd160(a, padded);
	};
	exports.ripemd160FromString = ripemd160FromString;
	/**
	 * Creates RIPEMD160 hash of a number[] input.
	 * @param a The input data (number[])
	 * @param padded Whether it should be padded to 256 bits or not
	 */
	const ripemd160FromArray = function (a, padded) {
	    (0, helpers_1.assertIsArray)(a);
	    return _ripemd160(a, padded);
	};
	exports.ripemd160FromArray = ripemd160FromArray;
	/**
	 * Creates SHA-3 hash of the RLP encoded version of the input.
	 * @param a The input data
	 */
	const rlphash = function (a) {
	    return (0, exports.keccak)(externals_1.rlp.encode(a));
	};
	exports.rlphash = rlphash;
	
} (hash$1));

var types$4 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;
	const externals_1 = externals;
	const internal_1 = internal$1;
	const bytes_1 = bytes$2;
	/**
	 * Convert BN to 0x-prefixed hex string.
	 */
	function bnToHex(value) {
	    return `0x${value.toString(16)}`;
	}
	exports.bnToHex = bnToHex;
	/**
	 * Convert value from BN to an unpadded Buffer
	 * (useful for RLP transport)
	 * @param value value to convert
	 */
	function bnToUnpaddedBuffer(value) {
	    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`
	    // for compatibility with browserify and similar tools
	    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));
	}
	exports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
	/**
	 * Deprecated alias for {@link bnToUnpaddedBuffer}
	 * @deprecated
	 */
	function bnToRlp(value) {
	    return bnToUnpaddedBuffer(value);
	}
	exports.bnToRlp = bnToRlp;
	/**
	 * Type output options
	 */
	var TypeOutput;
	(function (TypeOutput) {
	    TypeOutput[TypeOutput["Number"] = 0] = "Number";
	    TypeOutput[TypeOutput["BN"] = 1] = "BN";
	    TypeOutput[TypeOutput["Buffer"] = 2] = "Buffer";
	    TypeOutput[TypeOutput["PrefixedHexString"] = 3] = "PrefixedHexString";
	})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
	function toType(input, outputType) {
	    if (input === null) {
	        return null;
	    }
	    if (input === undefined) {
	        return undefined;
	    }
	    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {
	        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
	    }
	    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {
	        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
	    }
	    const output = (0, bytes_1.toBuffer)(input);
	    if (outputType === TypeOutput.Buffer) {
	        return output;
	    }
	    else if (outputType === TypeOutput.BN) {
	        return new externals_1.BN(output);
	    }
	    else if (outputType === TypeOutput.Number) {
	        const bn = new externals_1.BN(output);
	        const max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());
	        if (bn.gt(max)) {
	            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');
	        }
	        return bn.toNumber();
	    }
	    else {
	        // outputType === TypeOutput.PrefixedHexString
	        return `0x${output.toString('hex')}`;
	    }
	}
	exports.toType = toType;
	
} (types$4));

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
	const assert_1 = __importDefault(require$$0$8);
	const externals_1 = externals;
	const secp256k1_1 = secp256k1$4;
	const internal_1 = internal$1;
	const constants_1 = constants$3;
	const bytes_1 = bytes$2;
	const hash_1 = hash$1;
	const helpers_1 = helpers$1;
	const types_1 = types$4;
	class Account {
	    /**
	     * This constructor assigns and validates the values.
	     * Use the static factory methods to assist in creating an Account from varying data types.
	     */
	    constructor(nonce = new externals_1.BN(0), balance = new externals_1.BN(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
	        this.nonce = nonce;
	        this.balance = balance;
	        this.stateRoot = stateRoot;
	        this.codeHash = codeHash;
	        this._validate();
	    }
	    static fromAccountData(accountData) {
	        const { nonce, balance, stateRoot, codeHash } = accountData;
	        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);
	    }
	    static fromRlpSerializedAccount(serialized) {
	        const values = externals_1.rlp.decode(serialized);
	        if (!Array.isArray(values)) {
	            throw new Error('Invalid serialized account input. Must be array');
	        }
	        return this.fromValuesArray(values);
	    }
	    static fromValuesArray(values) {
	        const [nonce, balance, stateRoot, codeHash] = values;
	        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);
	    }
	    _validate() {
	        if (this.nonce.lt(new externals_1.BN(0))) {
	            throw new Error('nonce must be greater than zero');
	        }
	        if (this.balance.lt(new externals_1.BN(0))) {
	            throw new Error('balance must be greater than zero');
	        }
	        if (this.stateRoot.length !== 32) {
	            throw new Error('stateRoot must have a length of 32');
	        }
	        if (this.codeHash.length !== 32) {
	            throw new Error('codeHash must have a length of 32');
	        }
	    }
	    /**
	     * Returns a Buffer Array of the raw Buffers for the account, in order.
	     */
	    raw() {
	        return [
	            (0, types_1.bnToUnpaddedBuffer)(this.nonce),
	            (0, types_1.bnToUnpaddedBuffer)(this.balance),
	            this.stateRoot,
	            this.codeHash,
	        ];
	    }
	    /**
	     * Returns the RLP serialization of the account as a `Buffer`.
	     */
	    serialize() {
	        return externals_1.rlp.encode(this.raw());
	    }
	    /**
	     * Returns a `Boolean` determining if the account is a contract.
	     */
	    isContract() {
	        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
	    }
	    /**
	     * Returns a `Boolean` determining if the account is empty complying to the definition of
	     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
	     * "An account is considered empty when it has no code and zero nonce and zero balance."
	     */
	    isEmpty() {
	        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
	    }
	}
	exports.Account = Account;
	/**
	 * Checks if the address is a valid. Accepts checksummed addresses too.
	 */
	const isValidAddress = function (hexAddress) {
	    try {
	        (0, helpers_1.assertIsString)(hexAddress);
	    }
	    catch (e) {
	        return false;
	    }
	    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
	};
	exports.isValidAddress = isValidAddress;
	/**
	 * Returns a checksummed address.
	 *
	 * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
	 * has the effect of checksummed addresses for one chain having invalid checksums for others.
	 * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).
	 *
	 * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not
	 * backwards compatible to the original widely adopted checksum format standard introduced in
	 * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.
	 * Usage of this EIP is therefore discouraged unless you have a very targeted use case.
	 */
	const toChecksumAddress = function (hexAddress, eip1191ChainId) {
	    (0, helpers_1.assertIsHexString)(hexAddress);
	    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
	    let prefix = '';
	    if (eip1191ChainId) {
	        const chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);
	        prefix = chainId.toString() + '0x';
	    }
	    const hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');
	    let ret = '0x';
	    for (let i = 0; i < address.length; i++) {
	        if (parseInt(hash[i], 16) >= 8) {
	            ret += address[i].toUpperCase();
	        }
	        else {
	            ret += address[i];
	        }
	    }
	    return ret;
	};
	exports.toChecksumAddress = toChecksumAddress;
	/**
	 * Checks if the address is a valid checksummed address.
	 *
	 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
	 */
	const isValidChecksumAddress = function (hexAddress, eip1191ChainId) {
	    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
	};
	exports.isValidChecksumAddress = isValidChecksumAddress;
	/**
	 * Generates an address of a newly created contract.
	 * @param from The address which is creating this new address
	 * @param nonce The nonce of the from account
	 */
	const generateAddress = function (from, nonce) {
	    (0, helpers_1.assertIsBuffer)(from);
	    (0, helpers_1.assertIsBuffer)(nonce);
	    const nonceBN = new externals_1.BN(nonce);
	    if (nonceBN.isZero()) {
	        // in RLP we want to encode null in the case of zero nonce
	        // read the RLP documentation for an answer if you dare
	        return (0, hash_1.rlphash)([from, null]).slice(-20);
	    }
	    // Only take the lower 160bits of the hash
	    return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);
	};
	exports.generateAddress = generateAddress;
	/**
	 * Generates an address for a contract created using CREATE2.
	 * @param from The address which is creating this new address
	 * @param salt A salt
	 * @param initCode The init code of the contract being created
	 */
	const generateAddress2 = function (from, salt, initCode) {
	    (0, helpers_1.assertIsBuffer)(from);
	    (0, helpers_1.assertIsBuffer)(salt);
	    (0, helpers_1.assertIsBuffer)(initCode);
	    (0, assert_1.default)(from.length === 20);
	    (0, assert_1.default)(salt.length === 32);
	    const address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));
	    return address.slice(-20);
	};
	exports.generateAddress2 = generateAddress2;
	/**
	 * Checks if the private key satisfies the rules of the curve secp256k1.
	 */
	const isValidPrivate = function (privateKey) {
	    return (0, secp256k1_1.privateKeyVerify)(privateKey);
	};
	exports.isValidPrivate = isValidPrivate;
	/**
	 * Checks if the public key satisfies the rules of the curve secp256k1
	 * and the requirements of Ethereum.
	 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
	 * @param sanitize Accept public keys in other formats
	 */
	const isValidPublic = function (publicKey, sanitize = false) {
	    (0, helpers_1.assertIsBuffer)(publicKey);
	    if (publicKey.length === 64) {
	        // Convert to SEC1 for secp256k1
	        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));
	    }
	    if (!sanitize) {
	        return false;
	    }
	    return (0, secp256k1_1.publicKeyVerify)(publicKey);
	};
	exports.isValidPublic = isValidPublic;
	/**
	 * Returns the ethereum address of a given public key.
	 * Accepts "Ethereum public keys" and SEC1 encoded keys.
	 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
	 * @param sanitize Accept public keys in other formats
	 */
	const pubToAddress = function (pubKey, sanitize = false) {
	    (0, helpers_1.assertIsBuffer)(pubKey);
	    if (sanitize && pubKey.length !== 64) {
	        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));
	    }
	    (0, assert_1.default)(pubKey.length === 64);
	    // Only take the lower 160bits of the hash
	    return (0, hash_1.keccak)(pubKey).slice(-20);
	};
	exports.pubToAddress = pubToAddress;
	exports.publicToAddress = exports.pubToAddress;
	/**
	 * Returns the ethereum public key of a given private key.
	 * @param privateKey A private key must be 256 bits wide
	 */
	const privateToPublic = function (privateKey) {
	    (0, helpers_1.assertIsBuffer)(privateKey);
	    // skip the type flag and use the X, Y points
	    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);
	};
	exports.privateToPublic = privateToPublic;
	/**
	 * Returns the ethereum address of a given private key.
	 * @param privateKey A private key must be 256 bits wide
	 */
	const privateToAddress = function (privateKey) {
	    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
	};
	exports.privateToAddress = privateToAddress;
	/**
	 * Converts a public key to the Ethereum format.
	 */
	const importPublic = function (publicKey) {
	    (0, helpers_1.assertIsBuffer)(publicKey);
	    if (publicKey.length !== 64) {
	        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));
	    }
	    return publicKey;
	};
	exports.importPublic = importPublic;
	/**
	 * Returns the zero address.
	 */
	const zeroAddress = function () {
	    const addressLength = 20;
	    const addr = (0, bytes_1.zeros)(addressLength);
	    return (0, bytes_1.bufferToHex)(addr);
	};
	exports.zeroAddress = zeroAddress;
	/**
	 * Checks if a given address is the zero address.
	 */
	const isZeroAddress = function (hexAddress) {
	    try {
	        (0, helpers_1.assertIsString)(hexAddress);
	    }
	    catch (e) {
	        return false;
	    }
	    const zeroAddr = (0, exports.zeroAddress)();
	    return zeroAddr === hexAddress;
	};
	exports.isZeroAddress = isZeroAddress;
	
} (account$1));

var address$2 = {};

var __importDefault$Q = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(address$2, "__esModule", { value: true });
address$2.Address = void 0;
const assert_1$1 = __importDefault$Q(require$$0$8);
const externals_1$2 = externals;
const bytes_1$5 = bytes$2;
const account_1$1 = account$1;
class Address$1 {
    constructor(buf) {
        (0, assert_1$1.default)(buf.length === 20, 'Invalid address length');
        this.buf = buf;
    }
    /**
     * Returns the zero address.
     */
    static zero() {
        return new Address$1((0, bytes_1$5.zeros)(20));
    }
    /**
     * Returns an Address object from a hex-encoded string.
     * @param str - Hex-encoded address
     */
    static fromString(str) {
        (0, assert_1$1.default)((0, account_1$1.isValidAddress)(str), 'Invalid address');
        return new Address$1((0, bytes_1$5.toBuffer)(str));
    }
    /**
     * Returns an address for a given public key.
     * @param pubKey The two points of an uncompressed key
     */
    static fromPublicKey(pubKey) {
        (0, assert_1$1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');
        const buf = (0, account_1$1.pubToAddress)(pubKey);
        return new Address$1(buf);
    }
    /**
     * Returns an address for a given private key.
     * @param privateKey A private key must be 256 bits wide
     */
    static fromPrivateKey(privateKey) {
        (0, assert_1$1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');
        const buf = (0, account_1$1.privateToAddress)(privateKey);
        return new Address$1(buf);
    }
    /**
     * Generates an address for a newly created contract.
     * @param from The address which is creating this new address
     * @param nonce The nonce of the from account
     */
    static generate(from, nonce) {
        (0, assert_1$1.default)(externals_1$2.BN.isBN(nonce));
        return new Address$1((0, account_1$1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));
    }
    /**
     * Generates an address for a contract created using CREATE2.
     * @param from The address which is creating this new address
     * @param salt A salt
     * @param initCode The init code of the contract being created
     */
    static generate2(from, salt, initCode) {
        (0, assert_1$1.default)(Buffer.isBuffer(salt));
        (0, assert_1$1.default)(Buffer.isBuffer(initCode));
        return new Address$1((0, account_1$1.generateAddress2)(from.buf, salt, initCode));
    }
    /**
     * Is address equal to another.
     */
    equals(address) {
        return this.buf.equals(address.buf);
    }
    /**
     * Is address zero.
     */
    isZero() {
        return this.equals(Address$1.zero());
    }
    /**
     * True if address is in the address range defined
     * by EIP-1352
     */
    isPrecompileOrSystemAddress() {
        const addressBN = new externals_1$2.BN(this.buf);
        const rangeMin = new externals_1$2.BN(0);
        const rangeMax = new externals_1$2.BN('ffff', 'hex');
        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
    }
    /**
     * Returns hex encoding of address.
     */
    toString() {
        return '0x' + this.buf.toString('hex');
    }
    /**
     * Returns Buffer representation of address.
     */
    toBuffer() {
        return Buffer.from(this.buf);
    }
}
address$2.Address = Address$1;

var signature$1 = {};

Object.defineProperty(signature$1, "__esModule", { value: true });
signature$1.hashPersonalMessage = signature$1.isValidSignature = signature$1.fromRpcSig = signature$1.toCompactSig = signature$1.toRpcSig = signature$1.ecrecover = signature$1.ecsign = void 0;
const secp256k1_1$1 = secp256k1$4;
const externals_1$1 = externals;
const bytes_1$4 = bytes$2;
const hash_1 = hash$1;
const helpers_1$1 = helpers$1;
const types_1$4 = types$4;
function ecsign$1(msgHash, privateKey, chainId) {
    const { signature, recid: recovery } = (0, secp256k1_1$1.ecdsaSign)(msgHash, privateKey);
    const r = Buffer.from(signature.slice(0, 32));
    const s = Buffer.from(signature.slice(32, 64));
    if (!chainId || typeof chainId === 'number') {
        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)
        if (chainId && !Number.isSafeInteger(chainId)) {
            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
        }
        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
        return { r, s, v };
    }
    const chainIdBN = (0, types_1$4.toType)(chainId, types_1$4.TypeOutput.BN);
    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);
    return { r, s, v };
}
signature$1.ecsign = ecsign$1;
function calculateSigRecovery$1(v, chainId) {
    const vBN = (0, types_1$4.toType)(v, types_1$4.TypeOutput.BN);
    if (vBN.eqn(0) || vBN.eqn(1))
        return (0, types_1$4.toType)(v, types_1$4.TypeOutput.BN);
    if (!chainId) {
        return vBN.subn(27);
    }
    const chainIdBN = (0, types_1$4.toType)(chainId, types_1$4.TypeOutput.BN);
    return vBN.sub(chainIdBN.muln(2).addn(35));
}
function isValidSigRecovery$1(recovery) {
    const rec = new externals_1$1.BN(recovery);
    return rec.eqn(0) || rec.eqn(1);
}
/**
 * ECDSA public key recovery from signature.
 * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
 * @returns Recovered public key
 */
const ecrecover$1 = function (msgHash, v, r, s, chainId) {
    const signature = Buffer.concat([(0, bytes_1$4.setLengthLeft)(r, 32), (0, bytes_1$4.setLengthLeft)(s, 32)], 64);
    const recovery = calculateSigRecovery$1(v, chainId);
    if (!isValidSigRecovery$1(recovery)) {
        throw new Error('Invalid signature v value');
    }
    const senderPubKey = (0, secp256k1_1$1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);
    return Buffer.from((0, secp256k1_1$1.publicKeyConvert)(senderPubKey, false).slice(1));
};
signature$1.ecrecover = ecrecover$1;
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
 * @returns Signature
 */
const toRpcSig$1 = function (v, r, s, chainId) {
    const recovery = calculateSigRecovery$1(v, chainId);
    if (!isValidSigRecovery$1(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return (0, bytes_1$4.bufferToHex)(Buffer.concat([(0, bytes_1$4.setLengthLeft)(r, 32), (0, bytes_1$4.setLengthLeft)(s, 32), (0, bytes_1$4.toBuffer)(v)]));
};
signature$1.toRpcSig = toRpcSig$1;
/**
 * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).
 * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
 * @returns Signature
 */
const toCompactSig$1 = function (v, r, s, chainId) {
    const recovery = calculateSigRecovery$1(v, chainId);
    if (!isValidSigRecovery$1(recovery)) {
        throw new Error('Invalid signature v value');
    }
    const vn = (0, types_1$4.toType)(v, types_1$4.TypeOutput.Number);
    let ss = s;
    if ((vn > 28 && vn % 2 === 1) || vn === 1 || vn === 28) {
        ss = Buffer.from(s);
        ss[0] |= 0x80;
    }
    return (0, bytes_1$4.bufferToHex)(Buffer.concat([(0, bytes_1$4.setLengthLeft)(r, 32), (0, bytes_1$4.setLengthLeft)(ss, 32)]));
};
signature$1.toCompactSig = toCompactSig$1;
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes
 * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.
 */
const fromRpcSig$1 = function (sig) {
    const buf = (0, bytes_1$4.toBuffer)(sig);
    let r;
    let s;
    let v;
    if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1$4.bufferToInt)(buf.slice(64));
    }
    else if (buf.length === 64) {
        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1$4.bufferToInt)(buf.slice(32, 33)) >> 7;
        s[0] &= 0x7f;
    }
    else {
        throw new Error('Invalid signature length');
    }
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v,
        r,
        s,
    };
};
signature$1.fromRpcSig = fromRpcSig$1;
/**
 * Validate a ECDSA signature.
 * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
const isValidSignature$1 = function (v, r, s, homesteadOrLater = true, chainId) {
    const SECP256K1_N_DIV_2 = new externals_1$1.BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    const SECP256K1_N = new externals_1$1.BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery$1(calculateSigRecovery$1(v, chainId))) {
        return false;
    }
    const rBN = new externals_1$1.BN(r);
    const sBN = new externals_1$1.BN(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
signature$1.isValidSignature = isValidSignature$1;
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
const hashPersonalMessage$1 = function (message) {
    (0, helpers_1$1.assertIsBuffer)(message);
    const prefix = Buffer.from(`\u0019Ethereum Signed Message:\n${message.length}`, 'utf-8');
    return (0, hash_1.keccak)(Buffer.concat([prefix, message]));
};
signature$1.hashPersonalMessage = hashPersonalMessage$1;

var object = {};

var __importDefault$P = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(object, "__esModule", { value: true });
object.defineProperties = void 0;
const assert_1 = __importDefault$P(require$$0$8);
const internal_1$1 = internal$1;
const externals_1 = externals;
const bytes_1$3 = bytes$2;
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
const defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label = false) {
        if (label) {
            const obj = {};
            self._fields.forEach((field) => {
                obj[field] = `0x${self[field].toString('hex')}`;
            });
            return obj;
        }
        return (0, bytes_1$3.baToJSON)(self.raw);
    };
    self.serialize = function serialize() {
        return externals_1.rlp.encode(self.raw);
    };
    fields.forEach((field, i) => {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = (0, bytes_1$3.toBuffer)(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = (0, bytes_1$3.unpadBuffer)(v);
                (0, assert_1.default)(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                (0, assert_1.default)(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from((0, internal_1$1.stripHexPrefix)(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = externals_1.rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach((d, i) => {
                self[self._fields[i]] = (0, bytes_1$3.toBuffer)(d);
            });
        }
        else if (typeof data === 'object') {
            const keys = Object.keys(data);
            fields.forEach((field) => {
                if (keys.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};
object.defineProperties = defineProperties;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
	/**
	 * Constants
	 */
	__exportStar(constants$3, exports);
	/**
	 * Account class and helper functions
	 */
	__exportStar(account$1, exports);
	/**
	 * Address type
	 */
	__exportStar(address$2, exports);
	/**
	 * Hash functions
	 */
	__exportStar(hash$1, exports);
	/**
	 * ECDSA signature
	 */
	__exportStar(signature$1, exports);
	/**
	 * Utilities for manipulating Buffers, byte arrays, etc.
	 */
	__exportStar(bytes$2, exports);
	/**
	 * Function for definining properties on an object
	 */
	__exportStar(object, exports);
	/**
	 * External exports (BN, rlp)
	 */
	__exportStar(externals, exports);
	/**
	 * Helpful TypeScript types
	 */
	__exportStar(types$4, exports);
	/**
	 * Export ethjs-util methods
	 */
	var internal_1 = internal$1;
	Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function () { return internal_1.isHexPrefixed; } });
	Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function () { return internal_1.stripHexPrefix; } });
	Object.defineProperty(exports, "padToEven", { enumerable: true, get: function () { return internal_1.padToEven; } });
	Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function () { return internal_1.getBinarySize; } });
	Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function () { return internal_1.arrayContainsArray; } });
	Object.defineProperty(exports, "toAscii", { enumerable: true, get: function () { return internal_1.toAscii; } });
	Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function () { return internal_1.fromUtf8; } });
	Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function () { return internal_1.fromAscii; } });
	Object.defineProperty(exports, "getKeys", { enumerable: true, get: function () { return internal_1.getKeys; } });
	Object.defineProperty(exports, "isHexString", { enumerable: true, get: function () { return internal_1.isHexString; } });
	
} (dist$4));

var src$3 = {};

var utils$d = {};

var types$3 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AccountNonceOrdering = exports.AccountAbstractionVersion = exports.TransactionStatus = exports.PriorityOpTree = exports.PriorityQueueType = exports.Network = void 0;
	(function (Network) {
	    Network[Network["Mainnet"] = 1] = "Mainnet";
	    Network[Network["Ropsten"] = 3] = "Ropsten";
	    Network[Network["Rinkeby"] = 4] = "Rinkeby";
	    Network[Network["Goerli"] = 5] = "Goerli";
	    Network[Network["Localhost"] = 9] = "Localhost";
	})(exports.Network || (exports.Network = {}));
	(function (PriorityQueueType) {
	    PriorityQueueType[PriorityQueueType["Deque"] = 0] = "Deque";
	    PriorityQueueType[PriorityQueueType["HeapBuffer"] = 1] = "HeapBuffer";
	    PriorityQueueType[PriorityQueueType["Heap"] = 2] = "Heap";
	})(exports.PriorityQueueType || (exports.PriorityQueueType = {}));
	(function (PriorityOpTree) {
	    PriorityOpTree[PriorityOpTree["Full"] = 0] = "Full";
	    PriorityOpTree[PriorityOpTree["Rollup"] = 1] = "Rollup";
	})(exports.PriorityOpTree || (exports.PriorityOpTree = {}));
	(function (TransactionStatus) {
	    TransactionStatus["NotFound"] = "not-found";
	    TransactionStatus["Processing"] = "processing";
	    TransactionStatus["Committed"] = "committed";
	    TransactionStatus["Finalized"] = "finalized";
	})(exports.TransactionStatus || (exports.TransactionStatus = {}));
	(function (AccountAbstractionVersion) {
	    AccountAbstractionVersion[AccountAbstractionVersion["None"] = 0] = "None";
	    AccountAbstractionVersion[AccountAbstractionVersion["Version1"] = 1] = "Version1";
	})(exports.AccountAbstractionVersion || (exports.AccountAbstractionVersion = {}));
	(function (AccountNonceOrdering) {
	    AccountNonceOrdering[AccountNonceOrdering["Sequential"] = 0] = "Sequential";
	    AccountNonceOrdering[AccountNonceOrdering["Arbitrary"] = 1] = "Arbitrary";
	})(exports.AccountNonceOrdering || (exports.AccountNonceOrdering = {})); 
} (types$3));

var signer = {};

var adapters = {};

var typechain = {};

var IZkSyncFactory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(IZkSyncFactory$1, "__esModule", { value: true });
IZkSyncFactory$1.IZkSyncFactory = void 0;
const ethers_1$t = require$$0$d;
class IZkSyncFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1$t.Contract(address, _abi$r, signerOrProvider);
    }
}
IZkSyncFactory$1.IZkSyncFactory = IZkSyncFactory;
const _abi$r = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "blockNumber",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32",
            },
        ],
        name: "BlockCommit",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "blockNumber",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32",
            },
        ],
        name: "BlockExecution",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "totalBlocksCommitted",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "totalBlocksVerified",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "totalBlocksExecuted",
                type: "uint256",
            },
        ],
        name: "BlocksRevert",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "previousLastVerifiedBlock",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "currentLastVerifiedBlock",
                type: "uint256",
            },
        ],
        name: "BlocksVerification",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32",
            },
        ],
        name: "CancelUpgradeProposal",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "EthWithdrawalFinalized",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "bytes32",
                name: "proposalSalt",
                type: "bytes32",
            },
        ],
        name: "ExecuteUpgrade",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [],
        name: "Freeze",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bool",
                name: "isPorterAvailable",
                type: "bool",
            },
        ],
        name: "IsPorterAvailableStatusUpdate",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldGovernor",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "newGovernor",
                type: "address",
            },
        ],
        name: "NewGovernor",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousBytecodeHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newBytecodeHash",
                type: "bytes32",
            },
        ],
        name: "NewL2BootloaderBytecodeHash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousBytecodeHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newBytecodeHash",
                type: "bytes32",
            },
        ],
        name: "NewL2DefaultAccountBytecodeHash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldPendingGovernor",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "newPendingGovernor",
                type: "address",
            },
        ],
        name: "NewPendingGovernor",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "txId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint64",
                name: "expirationTimestamp",
                type: "uint64",
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "txType",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "from",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "to",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "gasLimit",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "gasPerPubdataByteLimit",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "paymaster",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "value",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256[4]",
                        name: "reserved",
                        type: "uint256[4]",
                    },
                    {
                        internalType: "bytes",
                        name: "data",
                        type: "bytes",
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes",
                    },
                    {
                        internalType: "uint256[]",
                        name: "factoryDeps",
                        type: "uint256[]",
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterInput",
                        type: "bytes",
                    },
                    {
                        internalType: "bytes",
                        name: "reservedDynamic",
                        type: "bytes",
                    },
                ],
                indexed: false,
                internalType: "struct IMailbox.L2CanonicalTransaction",
                name: "transaction",
                type: "tuple",
            },
            {
                indexed: false,
                internalType: "bytes[]",
                name: "factoryDeps",
                type: "bytes[]",
            },
        ],
        name: "NewPriorityRequest",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "oldPriorityTxMaxGasLimit",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "newPriorityTxMaxGasLimit",
                type: "uint256",
            },
        ],
        name: "NewPriorityTxMaxGasLimit",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldVerifier",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "newVerifier",
                type: "address",
            },
        ],
        name: "NewVerifier",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32",
                    },
                ],
                indexed: false,
                internalType: "struct VerifierParams",
                name: "oldVerifierParams",
                type: "tuple",
            },
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32",
                    },
                ],
                indexed: false,
                internalType: "struct VerifierParams",
                name: "newVerifierParams",
                type: "tuple",
            },
        ],
        name: "NewVerifierParams",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32",
            },
        ],
        name: "ProposeShadowUpgrade",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address",
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8",
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool",
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]",
                            },
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]",
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address",
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes",
                    },
                ],
                indexed: false,
                internalType: "struct Diamond.DiamondCutData",
                name: "diamondCut",
                type: "tuple",
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "bytes32",
                name: "proposalSalt",
                type: "bytes32",
            },
        ],
        name: "ProposeTransparentUpgrade",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32",
            },
        ],
        name: "SecurityCouncilUpgradeApprove",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [],
        name: "Unfreeze",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "validatorAddress",
                type: "address",
            },
            {
                indexed: false,
                internalType: "bool",
                name: "isActive",
                type: "bool",
            },
        ],
        name: "ValidatorStatusUpdate",
        type: "event",
    },
    {
        inputs: [],
        name: "acceptGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_proposedUpgradeHash",
                type: "bytes32",
            },
        ],
        name: "cancelUpgradeProposal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64",
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64",
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32",
                    },
                ],
                internalType: "struct IExecutor.StoredBlockInfo",
                name: "_lastCommittedBlockData",
                type: "tuple",
            },
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64",
                    },
                    {
                        internalType: "uint64",
                        name: "timestamp",
                        type: "uint64",
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64",
                    },
                    {
                        internalType: "bytes32",
                        name: "newStateRoot",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes",
                        name: "initialStorageChanges",
                        type: "bytes",
                    },
                    {
                        internalType: "bytes",
                        name: "repeatedStorageChanges",
                        type: "bytes",
                    },
                    {
                        internalType: "bytes",
                        name: "l2Logs",
                        type: "bytes",
                    },
                    {
                        internalType: "bytes[]",
                        name: "l2ArbitraryLengthMessages",
                        type: "bytes[]",
                    },
                    {
                        internalType: "bytes[]",
                        name: "factoryDeps",
                        type: "bytes[]",
                    },
                ],
                internalType: "struct IExecutor.CommitBlockInfo[]",
                name: "_newBlocksData",
                type: "tuple[]",
            },
        ],
        name: "commitBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64",
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64",
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32",
                    },
                ],
                internalType: "struct IExecutor.StoredBlockInfo[]",
                name: "_blocksData",
                type: "tuple[]",
            },
        ],
        name: "executeBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address",
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8",
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool",
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]",
                            },
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]",
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address",
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes",
                    },
                ],
                internalType: "struct Diamond.DiamondCutData",
                name: "_diamondCut",
                type: "tuple",
            },
            {
                internalType: "bytes32",
                name: "_proposalSalt",
                type: "bytes32",
            },
        ],
        name: "executeUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "_selector",
                type: "bytes4",
            },
        ],
        name: "facetAddress",
        outputs: [
            {
                internalType: "address",
                name: "facet",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "facetAddresses",
        outputs: [
            {
                internalType: "address[]",
                name: "facets",
                type: "address[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_facet",
                type: "address",
            },
        ],
        name: "facetFunctionSelectors",
        outputs: [
            {
                internalType: "bytes4[]",
                name: "",
                type: "bytes4[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "facets",
        outputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "addr",
                        type: "address",
                    },
                    {
                        internalType: "bytes4[]",
                        name: "selectors",
                        type: "bytes4[]",
                    },
                ],
                internalType: "struct IGetters.Facet[]",
                name: "",
                type: "tuple[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256",
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16",
            },
            {
                internalType: "bytes",
                name: "_message",
                type: "bytes",
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]",
            },
        ],
        name: "finalizeEthWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "freezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "getCurrentProposalId",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getFirstUnprocessedPriorityTx",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getGovernor",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getL2BootloaderBytecodeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getL2DefaultAccountBytecodeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getPendingGovernor",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getPriorityQueueSize",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getProposedUpgradeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getProposedUpgradeTimestamp",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getSecurityCouncil",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getTotalBlocksCommitted",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getTotalBlocksExecuted",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getTotalBlocksVerified",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getTotalPriorityTxs",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getUpgradeProposalState",
        outputs: [
            {
                internalType: "enum UpgradeState",
                name: "",
                type: "uint8",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getVerifier",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getVerifierParams",
        outputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32",
                    },
                ],
                internalType: "struct VerifierParams",
                name: "",
                type: "tuple",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getpriorityTxMaxGasLimit",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "isApprovedBySecurityCouncil",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "isDiamondStorageFrozen",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256",
            },
        ],
        name: "isEthWithdrawalFinalized",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_facet",
                type: "address",
            },
        ],
        name: "isFacetFreezable",
        outputs: [
            {
                internalType: "bool",
                name: "isFreezable",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "_selector",
                type: "bytes4",
            },
        ],
        name: "isFunctionFreezable",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_address",
                type: "address",
            },
        ],
        name: "isValidator",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256",
            },
        ],
        name: "l2LogsRootHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "hash",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_gasPrice",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2GasLimit",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2GasPerPubdataByteLimit",
                type: "uint256",
            },
        ],
        name: "l2TransactionBaseCost",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "priorityQueueFrontOperation",
        outputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "canonicalTxHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint64",
                        name: "expirationTimestamp",
                        type: "uint64",
                    },
                    {
                        internalType: "uint192",
                        name: "layer2Tip",
                        type: "uint192",
                    },
                ],
                internalType: "struct PriorityOperation",
                name: "",
                type: "tuple",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_proposalHash",
                type: "bytes32",
            },
            {
                internalType: "uint40",
                name: "_proposalId",
                type: "uint40",
            },
        ],
        name: "proposeShadowUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address",
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8",
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool",
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]",
                            },
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]",
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address",
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes",
                    },
                ],
                internalType: "struct Diamond.DiamondCutData",
                name: "_diamondCut",
                type: "tuple",
            },
            {
                internalType: "uint40",
                name: "_proposalId",
                type: "uint40",
            },
        ],
        name: "proposeTransparentUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64",
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64",
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32",
                    },
                ],
                internalType: "struct IExecutor.StoredBlockInfo",
                name: "_prevBlock",
                type: "tuple",
            },
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64",
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64",
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32",
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32",
                    },
                ],
                internalType: "struct IExecutor.StoredBlockInfo[]",
                name: "_committedBlocks",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "uint256[]",
                        name: "recursiveAggregationInput",
                        type: "uint256[]",
                    },
                    {
                        internalType: "uint256[]",
                        name: "serializedProof",
                        type: "uint256[]",
                    },
                ],
                internalType: "struct IExecutor.ProofInput",
                name: "_proof",
                type: "tuple",
            },
        ],
        name: "proveBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_l2TxHash",
                type: "bytes32",
            },
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256",
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16",
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]",
            },
            {
                internalType: "enum TxStatus",
                name: "_status",
                type: "uint8",
            },
        ],
        name: "proveL1ToL2TransactionStatus",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256",
            },
            {
                components: [
                    {
                        internalType: "uint8",
                        name: "l2ShardId",
                        type: "uint8",
                    },
                    {
                        internalType: "bool",
                        name: "isService",
                        type: "bool",
                    },
                    {
                        internalType: "uint16",
                        name: "txNumberInBlock",
                        type: "uint16",
                    },
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address",
                    },
                    {
                        internalType: "bytes32",
                        name: "key",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "value",
                        type: "bytes32",
                    },
                ],
                internalType: "struct L2Log",
                name: "_log",
                type: "tuple",
            },
            {
                internalType: "bytes32[]",
                name: "_proof",
                type: "bytes32[]",
            },
        ],
        name: "proveL2LogInclusion",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256",
            },
            {
                components: [
                    {
                        internalType: "uint16",
                        name: "txNumberInBlock",
                        type: "uint16",
                    },
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address",
                    },
                    {
                        internalType: "bytes",
                        name: "data",
                        type: "bytes",
                    },
                ],
                internalType: "struct L2Message",
                name: "_message",
                type: "tuple",
            },
            {
                internalType: "bytes32[]",
                name: "_proof",
                type: "bytes32[]",
            },
        ],
        name: "proveL2MessageInclusion",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_contractL2",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_l2Value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "_calldata",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "_l2GasLimit",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2GasPerPubdataByteLimit",
                type: "uint256",
            },
            {
                internalType: "bytes[]",
                name: "_factoryDeps",
                type: "bytes[]",
            },
            {
                internalType: "address",
                name: "_refundRecipient",
                type: "address",
            },
        ],
        name: "requestL2Transaction",
        outputs: [
            {
                internalType: "bytes32",
                name: "canonicalTxHash",
                type: "bytes32",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_newLastBlock",
                type: "uint256",
            },
        ],
        name: "revertBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_upgradeProposalHash",
                type: "bytes32",
            },
        ],
        name: "securityCouncilUpgradeApprove",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_l2BootloaderBytecodeHash",
                type: "bytes32",
            },
        ],
        name: "setL2BootloaderBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_l2DefaultAccountBytecodeHash",
                type: "bytes32",
            },
        ],
        name: "setL2DefaultAccountBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_newPendingGovernor",
                type: "address",
            },
        ],
        name: "setPendingGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bool",
                name: "_zkPorterIsAvailable",
                type: "bool",
            },
        ],
        name: "setPorterAvailability",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_newPriorityTxMaxGasLimit",
                type: "uint256",
            },
        ],
        name: "setPriorityTxMaxGasLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_validator",
                type: "address",
            },
            {
                internalType: "bool",
                name: "_active",
                type: "bool",
            },
        ],
        name: "setValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "contract Verifier",
                name: "_newVerifier",
                type: "address",
            },
        ],
        name: "setVerifier",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32",
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32",
                    },
                ],
                internalType: "struct VerifierParams",
                name: "_newVerifierParams",
                type: "tuple",
            },
        ],
        name: "setVerifierParams",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256",
            },
        ],
        name: "storedBlockHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "unfreezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address",
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8",
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool",
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]",
                            },
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]",
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address",
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes",
                    },
                ],
                internalType: "struct Diamond.DiamondCutData",
                name: "_diamondCut",
                type: "tuple",
            },
            {
                internalType: "uint256",
                name: "_proposalId",
                type: "uint256",
            },
            {
                internalType: "bytes32",
                name: "_salt",
                type: "bytes32",
            },
        ],
        name: "upgradeProposalHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
];

var IERC20MetadataFactory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(IERC20MetadataFactory$1, "__esModule", { value: true });
IERC20MetadataFactory$1.IERC20MetadataFactory = void 0;
const ethers_1$s = require$$0$d;
class IERC20MetadataFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1$s.Contract(address, _abi$q, signerOrProvider);
    }
}
IERC20MetadataFactory$1.IERC20MetadataFactory = IERC20MetadataFactory;
const _abi$q = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "spender",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
        ],
        name: "Approval",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "address",
                name: "spender",
                type: "address",
            },
        ],
        name: "allowance",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "spender",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "approve",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "decimals",
        outputs: [
            {
                internalType: "uint8",
                name: "",
                type: "uint8",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "name",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "symbol",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "transfer",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "from",
                type: "address",
            },
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "transferFrom",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];

var IL1BridgeFactory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(IL1BridgeFactory$1, "__esModule", { value: true });
IL1BridgeFactory$1.IL1BridgeFactory = void 0;
const ethers_1$r = require$$0$d;
class IL1BridgeFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1$r.Contract(address, _abi$p, signerOrProvider);
    }
}
IL1BridgeFactory$1.IL1BridgeFactory = IL1BridgeFactory;
const _abi$p = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "l1Token",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "ClaimedFailedDeposit",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "l1Token",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "DepositInitiated",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "l1Token",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "WithdrawalFinalized",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_depositSender",
                type: "address",
            },
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
            {
                internalType: "bytes32",
                name: "_l2TxHash",
                type: "bytes32",
            },
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256",
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16",
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]",
            },
        ],
        name: "claimFailedDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l2Receiver",
                type: "address",
            },
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2TxGasLimit",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2TxGasPerPubdataByte",
                type: "uint256",
            },
        ],
        name: "deposit",
        outputs: [
            {
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256",
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16",
            },
            {
                internalType: "bytes",
                name: "_message",
                type: "bytes",
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]",
            },
        ],
        name: "finalizeWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256",
            },
        ],
        name: "isWithdrawalFinalized",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
        ],
        name: "l2TokenAddress",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
];

var IL2BridgeFactory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(IL2BridgeFactory$1, "__esModule", { value: true });
IL2BridgeFactory$1.IL2BridgeFactory = void 0;
const ethers_1$q = require$$0$d;
class IL2BridgeFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1$q.Contract(address, _abi$o, signerOrProvider);
    }
}
IL2BridgeFactory$1.IL2BridgeFactory = IL2BridgeFactory;
const _abi$o = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Sender",
                type: "address",
            },
            {
                internalType: "address",
                name: "_l2Receiver",
                type: "address",
            },
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
        ],
        name: "finalizeDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Bridge",
                type: "address",
            },
            {
                internalType: "bytes32",
                name: "_l2TokenProxyBytecodeHash",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "_governor",
                type: "address",
            },
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "l1Bridge",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l2Token",
                type: "address",
            },
        ],
        name: "l1TokenAddress",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
        ],
        name: "l2TokenAddress",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Receiver",
                type: "address",
            },
            {
                internalType: "address",
                name: "_l2Token",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
];

var IAllowListFactory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(IAllowListFactory$1, "__esModule", { value: true });
IAllowListFactory$1.IAllowListFactory = void 0;
const ethers_1$p = require$$0$d;
class IAllowListFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1$p.Contract(address, _abi$n, signerOrProvider);
    }
}
IAllowListFactory$1.IAllowListFactory = IAllowListFactory;
const _abi$n = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "target",
                type: "address",
            },
            {
                indexed: false,
                internalType: "enum IAllowList.AccessMode",
                name: "previousMode",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "enum IAllowList.AccessMode",
                name: "newMode",
                type: "uint8",
            },
        ],
        name: "UpdateAccessMode",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "caller",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "target",
                type: "address",
            },
            {
                indexed: true,
                internalType: "bytes4",
                name: "functionSig",
                type: "bytes4",
            },
            {
                indexed: false,
                internalType: "bool",
                name: "status",
                type: "bool",
            },
        ],
        name: "UpdateCallPermission",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_caller",
                type: "address",
            },
            {
                internalType: "address",
                name: "_target",
                type: "address",
            },
            {
                internalType: "bytes4",
                name: "_functionSig",
                type: "bytes4",
            },
        ],
        name: "canCall",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_target",
                type: "address",
            },
        ],
        name: "getAccessMode",
        outputs: [
            {
                internalType: "enum IAllowList.AccessMode",
                name: "",
                type: "uint8",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
        ],
        name: "getTokenDepositLimitData",
        outputs: [
            {
                components: [
                    {
                        internalType: "bool",
                        name: "depositLimitation",
                        type: "bool",
                    },
                    {
                        internalType: "uint256",
                        name: "depositCap",
                        type: "uint256",
                    },
                ],
                internalType: "struct IAllowList.Deposit",
                name: "",
                type: "tuple",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_caller",
                type: "address",
            },
            {
                internalType: "address",
                name: "_target",
                type: "address",
            },
            {
                internalType: "bytes4",
                name: "_functionSig",
                type: "bytes4",
            },
        ],
        name: "hasSpecialAccessToCall",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_target",
                type: "address",
            },
            {
                internalType: "enum IAllowList.AccessMode",
                name: "_accessMode",
                type: "uint8",
            },
        ],
        name: "setAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_targets",
                type: "address[]",
            },
            {
                internalType: "enum IAllowList.AccessMode[]",
                name: "_accessMode",
                type: "uint8[]",
            },
        ],
        name: "setBatchAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_callers",
                type: "address[]",
            },
            {
                internalType: "address[]",
                name: "_targets",
                type: "address[]",
            },
            {
                internalType: "bytes4[]",
                name: "_functionSigs",
                type: "bytes4[]",
            },
            {
                internalType: "bool[]",
                name: "_enables",
                type: "bool[]",
            },
        ],
        name: "setBatchPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address",
            },
            {
                internalType: "bool",
                name: "_depositLimitation",
                type: "bool",
            },
            {
                internalType: "uint256",
                name: "_depositCap",
                type: "uint256",
            },
        ],
        name: "setDepositLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_caller",
                type: "address",
            },
            {
                internalType: "address",
                name: "_target",
                type: "address",
            },
            {
                internalType: "bytes4",
                name: "_functionSig",
                type: "bytes4",
            },
            {
                internalType: "bool",
                name: "_enable",
                type: "bool",
            },
        ],
        name: "setPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
];

var IEthTokenFactory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(IEthTokenFactory$1, "__esModule", { value: true });
IEthTokenFactory$1.IEthTokenFactory = void 0;
const ethers_1$o = require$$0$d;
class IEthTokenFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1$o.Contract(address, _abi$m, signerOrProvider);
    }
}
IEthTokenFactory$1.IEthTokenFactory = IEthTokenFactory;
const _abi$m = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "Mint",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "_l1Receiver",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
        ],
        name: "Withdrawal",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "decimals",
        outputs: [
            {
                internalType: "uint8",
                name: "",
                type: "uint8",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_account",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "name",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "symbol",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_from",
                type: "address",
            },
            {
                internalType: "address",
                name: "_to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
        ],
        name: "transferFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Receiver",
                type: "address",
            },
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "payable",
        type: "function",
    },
];

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IEthTokenFactory = exports.IAllowListFactory = exports.IL2BridgeFactory = exports.IL1BridgeFactory = exports.IERC20MetadataFactory = exports.IZkSyncFactory = void 0;
	var IZkSyncFactory_1 = IZkSyncFactory$1;
	Object.defineProperty(exports, "IZkSyncFactory", { enumerable: true, get: function () { return IZkSyncFactory_1.IZkSyncFactory; } });
	var IERC20MetadataFactory_1 = IERC20MetadataFactory$1;
	Object.defineProperty(exports, "IERC20MetadataFactory", { enumerable: true, get: function () { return IERC20MetadataFactory_1.IERC20MetadataFactory; } });
	var IL1BridgeFactory_1 = IL1BridgeFactory$1;
	Object.defineProperty(exports, "IL1BridgeFactory", { enumerable: true, get: function () { return IL1BridgeFactory_1.IL1BridgeFactory; } });
	var IL2BridgeFactory_1 = IL2BridgeFactory$1;
	Object.defineProperty(exports, "IL2BridgeFactory", { enumerable: true, get: function () { return IL2BridgeFactory_1.IL2BridgeFactory; } });
	var IAllowListFactory_1 = IAllowListFactory$1;
	Object.defineProperty(exports, "IAllowListFactory", { enumerable: true, get: function () { return IAllowListFactory_1.IAllowListFactory; } });
	var IEthTokenFactory_1 = IEthTokenFactory$1;
	Object.defineProperty(exports, "IEthTokenFactory", { enumerable: true, get: function () { return IEthTokenFactory_1.IEthTokenFactory; } }); 
} (typechain));

var hasRequiredAdapters;

function requireAdapters () {
	if (hasRequiredAdapters) return adapters;
	hasRequiredAdapters = 1;
	Object.defineProperty(adapters, "__esModule", { value: true });
	adapters.AdapterL2 = adapters.AdapterL1 = void 0;
	const ethers_1 = require$$0$d;
	const typechain_1 = typechain;
	const utils_1 = requireUtils$2();
	function AdapterL1(Base) {
	    return class Adapter extends Base {
	        _providerL2() {
	            throw new Error('Must be implemented by the derived class!');
	        }
	        _providerL1() {
	            throw new Error('Must be implemented by the derived class!');
	        }
	        _signerL1() {
	            throw new Error('Must be implemented by the derived class!');
	        }
	        async getMainContract() {
	            const address = await this._providerL2().getMainContractAddress();
	            return typechain_1.IZkSyncFactory.connect(address, this._signerL1());
	        }
	        async getL1BridgeContracts() {
	            const addresses = await this._providerL2().getDefaultBridgeAddresses();
	            return {
	                erc20: typechain_1.IL1BridgeFactory.connect(addresses.erc20L1, this._signerL1())
	            };
	        }
	        async getBalanceL1(token, blockTag) {
	            token !== null && token !== void 0 ? token : (token = utils_1.ETH_ADDRESS);
	            if ((0, utils_1.isETH)(token)) {
	                return await this._providerL1().getBalance(await this.getAddress(), blockTag);
	            }
	            else {
	                const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._providerL1());
	                return await erc20contract.balanceOf(await this.getAddress());
	            }
	        }
	        async l2TokenAddress(token) {
	            if (token == utils_1.ETH_ADDRESS) {
	                return utils_1.ETH_ADDRESS;
	            }
	            else {
	                const erc20Bridge = (await this.getL1BridgeContracts()).erc20;
	                return await erc20Bridge.l2TokenAddress(token);
	            }
	        }
	        async approveERC20(token, amount, overrides) {
	            if ((0, utils_1.isETH)(token)) {
	                throw new Error("ETH token can't be approved. The address of the token does not exist on L1.");
	            }
	            let bridgeAddress = overrides === null || overrides === void 0 ? void 0 : overrides.bridgeAddress;
	            const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._signerL1());
	            if (bridgeAddress == null) {
	                bridgeAddress = (await this._providerL2().getDefaultBridgeAddresses()).erc20L1;
	            }
	            else {
	                delete overrides.bridgeAddress;
	            }
	            return await erc20contract.approve(bridgeAddress, amount, overrides);
	        }
	        async getBaseCost(params) {
	            var _a, _b;
	            const zksyncContract = await this.getMainContract();
	            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
	            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());
	            (_b = parameters.gasPerPubdataByte) !== null && _b !== void 0 ? _b : (parameters.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
	            return ethers_1.BigNumber.from(await zksyncContract.l2TransactionBaseCost(parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte));
	        }
	        async deposit(transaction) {
	            var _a;
	            const depositTx = await this.getDepositTx(transaction);
	            if (transaction.token == utils_1.ETH_ADDRESS) {
	                return this.requestExecute(depositTx);
	            }
	            else {
	                const bridgeContracts = await this.getL1BridgeContracts();
	                if (transaction.approveERC20) {
	                    const approveTx = await this.approveERC20(transaction.token, transaction.amount, {
	                        bridgeAddress: (_a = transaction.bridgeAddress) !== null && _a !== void 0 ? _a : bridgeContracts.erc20.address,
	                        ...transaction.approveOverrides
	                    });
	                    await approveTx.wait();
	                }
	                return await this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(depositTx));
	            }
	        }
	        async estimateGasDeposit(transaction) {
	            const depositTx = await this.getDepositTx(transaction);
	            if (transaction.token == utils_1.ETH_ADDRESS) {
	                return await this.estimateGasRequestExecute(depositTx);
	            }
	            else {
	                return await this._providerL1().estimateGas(depositTx);
	            }
	        }
	        async getDepositTx(transaction) {
	            var _a, _b, _c, _d, _e, _f, _g;
	            const bridgeContracts = await this.getL1BridgeContracts();
	            if (transaction.bridgeAddress) {
	                bridgeContracts.erc20.attach(transaction.bridgeAddress);
	            }
	            const { ...tx } = transaction;
	            (_a = tx.to) !== null && _a !== void 0 ? _a : (tx.to = await this.getAddress());
	            (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : (tx.operatorTip = ethers_1.BigNumber.from(0));
	            (_c = tx.overrides) !== null && _c !== void 0 ? _c : (tx.overrides = {});
	            (_d = tx.gasPerPubdataByte) !== null && _d !== void 0 ? _d : (tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
	            (_e = tx.l2GasLimit) !== null && _e !== void 0 ? _e : (tx.l2GasLimit = await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._providerL1(), this._providerL2(), tx.token, tx.amount, tx.to, await this.getAddress(), tx.gasPerPubdataByte));
	            const { to, token, amount, operatorTip, overrides } = tx;
	            await insertGasPrice(this._providerL1(), overrides);
	            const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
	            const zksyncContract = await this.getMainContract();
	            const baseCost = await zksyncContract.l2TransactionBaseCost(await gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte);
	            if (token == utils_1.ETH_ADDRESS) {
	                (_f = overrides.value) !== null && _f !== void 0 ? _f : (overrides.value = baseCost.add(operatorTip).add(amount));
	                return {
	                    contractAddress: to,
	                    calldata: '0x',
	                    l2Value: amount,
	                    // For some reason typescript can not deduce that we've already set the
	                    // tx.l2GasLimit
	                    l2GasLimit: tx.l2GasLimit,
	                    ...tx
	                };
	            }
	            else {
	                const args = [
	                    to,
	                    token,
	                    amount,
	                    tx.l2GasLimit,
	                    tx.gasPerPubdataByte
	                ];
	                (_g = overrides.value) !== null && _g !== void 0 ? _g : (overrides.value = baseCost.add(operatorTip));
	                await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
	                // TODO: compatibility layer: using the old API which uses msg.sender as the
	                // refund recipient, to make the SDK compatible with the old contracts.
	                // const contract = bridgeContracts.erc20 as ethers.Contract;
	                return await bridgeContracts.erc20.populateTransaction.deposit(...args, overrides);
	            }
	        }
	        async _getWithdrawalLog(withdrawalHash, index = 0) {
	            const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
	            const receipt = await this._providerL2().getTransactionReceipt(hash);
	            const log = receipt.logs.filter((log) => log.address == utils_1.L1_MESSENGER_ADDRESS &&
	                log.topics[0] == ethers_1.ethers.utils.id('L1MessageSent(address,bytes32,bytes)'))[index];
	            return {
	                log,
	                l1BatchTxId: receipt.l1BatchTxIndex
	            };
	        }
	        async _getWithdrawalL2ToL1Log(withdrawalHash, index = 0) {
	            const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
	            const receipt = await this._providerL2().getTransactionReceipt(hash);
	            const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([_, log]) => log.sender == utils_1.L1_MESSENGER_ADDRESS);
	            const [l2ToL1LogIndex, l2ToL1Log] = messages[index];
	            return {
	                l2ToL1LogIndex,
	                l2ToL1Log
	            };
	        }
	        async finalizeWithdrawalParams(withdrawalHash, index = 0) {
	            const { log, l1BatchTxId } = await this._getWithdrawalLog(withdrawalHash, index);
	            const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
	            const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
	            const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
	            const message = ethers_1.ethers.utils.defaultAbiCoder.decode(['bytes'], log.data)[0];
	            return {
	                l1BatchNumber: log.l1BatchNumber,
	                l2MessageIndex: proof.id,
	                l2TxNumberInBlock: l1BatchTxId,
	                message,
	                sender,
	                proof: proof.proof
	            };
	        }
	        async finalizeWithdrawal(withdrawalHash, index = 0, overrides) {
	            const { l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, sender, proof } = await this.finalizeWithdrawalParams(withdrawalHash, index);
	            if ((0, utils_1.isETH)(sender)) {
	                const contractAddress = await this._providerL2().getMainContractAddress();
	                const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
	                return await zksync.finalizeEthWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
	            }
	            const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
	            const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._signerL1());
	            return await l1Bridge.finalizeWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
	        }
	        async isWithdrawalFinalized(withdrawalHash, index = 0) {
	            const { log } = await this._getWithdrawalLog(withdrawalHash, index);
	            const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
	            const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
	            // `getLogProof` is called not to get proof but
	            // to get the index of the corresponding L2->L1 log,
	            // which is returned as `proof.id`.
	            const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
	            if ((0, utils_1.isETH)(sender)) {
	                const contractAddress = await this._providerL2().getMainContractAddress();
	                const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
	                return await zksync.isEthWithdrawalFinalized(log.l1BatchNumber, proof.id);
	            }
	            const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
	            const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._providerL1());
	            return await l1Bridge.isWithdrawalFinalized(log.l1BatchNumber, proof.id);
	        }
	        async claimFailedDeposit(depositHash, overrides) {
	            const receipt = await this._providerL2().getTransactionReceipt(ethers_1.ethers.utils.hexlify(depositHash));
	            const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex((l2ToL1log) => l2ToL1log.sender == utils_1.BOOTLOADER_FORMAL_ADDRESS && l2ToL1log.key == depositHash);
	            const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];
	            if (successL2ToL1Log.value != ethers_1.ethers.constants.HashZero) {
	                throw new Error('Cannot claim successful deposit');
	            }
	            const tx = await this._providerL2().getTransaction(ethers_1.ethers.utils.hexlify(depositHash));
	            // Undo the aliasing, since the Mailbox contract set it as for contract address.
	            const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);
	            const l2BridgeAddress = receipt.to;
	            const l1Bridge = typechain_1.IL1BridgeFactory.connect(l1BridgeAddress, this._signerL1());
	            const l2Bridge = typechain_1.IL2BridgeFactory.connect(l2BridgeAddress, this._providerL2());
	            const calldata = l2Bridge.interface.decodeFunctionData('finalizeDeposit', tx.data);
	            const proof = await this._providerL2().getLogProof(depositHash, successL2ToL1LogIndex);
	            return await l1Bridge.claimFailedDeposit(calldata['_l1Sender'], calldata['_l1Token'], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof, overrides !== null && overrides !== void 0 ? overrides : {});
	        }
	        async requestExecute(transaction) {
	            const requestExecuteTx = await this.getRequestExecuteTx(transaction);
	            return this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(requestExecuteTx));
	        }
	        async estimateGasRequestExecute(transaction) {
	            const requestExecuteTx = await this.getRequestExecuteTx(transaction);
	            return this._providerL1().estimateGas(requestExecuteTx);
	        }
	        async getRequestExecuteTx(transaction) {
	            var _a, _b, _c, _d, _e, _f, _g, _h;
	            const zksyncContract = await this.getMainContract();
	            const { ...tx } = transaction;
	            (_a = tx.l2Value) !== null && _a !== void 0 ? _a : (tx.l2Value = ethers_1.BigNumber.from(0));
	            (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : (tx.operatorTip = ethers_1.BigNumber.from(0));
	            (_c = tx.factoryDeps) !== null && _c !== void 0 ? _c : (tx.factoryDeps = []);
	            (_d = tx.overrides) !== null && _d !== void 0 ? _d : (tx.overrides = {});
	            (_e = tx.gasPerPubdataByte) !== null && _e !== void 0 ? _e : (tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
	            (_f = tx.refundRecipient) !== null && _f !== void 0 ? _f : (tx.refundRecipient = await this.getAddress());
	            (_g = tx.l2GasLimit) !== null && _g !== void 0 ? _g : (tx.l2GasLimit = await this._providerL2().estimateL1ToL2Execute(transaction));
	            const { contractAddress, l2Value, calldata, l2GasLimit, factoryDeps, operatorTip, overrides, gasPerPubdataByte, refundRecipient } = tx;
	            await insertGasPrice(this._providerL1(), overrides);
	            const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
	            const baseCost = await this.getBaseCost({
	                gasPrice: await gasPriceForEstimation,
	                gasPerPubdataByte,
	                gasLimit: l2GasLimit
	            });
	            (_h = overrides.value) !== null && _h !== void 0 ? _h : (overrides.value = baseCost.add(operatorTip).add(l2Value));
	            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
	            return await zksyncContract.populateTransaction.requestL2Transaction(contractAddress, l2Value, calldata, l2GasLimit, utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT, factoryDeps, refundRecipient, overrides);
	        }
	    };
	}
	adapters.AdapterL1 = AdapterL1;
	function AdapterL2(Base) {
	    return class Adapter extends Base {
	        _providerL2() {
	            throw new Error('Must be implemented by the derived class!');
	        }
	        _signerL2() {
	            throw new Error('Must be implemented by the derived class!');
	        }
	        async getBalance(token, blockTag = 'committed') {
	            return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);
	        }
	        async getAllBalances() {
	            return await this._providerL2().getAllAccountBalances(await this.getAddress());
	        }
	        async getL2BridgeContracts() {
	            const addresses = await this._providerL2().getDefaultBridgeAddresses();
	            return {
	                erc20: typechain_1.IL2BridgeFactory.connect(addresses.erc20L2, this._signerL2())
	            };
	        }
	        _fillCustomData(data) {
	            var _a, _b;
	            const customData = { ...data };
	            (_a = customData.gasPerPubdata) !== null && _a !== void 0 ? _a : (customData.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);
	            (_b = customData.factoryDeps) !== null && _b !== void 0 ? _b : (customData.factoryDeps = []);
	            return customData;
	        }
	        async withdraw(transaction) {
	            const withdrawTx = await this._providerL2().getWithdrawTx({
	                from: await this.getAddress(),
	                ...transaction
	            });
	            const txResponse = await this.sendTransaction(withdrawTx);
	            return this._providerL2()._wrapTransaction(txResponse);
	        }
	        async transfer(transaction) {
	            const transferTx = await this._providerL2().getTransferTx({
	                from: await this.getAddress(),
	                ...transaction
	            });
	            const txResponse = await this.sendTransaction(transferTx);
	            return this._providerL2()._wrapTransaction(txResponse);
	        }
	    };
	}
	adapters.AdapterL2 = AdapterL2;
	/// @dev This method checks if the overrides contain a gasPrice (or maxFeePerGas), if not it will insert
	/// the maxFeePerGas
	async function insertGasPrice(l1Provider, overrides) {
	    if (!overrides.gasPrice && !overrides.maxFeePerGas) {
	        const l1FeeData = await l1Provider.getFeeData();
	        // Sometimes baseFeePerGas is not available, so we use gasPrice instead.
	        const baseFee = l1FeeData.lastBaseFeePerGas || l1FeeData.gasPrice;
	        // ethers.js by default uses multiplcation by 2, but since the price for the L2 part
	        // will depend on the L1 part, doubling base fee is typically too much.
	        const maxFeePerGas = baseFee.mul(3).div(2).add(l1FeeData.maxPriorityFeePerGas);
	        overrides.maxFeePerGas = maxFeePerGas;
	        overrides.maxPriorityFeePerGas = l1FeeData.maxPriorityFeePerGas;
	    }
	}
	return adapters;
}

var hasRequiredSigner;

function requireSigner () {
	if (hasRequiredSigner) return signer;
	hasRequiredSigner = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.eip712Types = void 0;
		const ethers_1 = require$$0$d;
		const utils_1 = requireUtils$2();
		const hash_1 = require$$2$4;
		const adapters_1 = requireAdapters();
		exports.eip712Types = {
		    Transaction: [
		        { name: 'txType', type: 'uint256' },
		        { name: 'from', type: 'uint256' },
		        { name: 'to', type: 'uint256' },
		        { name: 'gasLimit', type: 'uint256' },
		        { name: 'gasPerPubdataByteLimit', type: 'uint256' },
		        { name: 'maxFeePerGas', type: 'uint256' },
		        { name: 'maxPriorityFeePerGas', type: 'uint256' },
		        { name: 'paymaster', type: 'uint256' },
		        { name: 'nonce', type: 'uint256' },
		        { name: 'value', type: 'uint256' },
		        { name: 'data', type: 'bytes' },
		        { name: 'factoryDeps', type: 'bytes32[]' },
		        { name: 'paymasterInput', type: 'bytes' }
		    ]
		};
		class EIP712Signer {
		    constructor(ethSigner, chainId) {
		        this.ethSigner = ethSigner;
		        this.eip712Domain = Promise.resolve(chainId).then((chainId) => ({
		            name: 'zkSync',
		            version: '2',
		            chainId
		        }));
		    }
		    static getSignInput(transaction) {
		        var _a, _b, _c, _d, _e, _f, _g;
		        const maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice;
		        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
		        const gasPerPubdataByteLimit = ((_a = transaction.customData) === null || _a === void 0 ? void 0 : _a.gasPerPubdata) || utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
		        const signInput = {
		            txType: transaction.type,
		            from: transaction.from,
		            to: transaction.to,
		            gasLimit: transaction.gasLimit,
		            gasPerPubdataByteLimit: gasPerPubdataByteLimit,
		            maxFeePerGas,
		            maxPriorityFeePerGas,
		            paymaster: ((_c = (_b = transaction.customData) === null || _b === void 0 ? void 0 : _b.paymasterParams) === null || _c === void 0 ? void 0 : _c.paymaster) || ethers_1.ethers.constants.AddressZero,
		            nonce: transaction.nonce,
		            value: transaction.value,
		            data: transaction.data,
		            factoryDeps: ((_e = (_d = transaction.customData) === null || _d === void 0 ? void 0 : _d.factoryDeps) === null || _e === void 0 ? void 0 : _e.map((dep) => (0, utils_1.hashBytecode)(dep))) || [],
		            paymasterInput: ((_g = (_f = transaction.customData) === null || _f === void 0 ? void 0 : _f.paymasterParams) === null || _g === void 0 ? void 0 : _g.paymasterInput) || '0x'
		        };
		        return signInput;
		    }
		    async sign(transaction) {
		        return await this.ethSigner._signTypedData(await this.eip712Domain, exports.eip712Types, EIP712Signer.getSignInput(transaction));
		    }
		    static getSignedDigest(transaction) {
		        if (!transaction.chainId) {
		            throw Error("Transaction chainId isn't set");
		        }
		        const domain = {
		            name: 'zkSync',
		            version: '2',
		            chainId: transaction.chainId
		        };
		        return hash_1._TypedDataEncoder.hash(domain, exports.eip712Types, EIP712Signer.getSignInput(transaction));
		    }
		}
		exports.EIP712Signer = EIP712Signer;
		// This class is to be used on the frontend, with metamask injection.
		// It only contains L2 operations. For L1 operations, see L1Signer.
		// Sample usage:
		// const provider = new zkweb3.Web3Provider(window.ethereum);
		// const signer = provider.getSigner();
		// const tx = await signer.sendTransaction({ ... });
		class Signer extends (0, adapters_1.AdapterL2)(ethers_1.ethers.providers.JsonRpcSigner) {
		    _signerL2() {
		        return this;
		    }
		    _providerL2() {
		        return this.provider;
		    }
		    static from(signer) {
		        const newSigner = Object.setPrototypeOf(signer, Signer.prototype);
		        // @ts-ignore
		        newSigner.eip712 = new EIP712Signer(newSigner, newSigner.getChainId());
		        return newSigner;
		    }
		    // an alias with a better name
		    async getNonce(blockTag) {
		        return await this.getTransactionCount(blockTag);
		    }
		    async sendTransaction(transaction) {
		        var _a, _b, _c, _d, _e, _f, _g;
		        if (transaction.customData == null && transaction.type == null) {
		            // use legacy txs by default
		            transaction.type = 0;
		        }
		        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
		            return (await super.sendTransaction(transaction));
		        }
		        else {
		            const address = await this.getAddress();
		            (_a = transaction.from) !== null && _a !== void 0 ? _a : (transaction.from = address);
		            if (transaction.from.toLowerCase() != address.toLowerCase()) {
		                throw new Error('Transaction `from` address mismatch');
		            }
		            transaction.type = utils_1.EIP712_TX_TYPE;
		            (_b = transaction.value) !== null && _b !== void 0 ? _b : (transaction.value = 0);
		            (_c = transaction.data) !== null && _c !== void 0 ? _c : (transaction.data = '0x');
		            (_d = transaction.nonce) !== null && _d !== void 0 ? _d : (transaction.nonce = await this.getNonce());
		            transaction.customData = this._fillCustomData(transaction.customData);
		            (_e = transaction.gasPrice) !== null && _e !== void 0 ? _e : (transaction.gasPrice = await this.provider.getGasPrice());
		            (_f = transaction.gasLimit) !== null && _f !== void 0 ? _f : (transaction.gasLimit = await this.provider.estimateGas(transaction));
		            (_g = transaction.chainId) !== null && _g !== void 0 ? _g : (transaction.chainId = (await this.provider.getNetwork()).chainId);
		            transaction.customData.customSignature = await this.eip712.sign(transaction);
		            const txBytes = (0, utils_1.serialize)(transaction);
		            return await this.provider.sendTransaction(txBytes);
		        }
		    }
		}
		exports.Signer = Signer;
		// This class is to be used on the frontend with metamask injection.
		// It only contains L1 operations. For L2 operations, see Signer.
		// Sample usage:
		// const provider = new ethers.Web3Provider(window.ethereum);
		// const zksyncProvider = new zkweb3.Provider('<rpc_url>');
		// const signer = zkweb3.L1Signer.from(provider.getSigner(), zksyncProvider);
		// const tx = await signer.deposit({ ... });
		class L1Signer extends (0, adapters_1.AdapterL1)(ethers_1.ethers.providers.JsonRpcSigner) {
		    _providerL2() {
		        return this.providerL2;
		    }
		    _providerL1() {
		        return this.provider;
		    }
		    _signerL1() {
		        return this;
		    }
		    static from(signer, zksyncProvider) {
		        const newSigner = Object.setPrototypeOf(signer, L1Signer.prototype);
		        newSigner.providerL2 = zksyncProvider;
		        return newSigner;
		    }
		    connectToL2(provider) {
		        this.providerL2 = provider;
		        return this;
		    }
		}
		exports.L1Signer = L1Signer; 
	} (signer));
	return signer;
}

var paymasterUtils = {};

var abi$7 = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_minAllowance",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "_innerInput",
				type: "bytes"
			}
		],
		name: "approvalBased",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "input",
				type: "bytes"
			}
		],
		name: "general",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1 = {
	abi: abi$7
};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getPaymasterParams = exports.getGeneralPaymasterInput = exports.getApprovalBasedPaymasterInput = exports.IPaymasterFlow = void 0;
	const ethers_1 = require$$0$d;
	exports.IPaymasterFlow = new ethers_1.ethers.utils.Interface(require$$1.abi);
	function getApprovalBasedPaymasterInput(paymasterInput) {
	    return exports.IPaymasterFlow.encodeFunctionData('approvalBased', [
	        paymasterInput.token,
	        paymasterInput.minimalAllowance,
	        paymasterInput.innerInput
	    ]);
	}
	exports.getApprovalBasedPaymasterInput = getApprovalBasedPaymasterInput;
	function getGeneralPaymasterInput(paymasterInput) {
	    return exports.IPaymasterFlow.encodeFunctionData('general', [paymasterInput.innerInput]);
	}
	exports.getGeneralPaymasterInput = getGeneralPaymasterInput;
	function getPaymasterParams(paymasterAddress, paymasterInput) {
	    if (paymasterInput.type == 'General') {
	        return {
	            paymaster: paymasterAddress,
	            paymasterInput: getGeneralPaymasterInput(paymasterInput)
	        };
	    }
	    else {
	        return {
	            paymaster: paymasterAddress,
	            paymasterInput: getApprovalBasedPaymasterInput(paymasterInput)
	        };
	    }
	}
	exports.getPaymasterParams = getPaymasterParams; 
} (paymasterUtils));

var abi$6 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "blockNumber",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "blockHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "commitment",
				type: "bytes32"
			}
		],
		name: "BlockCommit",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "blockNumber",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "blockHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "commitment",
				type: "bytes32"
			}
		],
		name: "BlockExecution",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "totalBlocksCommitted",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "totalBlocksVerified",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "totalBlocksExecuted",
				type: "uint256"
			}
		],
		name: "BlocksRevert",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "previousLastVerifiedBlock",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "currentLastVerifiedBlock",
				type: "uint256"
			}
		],
		name: "BlocksVerification",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "proposalHash",
				type: "bytes32"
			}
		],
		name: "CancelUpgradeProposal",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "EthWithdrawalFinalized",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "proposalHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "proposalSalt",
				type: "bytes32"
			}
		],
		name: "ExecuteUpgrade",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
		],
		name: "Freeze",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bool",
				name: "isPorterAvailable",
				type: "bool"
			}
		],
		name: "IsPorterAvailableStatusUpdate",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "oldGovernor",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newGovernor",
				type: "address"
			}
		],
		name: "NewGovernor",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "previousBytecodeHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "newBytecodeHash",
				type: "bytes32"
			}
		],
		name: "NewL2BootloaderBytecodeHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "previousBytecodeHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "newBytecodeHash",
				type: "bytes32"
			}
		],
		name: "NewL2DefaultAccountBytecodeHash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "oldPendingGovernor",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newPendingGovernor",
				type: "address"
			}
		],
		name: "NewPendingGovernor",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "txId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint64",
				name: "expirationTimestamp",
				type: "uint64"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "txType",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "from",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "to",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "gasLimit",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "gasPerPubdataByteLimit",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "maxFeePerGas",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "maxPriorityFeePerGas",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "paymaster",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "nonce",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "value",
						type: "uint256"
					},
					{
						internalType: "uint256[4]",
						name: "reserved",
						type: "uint256[4]"
					},
					{
						internalType: "bytes",
						name: "data",
						type: "bytes"
					},
					{
						internalType: "bytes",
						name: "signature",
						type: "bytes"
					},
					{
						internalType: "uint256[]",
						name: "factoryDeps",
						type: "uint256[]"
					},
					{
						internalType: "bytes",
						name: "paymasterInput",
						type: "bytes"
					},
					{
						internalType: "bytes",
						name: "reservedDynamic",
						type: "bytes"
					}
				],
				indexed: false,
				internalType: "struct IMailbox.L2CanonicalTransaction",
				name: "transaction",
				type: "tuple"
			},
			{
				indexed: false,
				internalType: "bytes[]",
				name: "factoryDeps",
				type: "bytes[]"
			}
		],
		name: "NewPriorityRequest",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "oldPriorityTxMaxGasLimit",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "newPriorityTxMaxGasLimit",
				type: "uint256"
			}
		],
		name: "NewPriorityTxMaxGasLimit",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "oldVerifier",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newVerifier",
				type: "address"
			}
		],
		name: "NewVerifier",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "recursionNodeLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionLeafLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionCircuitsSetVksHash",
						type: "bytes32"
					}
				],
				indexed: false,
				internalType: "struct VerifierParams",
				name: "oldVerifierParams",
				type: "tuple"
			},
			{
				components: [
					{
						internalType: "bytes32",
						name: "recursionNodeLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionLeafLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionCircuitsSetVksHash",
						type: "bytes32"
					}
				],
				indexed: false,
				internalType: "struct VerifierParams",
				name: "newVerifierParams",
				type: "tuple"
			}
		],
		name: "NewVerifierParams",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "proposalHash",
				type: "bytes32"
			}
		],
		name: "ProposeShadowUpgrade",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				components: [
					{
						components: [
							{
								internalType: "address",
								name: "facet",
								type: "address"
							},
							{
								internalType: "enum Diamond.Action",
								name: "action",
								type: "uint8"
							},
							{
								internalType: "bool",
								name: "isFreezable",
								type: "bool"
							},
							{
								internalType: "bytes4[]",
								name: "selectors",
								type: "bytes4[]"
							}
						],
						internalType: "struct Diamond.FacetCut[]",
						name: "facetCuts",
						type: "tuple[]"
					},
					{
						internalType: "address",
						name: "initAddress",
						type: "address"
					},
					{
						internalType: "bytes",
						name: "initCalldata",
						type: "bytes"
					}
				],
				indexed: false,
				internalType: "struct Diamond.DiamondCutData",
				name: "diamondCut",
				type: "tuple"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "proposalSalt",
				type: "bytes32"
			}
		],
		name: "ProposeTransparentUpgrade",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "proposalHash",
				type: "bytes32"
			}
		],
		name: "SecurityCouncilUpgradeApprove",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
		],
		name: "Unfreeze",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "validatorAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "isActive",
				type: "bool"
			}
		],
		name: "ValidatorStatusUpdate",
		type: "event"
	},
	{
		inputs: [
		],
		name: "acceptGovernor",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_proposedUpgradeHash",
				type: "bytes32"
			}
		],
		name: "cancelUpgradeProposal",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "uint64",
						name: "blockNumber",
						type: "uint64"
					},
					{
						internalType: "bytes32",
						name: "blockHash",
						type: "bytes32"
					},
					{
						internalType: "uint64",
						name: "indexRepeatedStorageChanges",
						type: "uint64"
					},
					{
						internalType: "uint256",
						name: "numberOfLayer1Txs",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "priorityOperationsHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "l2LogsTreeRoot",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "timestamp",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "commitment",
						type: "bytes32"
					}
				],
				internalType: "struct IExecutor.StoredBlockInfo",
				name: "_lastCommittedBlockData",
				type: "tuple"
			},
			{
				components: [
					{
						internalType: "uint64",
						name: "blockNumber",
						type: "uint64"
					},
					{
						internalType: "uint64",
						name: "timestamp",
						type: "uint64"
					},
					{
						internalType: "uint64",
						name: "indexRepeatedStorageChanges",
						type: "uint64"
					},
					{
						internalType: "bytes32",
						name: "newStateRoot",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "numberOfLayer1Txs",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "l2LogsTreeRoot",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "priorityOperationsHash",
						type: "bytes32"
					},
					{
						internalType: "bytes",
						name: "initialStorageChanges",
						type: "bytes"
					},
					{
						internalType: "bytes",
						name: "repeatedStorageChanges",
						type: "bytes"
					},
					{
						internalType: "bytes",
						name: "l2Logs",
						type: "bytes"
					},
					{
						internalType: "bytes[]",
						name: "l2ArbitraryLengthMessages",
						type: "bytes[]"
					},
					{
						internalType: "bytes[]",
						name: "factoryDeps",
						type: "bytes[]"
					}
				],
				internalType: "struct IExecutor.CommitBlockInfo[]",
				name: "_newBlocksData",
				type: "tuple[]"
			}
		],
		name: "commitBlocks",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "uint64",
						name: "blockNumber",
						type: "uint64"
					},
					{
						internalType: "bytes32",
						name: "blockHash",
						type: "bytes32"
					},
					{
						internalType: "uint64",
						name: "indexRepeatedStorageChanges",
						type: "uint64"
					},
					{
						internalType: "uint256",
						name: "numberOfLayer1Txs",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "priorityOperationsHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "l2LogsTreeRoot",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "timestamp",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "commitment",
						type: "bytes32"
					}
				],
				internalType: "struct IExecutor.StoredBlockInfo[]",
				name: "_blocksData",
				type: "tuple[]"
			}
		],
		name: "executeBlocks",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						components: [
							{
								internalType: "address",
								name: "facet",
								type: "address"
							},
							{
								internalType: "enum Diamond.Action",
								name: "action",
								type: "uint8"
							},
							{
								internalType: "bool",
								name: "isFreezable",
								type: "bool"
							},
							{
								internalType: "bytes4[]",
								name: "selectors",
								type: "bytes4[]"
							}
						],
						internalType: "struct Diamond.FacetCut[]",
						name: "facetCuts",
						type: "tuple[]"
					},
					{
						internalType: "address",
						name: "initAddress",
						type: "address"
					},
					{
						internalType: "bytes",
						name: "initCalldata",
						type: "bytes"
					}
				],
				internalType: "struct Diamond.DiamondCutData",
				name: "_diamondCut",
				type: "tuple"
			},
			{
				internalType: "bytes32",
				name: "_proposalSalt",
				type: "bytes32"
			}
		],
		name: "executeUpgrade",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "_selector",
				type: "bytes4"
			}
		],
		name: "facetAddress",
		outputs: [
			{
				internalType: "address",
				name: "facet",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "facetAddresses",
		outputs: [
			{
				internalType: "address[]",
				name: "facets",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_facet",
				type: "address"
			}
		],
		name: "facetFunctionSelectors",
		outputs: [
			{
				internalType: "bytes4[]",
				name: "",
				type: "bytes4[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "facets",
		outputs: [
			{
				components: [
					{
						internalType: "address",
						name: "addr",
						type: "address"
					},
					{
						internalType: "bytes4[]",
						name: "selectors",
						type: "bytes4[]"
					}
				],
				internalType: "struct IGetters.Facet[]",
				name: "",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_l2BlockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2MessageIndex",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_l2TxNumberInBlock",
				type: "uint16"
			},
			{
				internalType: "bytes",
				name: "_message",
				type: "bytes"
			},
			{
				internalType: "bytes32[]",
				name: "_merkleProof",
				type: "bytes32[]"
			}
		],
		name: "finalizeEthWithdrawal",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "freezeDiamond",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getCurrentProposalId",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getFirstUnprocessedPriorityTx",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getGovernor",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getL2BootloaderBytecodeHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getL2DefaultAccountBytecodeHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getPendingGovernor",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getPriorityQueueSize",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getProposedUpgradeHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getProposedUpgradeTimestamp",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getSecurityCouncil",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getTotalBlocksCommitted",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getTotalBlocksExecuted",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getTotalBlocksVerified",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getTotalPriorityTxs",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getUpgradeProposalState",
		outputs: [
			{
				internalType: "enum UpgradeState",
				name: "",
				type: "uint8"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getVerifier",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getVerifierParams",
		outputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "recursionNodeLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionLeafLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionCircuitsSetVksHash",
						type: "bytes32"
					}
				],
				internalType: "struct VerifierParams",
				name: "",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getpriorityTxMaxGasLimit",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "isApprovedBySecurityCouncil",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "isDiamondStorageFrozen",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_l2BlockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2MessageIndex",
				type: "uint256"
			}
		],
		name: "isEthWithdrawalFinalized",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_facet",
				type: "address"
			}
		],
		name: "isFacetFreezable",
		outputs: [
			{
				internalType: "bool",
				name: "isFreezable",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "_selector",
				type: "bytes4"
			}
		],
		name: "isFunctionFreezable",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "isValidator",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "l2LogsRootHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "hash",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_gasPrice",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2GasLimit",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2GasPerPubdataByteLimit",
				type: "uint256"
			}
		],
		name: "l2TransactionBaseCost",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "priorityQueueFrontOperation",
		outputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "canonicalTxHash",
						type: "bytes32"
					},
					{
						internalType: "uint64",
						name: "expirationTimestamp",
						type: "uint64"
					},
					{
						internalType: "uint192",
						name: "layer2Tip",
						type: "uint192"
					}
				],
				internalType: "struct PriorityOperation",
				name: "",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_proposalHash",
				type: "bytes32"
			},
			{
				internalType: "uint40",
				name: "_proposalId",
				type: "uint40"
			}
		],
		name: "proposeShadowUpgrade",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						components: [
							{
								internalType: "address",
								name: "facet",
								type: "address"
							},
							{
								internalType: "enum Diamond.Action",
								name: "action",
								type: "uint8"
							},
							{
								internalType: "bool",
								name: "isFreezable",
								type: "bool"
							},
							{
								internalType: "bytes4[]",
								name: "selectors",
								type: "bytes4[]"
							}
						],
						internalType: "struct Diamond.FacetCut[]",
						name: "facetCuts",
						type: "tuple[]"
					},
					{
						internalType: "address",
						name: "initAddress",
						type: "address"
					},
					{
						internalType: "bytes",
						name: "initCalldata",
						type: "bytes"
					}
				],
				internalType: "struct Diamond.DiamondCutData",
				name: "_diamondCut",
				type: "tuple"
			},
			{
				internalType: "uint40",
				name: "_proposalId",
				type: "uint40"
			}
		],
		name: "proposeTransparentUpgrade",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "uint64",
						name: "blockNumber",
						type: "uint64"
					},
					{
						internalType: "bytes32",
						name: "blockHash",
						type: "bytes32"
					},
					{
						internalType: "uint64",
						name: "indexRepeatedStorageChanges",
						type: "uint64"
					},
					{
						internalType: "uint256",
						name: "numberOfLayer1Txs",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "priorityOperationsHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "l2LogsTreeRoot",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "timestamp",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "commitment",
						type: "bytes32"
					}
				],
				internalType: "struct IExecutor.StoredBlockInfo",
				name: "_prevBlock",
				type: "tuple"
			},
			{
				components: [
					{
						internalType: "uint64",
						name: "blockNumber",
						type: "uint64"
					},
					{
						internalType: "bytes32",
						name: "blockHash",
						type: "bytes32"
					},
					{
						internalType: "uint64",
						name: "indexRepeatedStorageChanges",
						type: "uint64"
					},
					{
						internalType: "uint256",
						name: "numberOfLayer1Txs",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "priorityOperationsHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "l2LogsTreeRoot",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "timestamp",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "commitment",
						type: "bytes32"
					}
				],
				internalType: "struct IExecutor.StoredBlockInfo[]",
				name: "_committedBlocks",
				type: "tuple[]"
			},
			{
				components: [
					{
						internalType: "uint256[]",
						name: "recursiveAggregationInput",
						type: "uint256[]"
					},
					{
						internalType: "uint256[]",
						name: "serializedProof",
						type: "uint256[]"
					}
				],
				internalType: "struct IExecutor.ProofInput",
				name: "_proof",
				type: "tuple"
			}
		],
		name: "proveBlocks",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_l2TxHash",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_l2BlockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2MessageIndex",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_l2TxNumberInBlock",
				type: "uint16"
			},
			{
				internalType: "bytes32[]",
				name: "_merkleProof",
				type: "bytes32[]"
			},
			{
				internalType: "enum TxStatus",
				name: "_status",
				type: "uint8"
			}
		],
		name: "proveL1ToL2TransactionStatus",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_index",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "uint8",
						name: "l2ShardId",
						type: "uint8"
					},
					{
						internalType: "bool",
						name: "isService",
						type: "bool"
					},
					{
						internalType: "uint16",
						name: "txNumberInBlock",
						type: "uint16"
					},
					{
						internalType: "address",
						name: "sender",
						type: "address"
					},
					{
						internalType: "bytes32",
						name: "key",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "value",
						type: "bytes32"
					}
				],
				internalType: "struct L2Log",
				name: "_log",
				type: "tuple"
			},
			{
				internalType: "bytes32[]",
				name: "_proof",
				type: "bytes32[]"
			}
		],
		name: "proveL2LogInclusion",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_index",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "uint16",
						name: "txNumberInBlock",
						type: "uint16"
					},
					{
						internalType: "address",
						name: "sender",
						type: "address"
					},
					{
						internalType: "bytes",
						name: "data",
						type: "bytes"
					}
				],
				internalType: "struct L2Message",
				name: "_message",
				type: "tuple"
			},
			{
				internalType: "bytes32[]",
				name: "_proof",
				type: "bytes32[]"
			}
		],
		name: "proveL2MessageInclusion",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_contractL2",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_l2Value",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "_calldata",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "_l2GasLimit",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2GasPerPubdataByteLimit",
				type: "uint256"
			},
			{
				internalType: "bytes[]",
				name: "_factoryDeps",
				type: "bytes[]"
			},
			{
				internalType: "address",
				name: "_refundRecipient",
				type: "address"
			}
		],
		name: "requestL2Transaction",
		outputs: [
			{
				internalType: "bytes32",
				name: "canonicalTxHash",
				type: "bytes32"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_newLastBlock",
				type: "uint256"
			}
		],
		name: "revertBlocks",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_upgradeProposalHash",
				type: "bytes32"
			}
		],
		name: "securityCouncilUpgradeApprove",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_l2BootloaderBytecodeHash",
				type: "bytes32"
			}
		],
		name: "setL2BootloaderBytecodeHash",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_l2DefaultAccountBytecodeHash",
				type: "bytes32"
			}
		],
		name: "setL2DefaultAccountBytecodeHash",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_newPendingGovernor",
				type: "address"
			}
		],
		name: "setPendingGovernor",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bool",
				name: "_zkPorterIsAvailable",
				type: "bool"
			}
		],
		name: "setPorterAvailability",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_newPriorityTxMaxGasLimit",
				type: "uint256"
			}
		],
		name: "setPriorityTxMaxGasLimit",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_validator",
				type: "address"
			},
			{
				internalType: "bool",
				name: "_active",
				type: "bool"
			}
		],
		name: "setValidator",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract Verifier",
				name: "_newVerifier",
				type: "address"
			}
		],
		name: "setVerifier",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "recursionNodeLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionLeafLevelVkHash",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "recursionCircuitsSetVksHash",
						type: "bytes32"
					}
				],
				internalType: "struct VerifierParams",
				name: "_newVerifierParams",
				type: "tuple"
			}
		],
		name: "setVerifierParams",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "storedBlockHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "unfreezeDiamond",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						components: [
							{
								internalType: "address",
								name: "facet",
								type: "address"
							},
							{
								internalType: "enum Diamond.Action",
								name: "action",
								type: "uint8"
							},
							{
								internalType: "bool",
								name: "isFreezable",
								type: "bool"
							},
							{
								internalType: "bytes4[]",
								name: "selectors",
								type: "bytes4[]"
							}
						],
						internalType: "struct Diamond.FacetCut[]",
						name: "facetCuts",
						type: "tuple[]"
					},
					{
						internalType: "address",
						name: "initAddress",
						type: "address"
					},
					{
						internalType: "bytes",
						name: "initCalldata",
						type: "bytes"
					}
				],
				internalType: "struct Diamond.DiamondCutData",
				name: "_diamondCut",
				type: "tuple"
			},
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "_salt",
				type: "bytes32"
			}
		],
		name: "upgradeProposalHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "pure",
		type: "function"
	}
];
var require$$6 = {
	abi: abi$6
};

var abi$5 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "accountAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "enum IContractDeployer.AccountNonceOrdering",
				name: "nonceOrdering",
				type: "uint8"
			}
		],
		name: "AccountNonceOrderingUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "accountAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "enum IContractDeployer.AccountAbstractionVersion",
				name: "aaVersion",
				type: "uint8"
			}
		],
		name: "AccountVersionUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "deployerAddress",
				type: "address"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "bytecodeHash",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "contractAddress",
				type: "address"
			}
		],
		name: "ContractDeployed",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_salt",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_bytecodeHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_input",
				type: "bytes"
			}
		],
		name: "create",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_salt",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_bytecodeHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_input",
				type: "bytes"
			}
		],
		name: "create2",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_salt",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_bytecodeHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_input",
				type: "bytes"
			},
			{
				internalType: "enum IContractDeployer.AccountAbstractionVersion",
				name: "_aaVersion",
				type: "uint8"
			}
		],
		name: "create2Account",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_bytecodeHash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_input",
				type: "bytes"
			},
			{
				internalType: "enum IContractDeployer.AccountAbstractionVersion",
				name: "_aaVersion",
				type: "uint8"
			}
		],
		name: "createAccount",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "extendedAccountVersion",
		outputs: [
			{
				internalType: "enum IContractDeployer.AccountAbstractionVersion",
				name: "",
				type: "uint8"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "bytecodeHash",
						type: "bytes32"
					},
					{
						internalType: "address",
						name: "newAddress",
						type: "address"
					},
					{
						internalType: "bool",
						name: "callConstructor",
						type: "bool"
					},
					{
						internalType: "uint256",
						name: "value",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "input",
						type: "bytes"
					}
				],
				internalType: "struct ContractDeployer.ForceDeployment",
				name: "_deployment",
				type: "tuple"
			},
			{
				internalType: "address",
				name: "_sender",
				type: "address"
			}
		],
		name: "forceDeployOnAddress",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "bytecodeHash",
						type: "bytes32"
					},
					{
						internalType: "address",
						name: "newAddress",
						type: "address"
					},
					{
						internalType: "bool",
						name: "callConstructor",
						type: "bool"
					},
					{
						internalType: "uint256",
						name: "value",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "input",
						type: "bytes"
					}
				],
				internalType: "struct ContractDeployer.ForceDeployment[]",
				name: "_deployments",
				type: "tuple[]"
			}
		],
		name: "forceDeployOnAddresses",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "getAccountInfo",
		outputs: [
			{
				components: [
					{
						internalType: "enum IContractDeployer.AccountAbstractionVersion",
						name: "supportedAAVersion",
						type: "uint8"
					},
					{
						internalType: "enum IContractDeployer.AccountNonceOrdering",
						name: "nonceOrdering",
						type: "uint8"
					}
				],
				internalType: "struct IContractDeployer.AccountInfo",
				name: "info",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_sender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_senderNonce",
				type: "uint256"
			}
		],
		name: "getNewAddressCreate",
		outputs: [
			{
				internalType: "address",
				name: "newAddress",
				type: "address"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_sender",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_bytecodeHash",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_salt",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_input",
				type: "bytes"
			}
		],
		name: "getNewAddressCreate2",
		outputs: [
			{
				internalType: "address",
				name: "newAddress",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "enum IContractDeployer.AccountAbstractionVersion",
				name: "_version",
				type: "uint8"
			}
		],
		name: "updateAccountVersion",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "enum IContractDeployer.AccountNonceOrdering",
				name: "_nonceOrdering",
				type: "uint8"
			}
		],
		name: "updateNonceOrdering",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$7 = {
	abi: abi$5
};

var abi$4 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_sender",
				type: "address"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_hash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_message",
				type: "bytes"
			}
		],
		name: "L1MessageSent",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_message",
				type: "bytes"
			}
		],
		name: "sendToL1",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$8 = {
	abi: abi$4
};

var abi$3 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				internalType: "uint8",
				name: "",
				type: "uint8"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$9 = {
	abi: abi$3
};

var abi$2 = [
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "hash",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "magicValue",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];
var require$$10 = {
	abi: abi$2
};

var abi$1 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l1Token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "ClaimedFailedDeposit",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l1Token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "DepositInitiated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l1Token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "WithdrawalFinalized",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_depositSender",
				type: "address"
			},
			{
				internalType: "address",
				name: "_l1Token",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_l2TxHash",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_l2BlockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2MessageIndex",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_l2TxNumberInBlock",
				type: "uint16"
			},
			{
				internalType: "bytes32[]",
				name: "_merkleProof",
				type: "bytes32[]"
			}
		],
		name: "claimFailedDeposit",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_l2Receiver",
				type: "address"
			},
			{
				internalType: "address",
				name: "_l1Token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2TxGasLimit",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2TxGasPerPubdataByte",
				type: "uint256"
			}
		],
		name: "deposit",
		outputs: [
			{
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_l2BlockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2MessageIndex",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_l2TxNumberInBlock",
				type: "uint16"
			},
			{
				internalType: "bytes",
				name: "_message",
				type: "bytes"
			},
			{
				internalType: "bytes32[]",
				name: "_merkleProof",
				type: "bytes32[]"
			}
		],
		name: "finalizeWithdrawal",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_l2BlockNumber",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_l2MessageIndex",
				type: "uint256"
			}
		],
		name: "isWithdrawalFinalized",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_l1Token",
				type: "address"
			}
		],
		name: "l2TokenAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];
var require$$11 = {
	abi: abi$1
};

var abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "l1Sender",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l2Receiver",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l2Token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "FinalizeDeposit",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "l2Sender",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l1Receiver",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "l2Token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "WithdrawalInitiated",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_l1Sender",
				type: "address"
			},
			{
				internalType: "address",
				name: "_l2Receiver",
				type: "address"
			},
			{
				internalType: "address",
				name: "_l1Token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		name: "finalizeDeposit",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "l1Bridge",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_l2Token",
				type: "address"
			}
		],
		name: "l1TokenAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_l1Token",
				type: "address"
			}
		],
		name: "l2TokenAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_l1Receiver",
				type: "address"
			},
			{
				internalType: "address",
				name: "_l2Token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "withdraw",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$12 = {
	abi: abi
};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$d;
	hasRequiredUtils$2 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.parseTransaction = exports.hashBytecode = exports.serialize = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = exports.MAX_BYTECODE_LEN_BYTES = exports.PRIORITY_OPERATION_L2_TX_TYPE = exports.EIP712_TX_TYPE = exports.EIP1271_MAGIC_VALUE = exports.L1_TO_L2_ALIAS_OFFSET = exports.L2_ETH_TOKEN_ADDRESS = exports.L1_MESSENGER_ADDRESS = exports.CONTRACT_DEPLOYER_ADDRESS = exports.BOOTLOADER_FORMAL_ADDRESS = exports.L2_BRIDGE_ABI = exports.L1_BRIDGE_ABI = exports.IERC1271 = exports.IERC20 = exports.L1_MESSENGER = exports.CONTRACT_DEPLOYER = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;
		const ethers_1 = require$$0$d;
		const types_1 = types$3;
		const signer_1 = requireSigner();
		const typechain_1 = typechain;
		const utils_1 = utils$t;
		__exportStar(paymasterUtils, exports);
		exports.ETH_ADDRESS = '0x0000000000000000000000000000000000000000';
		exports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(require$$6.abi);
		exports.CONTRACT_DEPLOYER = new ethers_1.utils.Interface(require$$7.abi);
		exports.L1_MESSENGER = new ethers_1.utils.Interface(require$$8.abi);
		exports.IERC20 = new ethers_1.utils.Interface(require$$9.abi);
		exports.IERC1271 = new ethers_1.utils.Interface(require$$10.abi);
		exports.L1_BRIDGE_ABI = new ethers_1.utils.Interface(require$$11.abi);
		exports.L2_BRIDGE_ABI = new ethers_1.utils.Interface(require$$12.abi);
		exports.BOOTLOADER_FORMAL_ADDRESS = '0x0000000000000000000000000000000000008001';
		exports.CONTRACT_DEPLOYER_ADDRESS = '0x0000000000000000000000000000000000008006';
		exports.L1_MESSENGER_ADDRESS = '0x0000000000000000000000000000000000008008';
		exports.L2_ETH_TOKEN_ADDRESS = '0x000000000000000000000000000000000000800a';
		exports.L1_TO_L2_ALIAS_OFFSET = '0x1111000000000000000000000000000000001111';
		exports.EIP1271_MAGIC_VALUE = '0x1626ba7e';
		exports.EIP712_TX_TYPE = 0x71;
		exports.PRIORITY_OPERATION_L2_TX_TYPE = 0xff;
		exports.MAX_BYTECODE_LEN_BYTES = ((1 << 16) - 1) * 32;
		// The large L2 gas per pubdata to sign. This gas is enough to ensure that
		// any reasonable limit will be accepted. Note, that the operator is NOT required to
		// use the honest value of gas per pubdata and it can use any value up to the one signed by the user.
		// In the future releases, we will provide a way to estimate the current gasPerPubdata.
		exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = 50000;
		// It is possible to provide practically any gasPerPubdataByte for L1->L2 transactions, since
		// the cost per gas will be adjusted respectively. We will use 800 as an relatively optimal value for now.
		exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = 800;
		function isETH(token) {
		    return token.toLowerCase() == exports.ETH_ADDRESS || token.toLowerCase() == exports.L2_ETH_TOKEN_ADDRESS;
		}
		exports.isETH = isETH;
		function sleep(millis) {
		    return new Promise((resolve) => setTimeout(resolve, millis));
		}
		exports.sleep = sleep;
		function layer1TxDefaults() {
		    return {
		        queueType: types_1.PriorityQueueType.Deque,
		        opTree: types_1.PriorityOpTree.Full
		    };
		}
		exports.layer1TxDefaults = layer1TxDefaults;
		function getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {
		    const encodedMsg = new Uint8Array([
		        0,
		        1,
		        ...ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(txNumberInBlock), 2),
		        ...ethers_1.ethers.utils.arrayify(exports.L1_MESSENGER_ADDRESS),
		        ...ethers_1.ethers.utils.zeroPad(sender, 32),
		        ...ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.keccak256(msg))
		    ]);
		    return ethers_1.ethers.utils.keccak256(encodedMsg);
		}
		exports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;
		function getDeployedContracts(receipt) {
		    const addressBytesLen = 40;
		    const deployedContracts = receipt.logs
		        .filter((log) => log.topics[0] == ethers_1.utils.id('ContractDeployed(address,bytes32,address)') &&
		        log.address == exports.CONTRACT_DEPLOYER_ADDRESS)
		        // Take the last topic (deployed contract address as U256) and extract address from it (U160).
		        .map((log) => {
		        const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;
		        const bytesCodehash = log.topics[2];
		        const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;
		        return {
		            sender: ethers_1.utils.getAddress(sender),
		            bytecodeHash: bytesCodehash,
		            deployedAddress: ethers_1.utils.getAddress(address)
		        };
		    });
		    return deployedContracts;
		}
		exports.getDeployedContracts = getDeployedContracts;
		function create2Address(sender, bytecodeHash, salt, input) {
		    const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate2'));
		    const inputHash = ethers_1.ethers.utils.keccak256(input);
		    const addressBytes = ethers_1.ethers.utils
		        .keccak256(ethers_1.ethers.utils.concat([prefix, ethers_1.ethers.utils.zeroPad(sender, 32), salt, bytecodeHash, inputHash]))
		        .slice(26);
		    return ethers_1.ethers.utils.getAddress(addressBytes);
		}
		exports.create2Address = create2Address;
		function createAddress(sender, senderNonce) {
		    const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate'));
		    const addressBytes = ethers_1.ethers.utils
		        .keccak256(ethers_1.ethers.utils.concat([
		        prefix,
		        ethers_1.ethers.utils.zeroPad(sender, 32),
		        ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(senderNonce), 32)
		    ]))
		        .slice(26);
		    return ethers_1.ethers.utils.getAddress(addressBytes);
		}
		exports.createAddress = createAddress;
		async function checkBaseCost(baseCost, value) {
		    if (baseCost.gt(await value)) {
		        throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter ` +
		            `for the transaction: baseCost: ${baseCost}, provided value: ${value}`);
		    }
		}
		exports.checkBaseCost = checkBaseCost;
		function serialize(transaction, signature) {
		    var _a;
		    if (transaction.customData == null && transaction.type != exports.EIP712_TX_TYPE) {
		        return ethers_1.utils.serializeTransaction(transaction, signature);
		    }
		    if (!transaction.chainId) {
		        throw Error("Transaction chainId isn't set");
		    }
		    function formatNumber(value, name) {
		        const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());
		        if (result.length > 32) {
		            throw new Error('invalid length for ' + name);
		        }
		        return result;
		    }
		    if (!transaction.from) {
		        throw new Error('Explicitly providing `from` field is reqiured for EIP712 transactions');
		    }
		    const from = transaction.from;
		    const meta = transaction.customData;
		    let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;
		    let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
		    const fields = [
		        formatNumber(transaction.nonce || 0, 'nonce'),
		        formatNumber(maxPriorityFeePerGas, 'maxPriorityFeePerGas'),
		        formatNumber(maxFeePerGas, 'maxFeePerGas'),
		        formatNumber(transaction.gasLimit || 0, 'gasLimit'),
		        transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : '0x',
		        formatNumber(transaction.value || 0, 'value'),
		        transaction.data || '0x'
		    ];
		    if (signature) {
		        const sig = ethers_1.utils.splitSignature(signature);
		        fields.push(formatNumber(sig.recoveryParam, 'recoveryParam'));
		        fields.push(ethers_1.utils.stripZeros(sig.r));
		        fields.push(ethers_1.utils.stripZeros(sig.s));
		    }
		    else {
		        fields.push(formatNumber(transaction.chainId, 'chainId'));
		        fields.push('0x');
		        fields.push('0x');
		    }
		    fields.push(formatNumber(transaction.chainId, 'chainId'));
		    fields.push(ethers_1.utils.getAddress(from));
		    // Add meta
		    fields.push(formatNumber(meta.gasPerPubdata || exports.DEFAULT_GAS_PER_PUBDATA_LIMIT, 'gasPerPubdata'));
		    fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map((dep) => ethers_1.utils.hexlify(dep)));
		    if (meta.customSignature && ethers_1.ethers.utils.arrayify(meta.customSignature).length == 0) {
		        throw new Error('Empty signatures are not supported');
		    }
		    fields.push(meta.customSignature || '0x');
		    if (meta.paymasterParams) {
		        fields.push([meta.paymasterParams.paymaster, ethers_1.ethers.utils.hexlify(meta.paymasterParams.paymasterInput)]);
		    }
		    else {
		        fields.push([]);
		    }
		    return ethers_1.utils.hexConcat([[exports.EIP712_TX_TYPE], ethers_1.utils.RLP.encode(fields)]);
		}
		exports.serialize = serialize;
		function hashBytecode(bytecode) {
		    // For getting the consistent length we first convert the bytecode to UInt8Array
		    const bytecodeAsArray = ethers_1.ethers.utils.arrayify(bytecode);
		    if (bytecodeAsArray.length % 32 != 0) {
		        throw new Error('The bytecode length in bytes must be divisible by 32');
		    }
		    if (bytecodeAsArray.length > exports.MAX_BYTECODE_LEN_BYTES) {
		        throw new Error(`Bytecode can not be longer than ${exports.MAX_BYTECODE_LEN_BYTES} bytes`);
		    }
		    const hashStr = ethers_1.ethers.utils.sha256(bytecodeAsArray);
		    const hash = ethers_1.ethers.utils.arrayify(hashStr);
		    // Note that the length of the bytecode
		    // should be provided in 32-byte words.
		    const bytecodeLengthInWords = bytecodeAsArray.length / 32;
		    if (bytecodeLengthInWords % 2 == 0) {
		        throw new Error('Bytecode length in 32-byte words must be odd');
		    }
		    const bytecodeLength = ethers_1.ethers.utils.arrayify(bytecodeLengthInWords);
		    // The bytecode should always take the first 2 bytes of the bytecode hash,
		    // so we pad it from the left in case the length is smaller than 2 bytes.
		    const bytecodeLengthPadded = ethers_1.ethers.utils.zeroPad(bytecodeLength, 2);
		    const codeHashVersion = new Uint8Array([1, 0]);
		    hash.set(codeHashVersion, 0);
		    hash.set(bytecodeLengthPadded, 2);
		    return hash;
		}
		exports.hashBytecode = hashBytecode;
		function parseTransaction(payload) {
		    function handleAddress(value) {
		        if (value === '0x') {
		            return null;
		        }
		        return ethers_1.utils.getAddress(value);
		    }
		    function handleNumber(value) {
		        if (value === '0x') {
		            return ethers_1.BigNumber.from(0);
		        }
		        return ethers_1.BigNumber.from(value);
		    }
		    function arrayToPaymasterParams(arr) {
		        if (arr.length == 0) {
		            return undefined;
		        }
		        if (arr.length != 2) {
		            throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`);
		        }
		        return {
		            paymaster: ethers_1.utils.getAddress(arr[0]),
		            paymasterInput: ethers_1.utils.arrayify(arr[1])
		        };
		    }
		    const bytes = ethers_1.utils.arrayify(payload);
		    if (bytes[0] != exports.EIP712_TX_TYPE) {
		        return ethers_1.utils.parseTransaction(bytes);
		    }
		    const raw = ethers_1.utils.RLP.decode(bytes.slice(1));
		    const transaction = {
		        type: exports.EIP712_TX_TYPE,
		        nonce: handleNumber(raw[0]).toNumber(),
		        maxPriorityFeePerGas: handleNumber(raw[1]),
		        maxFeePerGas: handleNumber(raw[2]),
		        gasLimit: handleNumber(raw[3]),
		        to: handleAddress(raw[4]),
		        value: handleNumber(raw[5]),
		        data: raw[6],
		        chainId: handleNumber(raw[10]),
		        from: handleAddress(raw[11]),
		        customData: {
		            gasPerPubdata: handleNumber(raw[12]),
		            factoryDeps: raw[13],
		            customSignature: raw[14],
		            paymasterParams: arrayToPaymasterParams(raw[15])
		        }
		    };
		    const ethSignature = {
		        v: handleNumber(raw[7]).toNumber(),
		        r: raw[8],
		        s: raw[9]
		    };
		    if ((ethers_1.utils.hexlify(ethSignature.r) == '0x' || ethers_1.utils.hexlify(ethSignature.s) == '0x') &&
		        !transaction.customData.customSignature) {
		        return transaction;
		    }
		    if (ethSignature.v !== 0 && ethSignature.v !== 1 && !transaction.customData.customSignature) {
		        throw new Error('Failed to parse signature');
		    }
		    if (!transaction.customData.customSignature) {
		        transaction.v = ethSignature.v;
		        transaction.s = ethSignature.s;
		        transaction.r = ethSignature.r;
		    }
		    transaction.hash = eip712TxHash(transaction, ethSignature);
		    return transaction;
		}
		exports.parseTransaction = parseTransaction;
		function getSignature(transaction, ethSignature) {
		    var _a;
		    if (((_a = transaction === null || transaction === void 0 ? void 0 : transaction.customData) === null || _a === void 0 ? void 0 : _a.customSignature) && transaction.customData.customSignature.length) {
		        return ethers_1.ethers.utils.arrayify(transaction.customData.customSignature);
		    }
		    if (!ethSignature) {
		        throw new Error('No signature provided');
		    }
		    const r = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.r), 32);
		    const s = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.s), 32);
		    const v = ethSignature.v;
		    return new Uint8Array([...r, ...s, v]);
		}
		function eip712TxHash(transaction, ethSignature) {
		    const signedDigest = signer_1.EIP712Signer.getSignedDigest(transaction);
		    const hashedSignature = ethers_1.ethers.utils.keccak256(getSignature(transaction, ethSignature));
		    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.hexConcat([signedDigest, hashedSignature]));
		}
		function getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {
		    let txHash = null;
		    for (const log of txReceipt.logs) {
		        if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {
		            continue;
		        }
		        try {
		            const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);
		            if (priorityQueueLog && priorityQueueLog.args.txHash != null) {
		                txHash = priorityQueueLog.args.txHash;
		            }
		        }
		        catch { }
		    }
		    if (!txHash) {
		        throw new Error('Failed to parse tx logs');
		    }
		    return txHash;
		}
		exports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;
		const ADDRESS_MODULO = ethers_1.BigNumber.from(2).pow(160);
		function applyL1ToL2Alias(address) {
		    return ethers_1.ethers.utils.hexlify(ethers_1.ethers.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET).mod(ADDRESS_MODULO));
		}
		exports.applyL1ToL2Alias = applyL1ToL2Alias;
		function undoL1ToL2Alias(address) {
		    let result = ethers_1.ethers.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET);
		    if (result.lt(ethers_1.BigNumber.from(0))) {
		        result = result.add(ADDRESS_MODULO);
		    }
		    return ethers_1.ethers.utils.hexlify(result);
		}
		exports.undoL1ToL2Alias = undoL1ToL2Alias;
		/// Getters data used to correctly initialize the L1 token counterpart on L2
		async function getERC20GettersData(l1TokenAddress, provider) {
		    const token = typechain_1.IERC20MetadataFactory.connect(l1TokenAddress, provider);
		    const name = await token.name();
		    const symbol = await token.symbol();
		    const decimals = await token.decimals();
		    const coder = new utils_1.AbiCoder();
		    const nameBytes = coder.encode(['string'], [name]);
		    const symbolBytes = coder.encode(['string'], [symbol]);
		    const decimalsBytes = coder.encode(['uint256'], [decimals]);
		    return coder.encode(['bytes', 'bytes', 'bytes'], [nameBytes, symbolBytes, decimalsBytes]);
		}
		/// The method that returns the calldata that will be sent by an L1 ERC20 bridge to its L2 counterpart
		/// during bridging of a token.
		async function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, provider) {
		    const gettersData = await getERC20GettersData(l1TokenAddress, provider);
		    return exports.L2_BRIDGE_ABI.encodeFunctionData('finalizeDeposit', [
		        l1Sender,
		        l2Receiver,
		        l1TokenAddress,
		        amount,
		        gettersData
		    ]);
		}
		exports.getERC20BridgeCalldata = getERC20BridgeCalldata;
		// The method with similar functionality is already available in ethers.js,
		// the only difference is that we provide additional `try { } catch { }`
		// for error-resilience.
		//
		// It will also pave the road for allowing future EIP-1271 signature verification, by
		// letting our SDK have functionality to verify signatures.
		function isECDSASignatureCorrect(address, msgHash, signature) {
		    try {
		        return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);
		    }
		    catch {
		        // In case ECDSA signature verification has thrown an error,
		        // we simply consider the signature as incorrect.
		        return false;
		    }
		}
		async function isEIP1271SignatureCorrect(provider, address, msgHash, signature) {
		    const accountContract = new ethers_1.ethers.Contract(address, exports.IERC1271, provider);
		    // This line may throw an exception if the contract does not implement the EIP1271 correctly.
		    // But it may also throw an exception in case the internet connection is lost.
		    // It is the caller's responsibility to handle the exception.
		    const result = await accountContract.isValidSignature(msgHash, signature);
		    return result == exports.EIP1271_MAGIC_VALUE;
		}
		async function isSignatureCorrect(provider, address, msgHash, signature) {
		    let isContractAccount = false;
		    const code = await provider.getCode(address);
		    isContractAccount = ethers_1.ethers.utils.arrayify(code).length != 0;
		    if (!isContractAccount) {
		        return isECDSASignatureCorrect(address, msgHash, signature);
		    }
		    else {
		        return await isEIP1271SignatureCorrect(provider, address, msgHash, signature);
		    }
		}
		// Returns `true` or `false` depending on whether or not the account abstraction's
		// signature is correct. Note, that while currently it does not do any `async` actions.
		// in the future it will. That's why the `Promise<boolean>` is returned.
		async function isMessageSignatureCorrect(provider, address, message, signature) {
		    const msgHash = ethers_1.ethers.utils.hashMessage(message);
		    return await isSignatureCorrect(provider, address, msgHash, signature);
		}
		exports.isMessageSignatureCorrect = isMessageSignatureCorrect;
		// Returns `true` or `false` depending on whether or not the account abstraction's
		// EIP712 signature is correct. Note, that while currently it does not do any `async` actions.
		// in the future it will. That's why the `Promise<boolean>` is returned.
		async function isTypedDataSignatureCorrect(provider, address, domain, types, value, signature) {
		    const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);
		    return await isSignatureCorrect(provider, address, msgHash, signature);
		}
		exports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;
		async function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {
		    // If the `from` address is not provided, we use a random address, because
		    // due to storage slot aggregation, the gas estimation will depend on the address
		    // and so estimation for the zero address may be smaller than for the sender.
		    from !== null && from !== void 0 ? from : (from = ethers_1.ethers.Wallet.createRandom().address);
		    if (token == exports.ETH_ADDRESS) {
		        return await providerL2.estimateL1ToL2Execute({
		            contractAddress: to,
		            gasPerPubdataByte: gasPerPubdataByte,
		            caller: from,
		            calldata: '0x',
		            l2Value: amount
		        });
		    }
		    else {
		        const l1ERC20BridgeAddresses = (await providerL2.getDefaultBridgeAddresses()).erc20L1;
		        const erc20BridgeAddress = (await providerL2.getDefaultBridgeAddresses()).erc20L2;
		        const calldata = await getERC20BridgeCalldata(token, from, to, amount, providerL1);
		        return await providerL2.estimateL1ToL2Execute({
		            caller: applyL1ToL2Alias(l1ERC20BridgeAddresses),
		            contractAddress: erc20BridgeAddress,
		            gasPerPubdataByte: gasPerPubdataByte,
		            calldata: calldata
		        });
		    }
		}
		exports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas; 
	} (utils$d));
	return utils$d;
}

var wallet = {};

Object.defineProperty(wallet, "__esModule", { value: true });
wallet.Wallet = void 0;
const signer_1$1 = requireSigner();
const utils_1$q = requireUtils$2();
const ethers_1$n = require$$0$d;
const adapters_1 = requireAdapters();
class Wallet extends (0, adapters_1.AdapterL2)((0, adapters_1.AdapterL1)(ethers_1$n.ethers.Wallet)) {
    _providerL1() {
        if (this.providerL1 == null) {
            throw new Error('L1 provider missing: use `connectToL1` to specify');
        }
        return this.providerL1;
    }
    _providerL2() {
        return this.provider;
    }
    _signerL1() {
        return this.ethWallet();
    }
    _signerL2() {
        return this;
    }
    ethWallet() {
        return new ethers_1$n.ethers.Wallet(this._signingKey(), this._providerL1());
    }
    // an alias with a better name
    async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
    }
    connect(provider) {
        return new Wallet(this._signingKey(), provider, this.providerL1);
    }
    connectToL1(provider) {
        return new Wallet(this._signingKey(), this.provider, provider);
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        const wallet = super.fromMnemonic(mnemonic, path, wordlist);
        return new Wallet(wallet._signingKey());
    }
    static async fromEncryptedJson(json, password, callback) {
        const wallet = await super.fromEncryptedJson(json, password, callback);
        return new Wallet(wallet._signingKey());
    }
    static fromEncryptedJsonSync(json, password) {
        const wallet = super.fromEncryptedJsonSync(json, password);
        return new Wallet(wallet._signingKey());
    }
    static createRandom(options) {
        const wallet = super.createRandom(options);
        return new Wallet(wallet._signingKey());
    }
    constructor(privateKey, providerL2, providerL1) {
        super(privateKey, providerL2);
        if (this.provider != null) {
            const chainId = this.getChainId();
            // @ts-ignore
            this.eip712 = new signer_1$1.EIP712Signer(this, chainId);
        }
        this.providerL1 = providerL1;
    }
    async populateTransaction(transaction) {
        var _a, _b;
        if (transaction.type == null && transaction.customData == null) {
            // use legacy txs by default
            transaction.type = 0;
        }
        transaction = await super.populateTransaction(transaction);
        if (transaction.customData == null && transaction.type != utils_1$q.EIP712_TX_TYPE) {
            return transaction;
        }
        transaction.type = utils_1$q.EIP712_TX_TYPE;
        (_a = transaction.value) !== null && _a !== void 0 ? _a : (transaction.value = 0);
        (_b = transaction.data) !== null && _b !== void 0 ? _b : (transaction.data = '0x');
        transaction.customData = this._fillCustomData(transaction.customData);
        transaction.gasPrice = await this.provider.getGasPrice();
        return transaction;
    }
    async signTransaction(transaction) {
        var _a;
        if (transaction.customData == null && transaction.type != utils_1$q.EIP712_TX_TYPE) {
            if (transaction.type == 2 && transaction.maxFeePerGas == null) {
                transaction.maxFeePerGas = await this.provider.getGasPrice();
            }
            return await super.signTransaction(transaction);
        }
        else {
            (_a = transaction.from) !== null && _a !== void 0 ? _a : (transaction.from = this.address);
            if (transaction.from.toLowerCase() != this.address.toLowerCase()) {
                throw new Error('Transaction `from` address mismatch');
            }
            transaction.customData.customSignature = await this.eip712.sign(transaction);
            return (0, utils_1$q.serialize)(transaction);
        }
    }
    async sendTransaction(transaction) {
        // Typescript isn't smart enough to recognise that wallet.sendTransaction
        // calls provider.sendTransaction which returns our extended type and not ethers' one.
        return (await super.sendTransaction(transaction));
    }
}
wallet.Wallet = Wallet;

var provider$1 = {};

Object.defineProperty(provider$1, "__esModule", { value: true });
provider$1.Web3Provider = provider$1.Provider = void 0;
const ethers_1$m = require$$0$d;
var Formatter = ethers_1$m.providers.Formatter;
const web_1 = require$$1$8;
const typechain_1 = typechain;
const types_1$3 = types$3;
const utils_1$p = requireUtils$2();
const signer_1 = requireSigner();
let defaultFormatter = null;
class Provider extends ethers_1$m.ethers.providers.JsonRpcProvider {
    async getTransactionReceipt(transactionHash) {
        await this.getNetwork();
        transactionHash = await transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return (0, web_1.poll)(async () => {
            const result = await this.perform('getTransactionReceipt', params);
            if (result == null) {
                if (this._emitted['t:' + transactionHash] == null) {
                    return null;
                }
                return undefined;
            }
            if (result.blockNumber == null && result.status != null && ethers_1$m.BigNumber.from(result.status).isZero()) {
                // transaction is rejected in the state-keeper
                return {
                    ...this.formatter.receipt({
                        ...result,
                        confirmations: 1,
                        blockNumber: 0,
                        blockHash: ethers_1$m.ethers.constants.HashZero
                    }),
                    blockNumber: null,
                    blockHash: null,
                    l1BatchNumber: null,
                    l1BatchTxIndex: null
                };
            }
            if (result.blockHash == null) {
                // receipt is not ready
                return undefined;
            }
            else {
                const receipt = this.formatter.receipt(result);
                if (receipt.blockNumber == null) {
                    receipt.confirmations = 0;
                }
                else if (receipt.confirmations == null) {
                    const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    // Add the confirmations using the fast block number (pessimistic)
                    let confirmations = blockNumber - receipt.blockNumber + 1;
                    if (confirmations <= 0) {
                        confirmations = 1;
                    }
                    receipt.confirmations = confirmations;
                }
                return receipt;
            }
        }, { oncePoll: this });
    }
    async getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
    }
    async getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
    }
    static getFormatter() {
        if (defaultFormatter == null) {
            defaultFormatter = new Formatter();
            const number = defaultFormatter.number.bind(defaultFormatter);
            const boolean = defaultFormatter.boolean.bind(defaultFormatter);
            const hash = defaultFormatter.hash.bind(defaultFormatter);
            const address = defaultFormatter.address.bind(defaultFormatter);
            defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.l2Tol1Log = {
                blockNumber: number,
                blockHash: hash,
                l1BatchNumber: Formatter.allowNull(number),
                transactionIndex: number,
                shardId: number,
                isService: boolean,
                sender: address,
                key: hash,
                value: hash,
                transactionHash: hash,
                logIndex: number
            };
            defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);
            defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf((value) => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));
            defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);
            defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);
            defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);
            defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);
        }
        return defaultFormatter;
    }
    async getBalance(address, blockTag, tokenAddress) {
        const tag = this.formatter.blockTag(blockTag);
        if (tokenAddress == null || (0, utils_1$p.isETH)(tokenAddress)) {
            // requesting ETH balance
            return await super.getBalance(address, tag);
        }
        else {
            try {
                let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);
                return await token.balanceOf(address, { blockTag: tag });
            }
            catch {
                return ethers_1$m.BigNumber.from(0);
            }
        }
    }
    async l2TokenAddress(token) {
        if (token == utils_1$p.ETH_ADDRESS) {
            return utils_1$p.ETH_ADDRESS;
        }
        else {
            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
            return await erc20Bridge.l2TokenAddress(token);
        }
    }
    async l1TokenAddress(token) {
        if (token == utils_1$p.ETH_ADDRESS) {
            return utils_1$p.ETH_ADDRESS;
        }
        else {
            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
            return await erc20Bridge.l1TokenAddress(token);
        }
    }
    // This function is used when formatting requests for
    // eth_call and eth_estimateGas. We override it here
    // because we have extra stuff to serialize (customData).
    // This function is for internal use only.
    static hexlifyTransaction(transaction, allowExtra) {
        var _a;
        const result = ethers_1$m.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {
            ...allowExtra,
            customData: true,
            from: true
        });
        if (transaction.customData == null) {
            return result;
        }
        result.eip712Meta = {
            gasPerPubdata: ethers_1$m.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)
        };
        transaction.type = utils_1$p.EIP712_TX_TYPE;
        if (transaction.customData.factoryDeps) {
            // @ts-ignore
            result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep) => 
            // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.
            //  We should change deserialization there.
            Array.from(ethers_1$m.utils.arrayify(dep)));
        }
        if (transaction.customData.paymasterParams) {
            // @ts-ignore
            result.eip712Meta.paymasterParams = {
                paymaster: ethers_1$m.utils.hexlify(transaction.customData.paymasterParams.paymaster),
                paymasterInput: Array.from(ethers_1$m.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))
            };
        }
        return result;
    }
    async estimateGas(transaction) {
        await this.getNetwork();
        const params = await ethers_1$m.utils.resolveProperties({
            transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
            // @ts-ignore
            params.transaction.customData = transaction.customData;
        }
        const result = await this.perform('estimateGas', params);
        try {
            return ethers_1$m.BigNumber.from(result);
        }
        catch (error) {
            throw new Error(`bad result from backend (estimateGas): ${result}`);
        }
    }
    async estimateGasL1(transaction) {
        await this.getNetwork();
        const params = await ethers_1$m.utils.resolveProperties({
            transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
            // @ts-ignore
            params.transaction.customData = transaction.customData;
        }
        const result = await this.send('zks_estimateGasL1ToL2', [
            Provider.hexlifyTransaction(params.transaction, { from: true })
        ]);
        try {
            return ethers_1$m.BigNumber.from(result);
        }
        catch (error) {
            throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);
        }
    }
    async getGasPrice(token) {
        const params = token ? [token] : [];
        const price = await this.send('eth_gasPrice', params);
        return ethers_1$m.BigNumber.from(price);
    }
    constructor(url, network) {
        super(url, network);
        this.pollingInterval = 500;
        const blockTag = this.formatter.blockTag.bind(this.formatter);
        this.formatter.blockTag = (tag) => {
            if (tag == 'committed' || tag == 'finalized') {
                return tag;
            }
            return blockTag(tag);
        };
        this.contractAddresses = {};
        this.formatter.transaction = utils_1$p.parseTransaction;
    }
    async getMessageProof(blockNumber, sender, messageHash, logIndex) {
        return await this.send('zks_getL2ToL1MsgProof', [
            ethers_1$m.BigNumber.from(blockNumber).toNumber(),
            sender,
            ethers_1$m.ethers.utils.hexlify(messageHash),
            logIndex
        ]);
    }
    async getLogProof(txHash, index) {
        return await this.send('zks_getL2ToL1LogProof', [ethers_1$m.ethers.utils.hexlify(txHash), index]);
    }
    async getL1BatchBlockRange(l1BatchNumber) {
        const range = await this.send('zks_getL1BatchBlockRange', [l1BatchNumber]);
        if (range == null) {
            return null;
        }
        return [parseInt(range[0], 16), parseInt(range[1], 16)];
    }
    async getMainContractAddress() {
        if (!this.contractAddresses.mainContract) {
            this.contractAddresses.mainContract = await this.send('zks_getMainContract', []);
        }
        return this.contractAddresses.mainContract;
    }
    async getTestnetPaymasterAddress() {
        // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed
        // on the fly by the server and should not be relied to be constant
        return await this.send('zks_getTestnetPaymaster', []);
    }
    async getDefaultBridgeAddresses() {
        if (!this.contractAddresses.erc20BridgeL1) {
            let addresses = await this.send('zks_getBridgeContracts', []);
            this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;
            this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;
        }
        return {
            erc20L1: this.contractAddresses.erc20BridgeL1,
            erc20L2: this.contractAddresses.erc20BridgeL2
        };
    }
    async getConfirmedTokens(start = 0, limit = 255) {
        const tokens = await this.send('zks_getConfirmedTokens', [start, limit]);
        return tokens.map((token) => ({ address: token.l2Address, ...token }));
    }
    async getTokenPrice(token) {
        return await this.send('zks_getTokenPrice', [token]);
    }
    async getAllAccountBalances(address) {
        let balances = await this.send('zks_getAllAccountBalances', [address]);
        for (let token in balances) {
            balances[token] = ethers_1$m.BigNumber.from(balances[token]);
        }
        return balances;
    }
    async l1ChainId() {
        const res = await this.send('zks_L1ChainId', []);
        return ethers_1$m.BigNumber.from(res).toNumber();
    }
    async getL1BatchNumber() {
        const number = await this.send('zks_L1BatchNumber', []);
        return ethers_1$m.BigNumber.from(number).toNumber();
    }
    async getL1BatchDetails(number) {
        return await this.send('zks_getL1BatchDetails', [number]);
    }
    async getBlockDetails(number) {
        return await this.send('zks_getBlockDetails', [number]);
    }
    async getTransactionDetails(txHash) {
        return await this.send('zks_getTransactionDetails', [txHash]);
    }
    async getWithdrawTx(transaction) {
        var _a, _b, _c;
        var _d;
        const { ...tx } = transaction;
        if (tx.to == null && tx.from == null) {
            throw new Error('withdrawal target address is undefined');
        }
        (_a = tx.to) !== null && _a !== void 0 ? _a : (tx.to = tx.from);
        (_b = tx.overrides) !== null && _b !== void 0 ? _b : (tx.overrides = {});
        (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : (_d.from = tx.from);
        if ((0, utils_1$p.isETH)(tx.token)) {
            if (!tx.overrides.value) {
                tx.overrides.value = tx.amount;
            }
            const passedValue = ethers_1$m.BigNumber.from(tx.overrides.value);
            if (!passedValue.eq(tx.amount)) {
                // To avoid users shooting themselves into the foot, we will always use the amount to withdraw
                // as the value
                throw new Error('The tx.value is not equal to the value withdrawn');
            }
            const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1$p.L2_ETH_TOKEN_ADDRESS, this);
            return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);
        }
        if (tx.bridgeAddress == null) {
            const bridges = await this.getDefaultBridgeAddresses();
            tx.bridgeAddress = bridges.erc20L2;
        }
        const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);
        return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);
    }
    async estimateGasWithdraw(transaction) {
        const withdrawTx = await this.getWithdrawTx(transaction);
        return await this.estimateGas(withdrawTx);
    }
    async getTransferTx(transaction) {
        var _a, _b;
        var _c;
        const { ...tx } = transaction;
        (_a = tx.overrides) !== null && _a !== void 0 ? _a : (tx.overrides = {});
        (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : (_c.from = tx.from);
        if (tx.token == null || tx.token == utils_1$p.ETH_ADDRESS) {
            return {
                ...(await ethers_1$m.ethers.utils.resolveProperties(tx.overrides)),
                to: tx.to,
                value: tx.amount
            };
        }
        else {
            const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);
            return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);
        }
    }
    async estimateGasTransfer(transaction) {
        const transferTx = await this.getTransferTx(transaction);
        return await this.estimateGas(transferTx);
    }
    static getDefaultProvider() {
        // TODO (SMA-1606): Add different urls for different networks.
        return new Provider(process.env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');
    }
    async newFilter(filter) {
        filter = await filter;
        const id = await this.send('eth_newFilter', [this._prepareFilter(filter)]);
        return ethers_1$m.BigNumber.from(id);
    }
    async newBlockFilter() {
        const id = await this.send('eth_newBlockFilter', []);
        return ethers_1$m.BigNumber.from(id);
    }
    async newPendingTransactionsFilter() {
        const id = await this.send('eth_newPendingTransactionFilter', []);
        return ethers_1$m.BigNumber.from(id);
    }
    async getFilterChanges(idx) {
        const logs = await this.send('eth_getFilterChanges', [idx.toHexString()]);
        return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);
    }
    async getLogs(filter = {}) {
        filter = await filter;
        const logs = await this.send('eth_getLogs', [this._prepareFilter(filter)]);
        return this._parseLogs(logs);
    }
    _parseLogs(logs) {
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    }
    _prepareFilter(filter) {
        return {
            ...filter,
            fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),
            toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)
        };
    }
    _wrapTransaction(tx, hash) {
        const response = super._wrapTransaction(tx, hash);
        response.waitFinalize = async () => {
            const receipt = await response.wait();
            while (true) {
                const block = await this.getBlock('finalized');
                if (receipt.blockNumber <= block.number) {
                    return await this.getTransactionReceipt(receipt.transactionHash);
                }
                else {
                    await (0, utils_1$p.sleep)(this.pollingInterval);
                }
            }
        };
        return response;
    }
    // This is inefficient. Status should probably be indicated in the transaction receipt.
    async getTransactionStatus(txHash) {
        const tx = await this.getTransaction(txHash);
        if (tx == null) {
            return types_1$3.TransactionStatus.NotFound;
        }
        if (tx.blockNumber == null) {
            return types_1$3.TransactionStatus.Processing;
        }
        const verifiedBlock = await this.getBlock('finalized');
        if (tx.blockNumber <= verifiedBlock.number) {
            return types_1$3.TransactionStatus.Finalized;
        }
        return types_1$3.TransactionStatus.Committed;
    }
    async getTransaction(hash) {
        hash = await hash;
        const tx = await super.getTransaction(hash);
        return tx ? this._wrapTransaction(tx, hash) : null;
    }
    async sendTransaction(transaction) {
        return (await super.sendTransaction(transaction));
    }
    async getL2TransactionFromPriorityOp(l1TxResponse) {
        const receipt = await l1TxResponse.wait();
        const l2Hash = (0, utils_1$p.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
        let status = null;
        do {
            status = await this.getTransactionStatus(l2Hash);
            await (0, utils_1$p.sleep)(this.pollingInterval);
        } while (status == types_1$3.TransactionStatus.NotFound);
        return await this.getTransaction(l2Hash);
    }
    async getPriorityOpResponse(l1TxResponse) {
        const l2Response = { ...l1TxResponse };
        l2Response.waitL1Commit = l2Response.wait;
        l2Response.wait = async () => {
            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
            return await l2Tx.wait();
        };
        l2Response.waitFinalize = async () => {
            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
            return await l2Tx.waitFinalize();
        };
        return l2Response;
    }
    async getContractAccountInfo(address) {
        const deployerContract = new ethers_1$m.Contract(utils_1$p.CONTRACT_DEPLOYER_ADDRESS, utils_1$p.CONTRACT_DEPLOYER, this);
        const data = await deployerContract.getAccountInfo(address);
        return {
            supportedAAVersion: data.supportedAAVersion,
            nonceOrdering: data.nonceOrdering
        };
    }
    // TODO (EVM-3): support refundRecipient for fee estimation
    async estimateL1ToL2Execute(transaction) {
        var _a, _b;
        (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : (transaction.gasPerPubdataByte = utils_1$p.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
        // If the `from` address is not provided, we use a random address, because
        // due to storage slot aggregation, the gas estimation will depend on the address
        // and so estimation for the zero address may be smaller than for the sender.
        (_b = transaction.caller) !== null && _b !== void 0 ? _b : (transaction.caller = ethers_1$m.ethers.Wallet.createRandom().address);
        const customData = {
            gasPerPubdataByte: transaction.gasPerPubdataByte
        };
        if (transaction.factoryDeps) {
            Object.assign(customData, { factoryDeps: transaction.factoryDeps });
        }
        const fee = await this.estimateGasL1({
            from: transaction.caller,
            data: transaction.calldata,
            to: transaction.contractAddress,
            value: transaction.l2Value,
            customData
        });
        return fee;
    }
}
provider$1.Provider = Provider;
class Web3Provider extends Provider {
    constructor(provider, network) {
        if (provider == null) {
            throw new Error('missing provider');
        }
        if (!provider.request) {
            throw new Error('provider must implement eip-1193');
        }
        let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');
        super(path, network);
        this.provider = provider;
    }
    async send(method, params) {
        params !== null && params !== void 0 ? params : (params = []);
        // Metamask complains about eth_sign (and on some versions hangs)
        if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {
            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign
            method = 'personal_sign';
            params = [params[1], params[0]];
        }
        return await this.provider.request({ method, params });
    }
    getSigner(addressOrIndex) {
        return signer_1.Signer.from(super.getSigner(addressOrIndex));
    }
    async estimateGas(transaction) {
        const gas = await super.estimateGas(transaction);
        const metamaskMinimum = ethers_1$m.BigNumber.from(21000);
        const isEIP712 = transaction.customData != null || transaction.type == utils_1$p.EIP712_TX_TYPE;
        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;
    }
}
provider$1.Web3Provider = Web3Provider;

var contract = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ContractFactory = exports.Contract = void 0;
	const ethers_1 = require$$0$d;
	const utils_1 = requireUtils$2();
	const types_1 = types$3;
	var ethers_2 = require$$0$d;
	Object.defineProperty(exports, "Contract", { enumerable: true, get: function () { return ethers_2.Contract; } });
	class ContractFactory extends ethers_1.ethers.ContractFactory {
	    constructor(abi, bytecode, signer, deploymentType) {
	        super(abi, bytecode, signer);
	        this.deploymentType = deploymentType || 'create';
	    }
	    encodeCalldata(salt, bytecodeHash, constructorCalldata) {
	        if (this.deploymentType == 'create') {
	            return utils_1.CONTRACT_DEPLOYER.encodeFunctionData('create', [salt, bytecodeHash, constructorCalldata]);
	        }
	        else if (this.deploymentType == 'createAccount') {
	            return utils_1.CONTRACT_DEPLOYER.encodeFunctionData('createAccount', [
	                salt,
	                bytecodeHash,
	                constructorCalldata,
	                types_1.AccountAbstractionVersion.Version1
	            ]);
	        }
	        else {
	            throw new Error(`Unsupported deployment type ${this.deploymentType}`);
	        }
	    }
	    getDeployTransaction(...args) {
	        var _a, _b, _c;
	        var _d, _e;
	        // TODO (SMA-1585): Users should be able to provide the salt.
	        let salt = '0x0000000000000000000000000000000000000000000000000000000000000000';
	        // The overrides will be popped out in this call:
	        const txRequest = super.getDeployTransaction(...args);
	        // Removing overrides
	        if (this.interface.deploy.inputs.length + 1 == args.length) {
	            args.pop();
	        }
	        // Salt argument is not used, so we provide a placeholder value.
	        const bytecodeHash = (0, utils_1.hashBytecode)(this.bytecode);
	        const constructorCalldata = ethers_1.utils.arrayify(this.interface.encodeDeploy(args));
	        const deployCalldata = this.encodeCalldata(salt, bytecodeHash, constructorCalldata);
	        txRequest.type = utils_1.EIP712_TX_TYPE;
	        txRequest.to = utils_1.CONTRACT_DEPLOYER_ADDRESS;
	        txRequest.data = deployCalldata;
	        (_a = txRequest.customData) !== null && _a !== void 0 ? _a : (txRequest.customData = {});
	        (_b = (_d = txRequest.customData).factoryDeps) !== null && _b !== void 0 ? _b : (_d.factoryDeps = []);
	        (_c = (_e = txRequest.customData).gasPerPubdata) !== null && _c !== void 0 ? _c : (_e.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);
	        // The number of factory deps is relatively low, so it is efficient enough.
	        if (!txRequest.customData.factoryDeps.includes(this.bytecode)) {
	            txRequest.customData.factoryDeps.push(this.bytecode);
	        }
	        return txRequest;
	    }
	    async deploy(...args) {
	        const contract = await super.deploy(...args);
	        const deployTxReceipt = await contract.deployTransaction.wait();
	        const deployedAddresses = (0, utils_1.getDeployedContracts)(deployTxReceipt).map((info) => info.deployedAddress);
	        const contractWithCorrectAddress = new ethers_1.ethers.Contract(deployedAddresses[deployedAddresses.length - 1], contract.interface, contract.signer);
	        ethers_1.utils.defineReadOnly(contractWithCorrectAddress, 'deployTransaction', contract.deployTransaction);
	        return contractWithCorrectAddress;
	    }
	}
	exports.ContractFactory = ContractFactory; 
} (contract));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Contract = exports.ContractFactory = exports.Provider = exports.Web3Provider = exports.Wallet = exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.types = exports.utils = void 0;
	exports.utils = __importStar(requireUtils$2());
	exports.types = __importStar(types$3);
	var signer_1 = requireSigner();
	Object.defineProperty(exports, "EIP712Signer", { enumerable: true, get: function () { return signer_1.EIP712Signer; } });
	Object.defineProperty(exports, "Signer", { enumerable: true, get: function () { return signer_1.Signer; } });
	Object.defineProperty(exports, "L1Signer", { enumerable: true, get: function () { return signer_1.L1Signer; } });
	var wallet_1 = wallet;
	Object.defineProperty(exports, "Wallet", { enumerable: true, get: function () { return wallet_1.Wallet; } });
	var provider_1 = provider$1;
	Object.defineProperty(exports, "Web3Provider", { enumerable: true, get: function () { return provider_1.Web3Provider; } });
	Object.defineProperty(exports, "Provider", { enumerable: true, get: function () { return provider_1.Provider; } });
	var contract_1 = contract;
	Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function () { return contract_1.ContractFactory; } });
	Object.defineProperty(exports, "Contract", { enumerable: true, get: function () { return contract_1.Contract; } }); 
} (src$3));

var safeDeploymentContracts = {};

Object.defineProperty(safeDeploymentContracts, "__esModule", { value: true });
safeDeploymentContracts.getSimulateTxAccessorContract = safeDeploymentContracts.getCreateCallContract = safeDeploymentContracts.getSignMessageLibContract = safeDeploymentContracts.getMultiSendCallOnlyContract = safeDeploymentContracts.getMultiSendContract = safeDeploymentContracts.getCompatibilityFallbackHandlerContract = safeDeploymentContracts.getProxyFactoryContract = safeDeploymentContracts.getSafeContract = safeDeploymentContracts.getSimulateTxAccessorContractDeployment = safeDeploymentContracts.getCreateCallContractDeployment = safeDeploymentContracts.getSignMessageLibContractDeployment = safeDeploymentContracts.getSafeProxyFactoryContractDeployment = safeDeploymentContracts.getMultiSendContractDeployment = safeDeploymentContracts.getMultiSendCallOnlyContractDeployment = safeDeploymentContracts.getCompatibilityFallbackHandlerContractDeployment = safeDeploymentContracts.getSafeContractDeployment = void 0;
const safe_deployments_1 = dist$5;
const config_1$4 = config$1;
function getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy = false) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].safeMasterCopyVersion;
    const filters = { version, network: chainId.toString(), released: true };
    if (config_1$4.safeDeploymentsL1ChainIds.includes(chainId) || isL1SafeMasterCopy) {
        return (0, safe_deployments_1.getSafeSingletonDeployment)(filters);
    }
    return (0, safe_deployments_1.getSafeL2SingletonDeployment)(filters);
}
safeDeploymentContracts.getSafeContractDeployment = getSafeContractDeployment;
function getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].compatibilityFallbackHandler;
    return (0, safe_deployments_1.getCompatibilityFallbackHandlerDeployment)({
        version,
        network: chainId.toString(),
        released: true
    });
}
safeDeploymentContracts.getCompatibilityFallbackHandlerContractDeployment = getCompatibilityFallbackHandlerContractDeployment;
function getMultiSendCallOnlyContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].multiSendCallOnlyVersion;
    return (0, safe_deployments_1.getMultiSendCallOnlyDeployment)({ version, network: chainId.toString(), released: true });
}
safeDeploymentContracts.getMultiSendCallOnlyContractDeployment = getMultiSendCallOnlyContractDeployment;
function getMultiSendContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].multiSendVersion;
    return (0, safe_deployments_1.getMultiSendDeployment)({ version, network: chainId.toString(), released: true });
}
safeDeploymentContracts.getMultiSendContractDeployment = getMultiSendContractDeployment;
function getSafeProxyFactoryContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].safeProxyFactoryVersion;
    return (0, safe_deployments_1.getProxyFactoryDeployment)({ version, network: chainId.toString(), released: true });
}
safeDeploymentContracts.getSafeProxyFactoryContractDeployment = getSafeProxyFactoryContractDeployment;
function getSignMessageLibContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].signMessageLibVersion;
    return (0, safe_deployments_1.getSignMessageLibDeployment)({ version, network: chainId.toString(), released: true });
}
safeDeploymentContracts.getSignMessageLibContractDeployment = getSignMessageLibContractDeployment;
function getCreateCallContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].createCallVersion;
    return (0, safe_deployments_1.getCreateCallDeployment)({ version, network: chainId.toString(), released: true });
}
safeDeploymentContracts.getCreateCallContractDeployment = getCreateCallContractDeployment;
function getSimulateTxAccessorContractDeployment(safeVersion, chainId) {
    const version = config_1$4.safeDeploymentsVersions[safeVersion].createCallVersion;
    return (0, safe_deployments_1.getSimulateTxAccessorDeployment)({ version, network: chainId.toString(), released: true });
}
safeDeploymentContracts.getSimulateTxAccessorContractDeployment = getSimulateTxAccessorContractDeployment;
async function getSafeContract({ ethAdapter, safeVersion, customSafeAddress, isL1SafeMasterCopy, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const singletonDeployment = getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy);
    const safeContract = await ethAdapter.getSafeContract({
        safeVersion,
        singletonDeployment,
        customContractAddress: customSafeAddress ?? customContracts?.safeMasterCopyAddress,
        customContractAbi: customContracts?.safeMasterCopyAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(safeContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('SafeProxy contract is not deployed on the current network');
    }
    return safeContract;
}
safeDeploymentContracts.getSafeContract = getSafeContract;
async function getProxyFactoryContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const proxyFactoryDeployment = getSafeProxyFactoryContractDeployment(safeVersion, chainId);
    const safeProxyFactoryContract = await ethAdapter.getSafeProxyFactoryContract({
        safeVersion,
        singletonDeployment: proxyFactoryDeployment,
        customContractAddress: customContracts?.safeProxyFactoryAddress,
        customContractAbi: customContracts?.safeProxyFactoryAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(safeProxyFactoryContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('SafeProxyFactory contract is not deployed on the current network');
    }
    return safeProxyFactoryContract;
}
safeDeploymentContracts.getProxyFactoryContract = getProxyFactoryContract;
async function getCompatibilityFallbackHandlerContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const fallbackHandlerDeployment = getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId);
    const fallbackHandlerContract = await ethAdapter.getCompatibilityFallbackHandlerContract({
        safeVersion,
        singletonDeployment: fallbackHandlerDeployment,
        customContractAddress: customContracts?.fallbackHandlerAddress,
        customContractAbi: customContracts?.fallbackHandlerAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(fallbackHandlerContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('CompatibilityFallbackHandler contract is not deployed on the current network');
    }
    return fallbackHandlerContract;
}
safeDeploymentContracts.getCompatibilityFallbackHandlerContract = getCompatibilityFallbackHandlerContract;
async function getMultiSendContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const multiSendDeployment = getMultiSendContractDeployment(safeVersion, chainId);
    const multiSendContract = await ethAdapter.getMultiSendContract({
        safeVersion,
        singletonDeployment: multiSendDeployment,
        customContractAddress: customContracts?.multiSendAddress,
        customContractAbi: customContracts?.multiSendAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(multiSendContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('MultiSend contract is not deployed on the current network');
    }
    return multiSendContract;
}
safeDeploymentContracts.getMultiSendContract = getMultiSendContract;
async function getMultiSendCallOnlyContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const multiSendCallOnlyDeployment = getMultiSendCallOnlyContractDeployment(safeVersion, chainId);
    const multiSendCallOnlyContract = await ethAdapter.getMultiSendCallOnlyContract({
        safeVersion,
        singletonDeployment: multiSendCallOnlyDeployment,
        customContractAddress: customContracts?.multiSendCallOnlyAddress,
        customContractAbi: customContracts?.multiSendCallOnlyAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(multiSendCallOnlyContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('MultiSendCallOnly contract is not deployed on the current network');
    }
    return multiSendCallOnlyContract;
}
safeDeploymentContracts.getMultiSendCallOnlyContract = getMultiSendCallOnlyContract;
async function getSignMessageLibContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const signMessageLibDeployment = getSignMessageLibContractDeployment(safeVersion, chainId);
    const signMessageLibContract = await ethAdapter.getSignMessageLibContract({
        safeVersion,
        singletonDeployment: signMessageLibDeployment,
        customContractAddress: customContracts?.signMessageLibAddress,
        customContractAbi: customContracts?.signMessageLibAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(signMessageLibContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('SignMessageLib contract is not deployed on the current network');
    }
    return signMessageLibContract;
}
safeDeploymentContracts.getSignMessageLibContract = getSignMessageLibContract;
async function getCreateCallContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const createCallDeployment = getCreateCallContractDeployment(safeVersion, chainId);
    const createCallContract = await ethAdapter.getCreateCallContract({
        safeVersion,
        singletonDeployment: createCallDeployment,
        customContractAddress: customContracts?.createCallAddress,
        customContractAbi: customContracts?.createCallAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(createCallContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('CreateCall contract is not deployed on the current network');
    }
    return createCallContract;
}
safeDeploymentContracts.getCreateCallContract = getCreateCallContract;
async function getSimulateTxAccessorContract({ ethAdapter, safeVersion, customContracts }) {
    const chainId = await ethAdapter.getChainId();
    const simulateTxAccessorDeployment = getSimulateTxAccessorContractDeployment(safeVersion, chainId);
    const simulateTxAccessorContract = await ethAdapter.getSimulateTxAccessorContract({
        safeVersion,
        singletonDeployment: simulateTxAccessorDeployment,
        customContractAddress: customContracts?.simulateTxAccessorAddress,
        customContractAbi: customContracts?.simulateTxAccessorAbi
    });
    const isContractDeployed = await ethAdapter.isContractDeployed(simulateTxAccessorContract.getAddress());
    if (!isContractDeployed) {
        throw new Error('SimulateTxAccessor contract is not deployed on the current network');
    }
    return simulateTxAccessorContract;
}
safeDeploymentContracts.getSimulateTxAccessorContract = getSimulateTxAccessorContract;

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSafeDeploymentConfig = exports.validateSafeAccountConfig = exports.predictSafeAddress = exports.encodeSetupCallData = exports.encodeCreateProxyWithNonce = exports.PREDETERMINED_SALT_NONCE = void 0;
	const address_1 = require$$0$a;
	const bignumber_1 = require$$0$7;
	const config_1 = config$1;
	const constants_1 = constants$4;
	const memoized_1 = memoized;
	const ethereumjs_util_1 = dist$4;
	const satisfies_1 = __importDefault(satisfies_1$2);
	const zksync_web3_1 = src$3;
	const safeDeploymentContracts_1 = safeDeploymentContracts;
	// keccak256(toUtf8Bytes('Safe Account Abstraction'))
	exports.PREDETERMINED_SALT_NONCE = '0xb1073742015cbcf5a3a4d9d1ae33ecf619439710b89475f92e2abd2117e90f90';
	const ZKSYNC_MAINNET = 324;
	const ZKSYNC_TESTNET = 280;
	// For bundle size efficiency we store SafeProxy.sol/GnosisSafeProxy.sol zksync bytecode hash in hex.
	// To get the values below we need to:
	// 1. Compile Safe smart contracts for zksync
	// 2. Get `deployedBytecode` from SafeProxy.json/GnosisSafeProxy.json
	// 3. Use zksync-web3 SDK to get the bytecode hash
	//    const bytecodeHash = zkSyncUtils.hashBytecode(${deployedBytecode})
	// 4. Use ethers to convert the array into hex
	//    const deployedBytecodeHash = ethers.utils.hexlify(bytecodeHash)
	const ZKSYNC_SAFE_PROXY_DEPLOYED_BYTECODE = {
	    '1.3.0': {
	        deployedBytecodeHash: '0x0100004124426fb9ebb25e27d670c068e52f9ba631bd383279a188be47e3f86d'
	    }
	};
	function encodeCreateProxyWithNonce(safeProxyFactoryContract, safeSingletonAddress, initializer) {
	    return safeProxyFactoryContract.encode('createProxyWithNonce', [
	        safeSingletonAddress,
	        initializer,
	        exports.PREDETERMINED_SALT_NONCE
	    ]);
	}
	exports.encodeCreateProxyWithNonce = encodeCreateProxyWithNonce;
	const memoizedGetCompatibilityFallbackHandlerContract = (0, memoized_1.createMemoizedFunction)(safeDeploymentContracts_1.getCompatibilityFallbackHandlerContract);
	async function encodeSetupCallData({ ethAdapter, safeAccountConfig, safeContract, customContracts, customSafeVersion }) {
	    const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = safeAccountConfig;
	    const safeVersion = customSafeVersion || (await safeContract.getVersion());
	    if ((0, satisfies_1.default)(safeVersion, '<=1.0.0')) {
	        return safeContract.encode('setup', [
	            owners,
	            threshold,
	            to,
	            data,
	            paymentToken,
	            payment,
	            paymentReceiver
	        ]);
	    }
	    let fallbackHandlerAddress = fallbackHandler;
	    const isValidAddress = fallbackHandlerAddress !== undefined && (0, address_1.isAddress)(fallbackHandlerAddress);
	    if (!isValidAddress) {
	        const fallbackHandlerContract = await memoizedGetCompatibilityFallbackHandlerContract({
	            ethAdapter,
	            safeVersion,
	            customContracts
	        });
	        fallbackHandlerAddress = fallbackHandlerContract.getAddress();
	    }
	    return safeContract.encode('setup', [
	        owners,
	        threshold,
	        to,
	        data,
	        fallbackHandlerAddress,
	        paymentToken,
	        payment,
	        paymentReceiver
	    ]);
	}
	exports.encodeSetupCallData = encodeSetupCallData;
	const memoizedGetProxyFactoryContract = (0, memoized_1.createMemoizedFunction)(safeDeploymentContracts_1.getProxyFactoryContract);
	const memoizedGetSafeContract = (0, memoized_1.createMemoizedFunction)(safeDeploymentContracts_1.getSafeContract);
	const memoizedGetProxyCreationCode = (0, memoized_1.createMemoizedFunction)(async ({ ethAdapter, safeVersion, customContracts }) => {
	    const safeProxyFactoryContract = await memoizedGetProxyFactoryContract({
	        ethAdapter,
	        safeVersion,
	        customContracts
	    });
	    return safeProxyFactoryContract.proxyCreationCode();
	});
	async function predictSafeAddress({ ethAdapter, safeAccountConfig, safeDeploymentConfig = {}, isL1SafeMasterCopy = false, customContracts }) {
	    (0, exports.validateSafeAccountConfig)(safeAccountConfig);
	    (0, exports.validateSafeDeploymentConfig)(safeDeploymentConfig);
	    const { safeVersion = config_1.DEFAULT_SAFE_VERSION, saltNonce = exports.PREDETERMINED_SALT_NONCE } = safeDeploymentConfig;
	    const safeProxyFactoryContract = await memoizedGetProxyFactoryContract({
	        ethAdapter,
	        safeVersion,
	        customContracts
	    });
	    const proxyCreationCode = await memoizedGetProxyCreationCode({
	        ethAdapter,
	        safeVersion,
	        customContracts
	    });
	    const safeContract = await memoizedGetSafeContract({
	        ethAdapter,
	        safeVersion,
	        isL1SafeMasterCopy,
	        customContracts
	    });
	    const initializer = await encodeSetupCallData({
	        ethAdapter,
	        safeAccountConfig,
	        safeContract,
	        customContracts,
	        customSafeVersion: safeVersion // it is more efficient if we provide the safeVersion manually
	    });
	    const encodedNonce = (0, ethereumjs_util_1.toBuffer)(ethAdapter.encodeParameters(['uint256'], [saltNonce])).toString('hex');
	    const salt = (0, ethereumjs_util_1.keccak256)((0, ethereumjs_util_1.toBuffer)('0x' + (0, ethereumjs_util_1.keccak256)((0, ethereumjs_util_1.toBuffer)(initializer)).toString('hex') + encodedNonce));
	    const input = ethAdapter.encodeParameters(['address'], [safeContract.getAddress()]);
	    const chainId = await ethAdapter.getChainId();
	    // zkSync Era counterfactual deployment is calculated differently
	    // https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#create-create2
	    if ([ZKSYNC_MAINNET, ZKSYNC_TESTNET].includes(chainId)) {
	        const bytecodeHash = ZKSYNC_SAFE_PROXY_DEPLOYED_BYTECODE[safeVersion].deployedBytecodeHash;
	        return zksync_web3_1.utils.create2Address(safeProxyFactoryContract.getAddress(), bytecodeHash, salt, input);
	    }
	    const constructorData = (0, ethereumjs_util_1.toBuffer)(input).toString('hex');
	    const initCode = proxyCreationCode + constructorData;
	    const proxyAddress = '0x' +
	        (0, ethereumjs_util_1.generateAddress2)((0, ethereumjs_util_1.toBuffer)(safeProxyFactoryContract.getAddress()), (0, ethereumjs_util_1.toBuffer)(salt), (0, ethereumjs_util_1.toBuffer)(initCode)).toString('hex');
	    return ethAdapter.getChecksummedAddress(proxyAddress);
	}
	exports.predictSafeAddress = predictSafeAddress;
	const validateSafeAccountConfig = ({ owners, threshold }) => {
	    if (owners.length <= 0)
	        throw new Error('Owner list must have at least one owner');
	    if (threshold <= 0)
	        throw new Error('Threshold must be greater than or equal to 1');
	    if (threshold > owners.length)
	        throw new Error('Threshold must be lower than or equal to owners length');
	};
	exports.validateSafeAccountConfig = validateSafeAccountConfig;
	const validateSafeDeploymentConfig = ({ saltNonce }) => {
	    if (saltNonce && bignumber_1.BigNumber.from(saltNonce).lt(0))
	        throw new Error('saltNonce must be greater than or equal to 0');
	};
	exports.validateSafeDeploymentConfig = validateSafeDeploymentConfig;
	
} (utils$g));

var contractManager = {};

var types$2 = {};

Object.defineProperty(types$2, "__esModule", { value: true });
types$2.isSafeConfigWithPredictedSafe = void 0;
function isSafeConfigWithPredictedSafe(config) {
    return config.predictedSafe !== undefined;
}
types$2.isSafeConfigWithPredictedSafe = isSafeConfigWithPredictedSafe;

var __classPrivateFieldSet$8 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$8 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ContractManager_contractNetworks, _ContractManager_isL1SafeMasterCopy, _ContractManager_safeContract, _ContractManager_multiSendContract, _ContractManager_multiSendCallOnlyContract;
Object.defineProperty(contractManager, "__esModule", { value: true });
const config_1$3 = config$1;
const safeDeploymentContracts_1$3 = safeDeploymentContracts;
const types_1$2 = types$2;
class ContractManager {
    constructor() {
        _ContractManager_contractNetworks.set(this, void 0);
        _ContractManager_isL1SafeMasterCopy.set(this, void 0);
        _ContractManager_safeContract.set(this, void 0);
        _ContractManager_multiSendContract.set(this, void 0);
        _ContractManager_multiSendCallOnlyContract.set(this, void 0);
    }
    static async create(config) {
        const contractManager = new ContractManager();
        await contractManager.init(config);
        return contractManager;
    }
    async init(config) {
        const { ethAdapter, isL1SafeMasterCopy, contractNetworks, predictedSafe, safeAddress } = config;
        const chainId = await ethAdapter.getChainId();
        const customContracts = contractNetworks?.[chainId];
        __classPrivateFieldSet$8(this, _ContractManager_contractNetworks, contractNetworks, "f");
        __classPrivateFieldSet$8(this, _ContractManager_isL1SafeMasterCopy, isL1SafeMasterCopy, "f");
        let safeVersion;
        if ((0, types_1$2.isSafeConfigWithPredictedSafe)(config)) {
            safeVersion = predictedSafe?.safeDeploymentConfig?.safeVersion ?? config_1$3.DEFAULT_SAFE_VERSION;
        }
        else {
            // We use the default version of the Safe contract to get the correct version of this Safe
            const defaultSafeContractInstance = await (0, safeDeploymentContracts_1$3.getSafeContract)({
                ethAdapter,
                safeVersion: config_1$3.DEFAULT_SAFE_VERSION,
                isL1SafeMasterCopy,
                customSafeAddress: safeAddress,
                customContracts
            });
            // We check the correct version of the Safe from the blockchain
            safeVersion = await defaultSafeContractInstance.getVersion();
            // We get the correct Safe Contract if the real Safe version is not the lastest
            const isTheDefaultSafeVersion = safeVersion === config_1$3.DEFAULT_SAFE_VERSION;
            __classPrivateFieldSet$8(this, _ContractManager_safeContract, isTheDefaultSafeVersion
                ? defaultSafeContractInstance
                : await (0, safeDeploymentContracts_1$3.getSafeContract)({
                    ethAdapter,
                    safeVersion,
                    isL1SafeMasterCopy,
                    customSafeAddress: safeAddress,
                    customContracts
                }), "f");
        }
        __classPrivateFieldSet$8(this, _ContractManager_multiSendContract, await (0, safeDeploymentContracts_1$3.getMultiSendContract)({
            ethAdapter,
            safeVersion,
            customContracts
        }), "f");
        __classPrivateFieldSet$8(this, _ContractManager_multiSendCallOnlyContract, await (0, safeDeploymentContracts_1$3.getMultiSendCallOnlyContract)({
            ethAdapter,
            safeVersion,
            customContracts
        }), "f");
    }
    get contractNetworks() {
        return __classPrivateFieldGet$8(this, _ContractManager_contractNetworks, "f");
    }
    get isL1SafeMasterCopy() {
        return __classPrivateFieldGet$8(this, _ContractManager_isL1SafeMasterCopy, "f");
    }
    get safeContract() {
        return __classPrivateFieldGet$8(this, _ContractManager_safeContract, "f");
    }
    get multiSendContract() {
        return __classPrivateFieldGet$8(this, _ContractManager_multiSendContract, "f");
    }
    get multiSendCallOnlyContract() {
        return __classPrivateFieldGet$8(this, _ContractManager_multiSendCallOnlyContract, "f");
    }
}
_ContractManager_contractNetworks = new WeakMap(), _ContractManager_isL1SafeMasterCopy = new WeakMap(), _ContractManager_safeContract = new WeakMap(), _ContractManager_multiSendContract = new WeakMap(), _ContractManager_multiSendCallOnlyContract = new WeakMap();
contractManager.default = ContractManager;

var fallbackHandlerManager = {};

var utils$c = {};

var address$1 = {};

Object.defineProperty(address$1, "__esModule", { value: true });
address$1.isRestrictedAddress = address$1.isZeroAddress = address$1.sameString = void 0;
const constants_1$h = constants$4;
function sameString$2(str1, str2) {
    return str1.toLowerCase() === str2.toLowerCase();
}
address$1.sameString = sameString$2;
function isZeroAddress(address) {
    return sameString$2(address, constants_1$h.ZERO_ADDRESS);
}
address$1.isZeroAddress = isZeroAddress;
function isSentinelAddress(address) {
    return sameString$2(address, constants_1$h.SENTINEL_ADDRESS);
}
function isRestrictedAddress(address) {
    return isZeroAddress(address) || isSentinelAddress(address);
}
address$1.isRestrictedAddress = isRestrictedAddress;

var eip3770 = {};

var bn$1 = {exports: {}};

bn$1.exports;

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    Buffer = commonjsRequire('buf' + 'fer').Buffer;
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	    }

	    if (base === 16) {
	      this._parseHex(number, start);
	    } else {
	      this._parseBase(number, base, start);
	    }

	    if (number[0] === '-') {
	      this.negative = 1;
	    }

	    this.strip();

	    if (endian !== 'le') return;

	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex (str, start, end) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r <<= 4;

	      // 'a' - 'f'
	      if (c >= 49 && c <= 54) {
	        r |= c - 49 + 0xa;

	      // 'A' - 'F'
	      } else if (c >= 17 && c <= 22) {
	        r |= c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r |= c & 0xf;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    // Scan 24-bit chunks and add them to the number
	    var off = 0;
	    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
	      w = parseHex(number, i, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	    if (i + 6 !== start) {
	      w = parseHex(number, start, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    }
	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      r.strip();
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal); 
} (bn$1));

var bnExports$1 = bn$1.exports;

var bn = {exports: {}};

bn.exports;

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    Buffer = commonjsRequire('buf' + 'fer').Buffer;
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	    }

	    if (base === 16) {
	      this._parseHex(number, start);
	    } else {
	      this._parseBase(number, base, start);
	    }

	    if (number[0] === '-') {
	      this.negative = 1;
	    }

	    this.strip();

	    if (endian !== 'le') return;

	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex (str, start, end) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r <<= 4;

	      // 'a' - 'f'
	      if (c >= 49 && c <= 54) {
	        r |= c - 49 + 0xa;

	      // 'A' - 'F'
	      } else if (c >= 17 && c <= 22) {
	        r |= c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r |= c & 0xf;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    // Scan 24-bit chunks and add them to the number
	    var off = 0;
	    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
	      w = parseHex(number, i, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	    if (i + 6 !== start) {
	      w = parseHex(number, start, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    }
	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      r.strip();
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal); 
} (bn));

var bnExports = bn.exports;

/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */

var src$2 = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
};

var isHexPrefixed$2 = src$2;

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
var src$1 = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed$2(str) ? str.slice(2) : str;
};

var BN$4 = bnExports;
var stripHexPrefix$3 = src$1;

/**
 * Returns a BN object, converts a number value to a BN
 * @param {String|Number|Object} `arg` input a string number, hex string number, number, BigNumber or BN object
 * @return {Object} `output` BN object of the number
 * @throws if the argument is not an array, object that isn't a bignumber, not a string number or number
 */
var src = function numberToBN(arg) {
  if (typeof arg === 'string' || typeof arg === 'number') {
    var multiplier = new BN$4(1); // eslint-disable-line
    var formattedString = String(arg).toLowerCase().trim();
    var isHexPrefixed = formattedString.substr(0, 2) === '0x' || formattedString.substr(0, 3) === '-0x';
    var stringArg = stripHexPrefix$3(formattedString); // eslint-disable-line
    if (stringArg.substr(0, 1) === '-') {
      stringArg = stripHexPrefix$3(stringArg.slice(1));
      multiplier = new BN$4(-1, 10);
    }
    stringArg = stringArg === '' ? '0' : stringArg;

    if ((!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/))
      || stringArg.match(/^[a-fA-F]+$/)
      || (isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/))) {
      return new BN$4(stringArg, 16).mul(multiplier);
    }

    if ((stringArg.match(/^-?[0-9]+$/) || stringArg === '') && isHexPrefixed === false) {
      return new BN$4(stringArg, 10).mul(multiplier);
    }
  } else if (typeof arg === 'object' && arg.toString && (!arg.pop && !arg.push)) {
    if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
      return new BN$4(arg.toString(10), 10);
    }
  }

  throw new Error('[number-to-bn] while converting number ' + JSON.stringify(arg) + ' to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.');
};

var BN$3 = bnExports$1;
var numberToBN$1 = src;

var zero = new BN$3(0);
var negative1 = new BN$3(-1);

// complete ethereum unit map
var unitMap = {
  'noether': '0', // eslint-disable-line
  'wei': '1', // eslint-disable-line
  'kwei': '1000', // eslint-disable-line
  'Kwei': '1000', // eslint-disable-line
  'babbage': '1000', // eslint-disable-line
  'femtoether': '1000', // eslint-disable-line
  'mwei': '1000000', // eslint-disable-line
  'Mwei': '1000000', // eslint-disable-line
  'lovelace': '1000000', // eslint-disable-line
  'picoether': '1000000', // eslint-disable-line
  'gwei': '1000000000', // eslint-disable-line
  'Gwei': '1000000000', // eslint-disable-line
  'shannon': '1000000000', // eslint-disable-line
  'nanoether': '1000000000', // eslint-disable-line
  'nano': '1000000000', // eslint-disable-line
  'szabo': '1000000000000', // eslint-disable-line
  'microether': '1000000000000', // eslint-disable-line
  'micro': '1000000000000', // eslint-disable-line
  'finney': '1000000000000000', // eslint-disable-line
  'milliether': '1000000000000000', // eslint-disable-line
  'milli': '1000000000000000', // eslint-disable-line
  'ether': '1000000000000000000', // eslint-disable-line
  'kether': '1000000000000000000000', // eslint-disable-line
  'grand': '1000000000000000000000', // eslint-disable-line
  'mether': '1000000000000000000000000', // eslint-disable-line
  'gether': '1000000000000000000000000000', // eslint-disable-line
  'tether': '1000000000000000000000000000000' };

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
function getValueOfUnit(unitInput) {
  var unit = unitInput ? unitInput.toLowerCase() : 'ether';
  var unitValue = unitMap[unit]; // eslint-disable-line

  if (typeof unitValue !== 'string') {
    throw new Error('[ethjs-unit] the unit provided ' + unitInput + ' doesn\'t exists, please use the one of the following units ' + JSON.stringify(unitMap, null, 2));
  }

  return new BN$3(unitValue, 10);
}

function numberToString(arg) {
  if (typeof arg === 'string') {
    if (!arg.match(/^-?[0-9.]+$/)) {
      throw new Error('while converting number to string, invalid number value \'' + arg + '\', should be a number matching (^-?[0-9.]+).');
    }
    return arg;
  } else if (typeof arg === 'number') {
    return String(arg);
  } else if (typeof arg === 'object' && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
    if (arg.toPrecision) {
      return String(arg.toPrecision());
    } else {
      // eslint-disable-line
      return arg.toString(10);
    }
  }
  throw new Error('while converting number to string, invalid number value \'' + arg + '\' type ' + typeof arg + '.');
}

function fromWei$1(weiInput, unit, optionsInput) {
  var wei = numberToBN$1(weiInput); // eslint-disable-line
  var negative = wei.lt(zero); // eslint-disable-line
  var base = getValueOfUnit(unit);
  var baseLength = unitMap[unit].length - 1 || 1;
  var options = optionsInput || {};

  if (negative) {
    wei = wei.mul(negative1);
  }

  var fraction = wei.mod(base).toString(10); // eslint-disable-line

  while (fraction.length < baseLength) {
    fraction = '0' + fraction;
  }

  if (!options.pad) {
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  }

  var whole = wei.div(base).toString(10); // eslint-disable-line

  if (options.commify) {
    whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  }

  var value = '' + whole + (fraction == '0' ? '' : '.' + fraction); // eslint-disable-line

  if (negative) {
    value = '-' + value;
  }

  return value;
}

function toWei$1(etherInput, unit) {
  var ether = numberToString(etherInput); // eslint-disable-line
  var base = getValueOfUnit(unit);
  var baseLength = unitMap[unit].length - 1 || 1;

  // Is it negative?
  var negative = ether.substring(0, 1) === '-'; // eslint-disable-line
  if (negative) {
    ether = ether.substring(1);
  }

  if (ether === '.') {
    throw new Error('[ethjs-unit] while converting number ' + etherInput + ' to wei, invalid value');
  }

  // Split it into a whole and fractional part
  var comps = ether.split('.'); // eslint-disable-line
  if (comps.length > 2) {
    throw new Error('[ethjs-unit] while converting number ' + etherInput + ' to wei,  too many decimal points');
  }

  var whole = comps[0],
      fraction = comps[1]; // eslint-disable-line

  if (!whole) {
    whole = '0';
  }
  if (!fraction) {
    fraction = '0';
  }
  if (fraction.length > baseLength) {
    throw new Error('[ethjs-unit] while converting number ' + etherInput + ' to wei, too many decimal places');
  }

  while (fraction.length < baseLength) {
    fraction += '0';
  }

  whole = new BN$3(whole);
  fraction = new BN$3(fraction);
  var wei = whole.mul(base).add(fraction); // eslint-disable-line

  if (negative) {
    wei = wei.mul(negative1);
  }

  return new BN$3(wei.toString(10), 10);
}

var lib$1 = {
  unitMap: unitMap,
  numberToString: numberToString,
  getValueOfUnit: getValueOfUnit,
  fromWei: fromWei$1,
  toWei: toWei$1
};

var utf8$1 = {};

/*! https://mths.be/utf8js v3.0.0 by @mathias */

(function (exports) {
(function(root) {

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		root.version = '3.0.0';
		root.encode = utf8encode;
		root.decode = utf8decode;

	}(exports)); 
} (utf8$1));

var dist$2 = {};

var constants$2 = {};

var secp256k1$1 = {};

var secp256k1 = {};

var sha256 = {};

var _sha2 = {};

var _assert = {};

Object.defineProperty(_assert, "__esModule", { value: true });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
_assert.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
_assert.bool = bool;
// copied from utils
function isBytes$1(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes$1(b, ...lengths) {
    if (!isBytes$1(b))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
_assert.bytes = bytes$1;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
_assert.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
_assert.exists = exists;
function output(out, instance) {
    bytes$1(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
_assert.output = output;
const assert = { number, bool, bytes: bytes$1, hash, exists, output };
_assert.default = assert;

var utils$b = {};

var crypto = {};

Object.defineProperty(crypto, "__esModule", { value: true });
crypto.crypto = void 0;
crypto.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

(function (exports) {
	/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
	// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
	// node.js versions earlier than v19 don't declare it in global scope.
	// For node.js, package.json#exports field mapping rewrites import
	// from `crypto` to `cryptoNode`, which imports native module.
	// Makes the utils un-importable in browsers without a bundler.
	// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
	const crypto_1 = crypto;
	// Cast array to different type
	const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
	exports.u8 = u8;
	const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
	exports.u32 = u32;
	function isBytes(a) {
	    return (a instanceof Uint8Array ||
	        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
	}
	// Cast array to view
	const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
	exports.createView = createView;
	// The rotate right (circular right shift) operation for uint32
	const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
	exports.rotr = rotr;
	// big-endian hardware is rare. Just in case someone still decides to run hashes:
	// early-throw an error because we don't support BE yet.
	// Other libraries would silently corrupt the data instead of throwing an error,
	// when they don't support it.
	exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
	if (!exports.isLE)
	    throw new Error('Non little-endian hardware is not supported');
	// Array where index 0xf0 (240) is mapped to string 'f0'
	const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
	/**
	 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
	 */
	function bytesToHex(bytes) {
	    if (!isBytes(bytes))
	        throw new Error('Uint8Array expected');
	    // pre-caching improves the speed 6x
	    let hex = '';
	    for (let i = 0; i < bytes.length; i++) {
	        hex += hexes[bytes[i]];
	    }
	    return hex;
	}
	exports.bytesToHex = bytesToHex;
	// We use optimized technique to convert hex string to byte array
	const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
	function asciiToBase16(char) {
	    if (char >= asciis._0 && char <= asciis._9)
	        return char - asciis._0;
	    if (char >= asciis._A && char <= asciis._F)
	        return char - (asciis._A - 10);
	    if (char >= asciis._a && char <= asciis._f)
	        return char - (asciis._a - 10);
	    return;
	}
	/**
	 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
	 */
	function hexToBytes(hex) {
	    if (typeof hex !== 'string')
	        throw new Error('hex string expected, got ' + typeof hex);
	    const hl = hex.length;
	    const al = hl / 2;
	    if (hl % 2)
	        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
	    const array = new Uint8Array(al);
	    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
	        const n1 = asciiToBase16(hex.charCodeAt(hi));
	        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
	        if (n1 === undefined || n2 === undefined) {
	            const char = hex[hi] + hex[hi + 1];
	            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
	        }
	        array[ai] = n1 * 16 + n2;
	    }
	    return array;
	}
	exports.hexToBytes = hexToBytes;
	// There is no setImmediate in browser and setTimeout is slow.
	// call of async fn will return Promise, which will be fullfiled only on
	// next scheduler queue processing step and this is exactly what we need.
	const nextTick = async () => { };
	exports.nextTick = nextTick;
	// Returns control to thread each 'tick' ms to avoid blocking
	async function asyncLoop(iters, tick, cb) {
	    let ts = Date.now();
	    for (let i = 0; i < iters; i++) {
	        cb(i);
	        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
	        const diff = Date.now() - ts;
	        if (diff >= 0 && diff < tick)
	            continue;
	        await (0, exports.nextTick)();
	        ts += diff;
	    }
	}
	exports.asyncLoop = asyncLoop;
	/**
	 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
	 */
	function utf8ToBytes(str) {
	    if (typeof str !== 'string')
	        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
	    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
	}
	exports.utf8ToBytes = utf8ToBytes;
	/**
	 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
	 * Warning: when Uint8Array is passed, it would NOT get copied.
	 * Keep in mind for future mutable operations.
	 */
	function toBytes(data) {
	    if (typeof data === 'string')
	        data = utf8ToBytes(data);
	    if (!isBytes(data))
	        throw new Error(`expected Uint8Array, got ${typeof data}`);
	    return data;
	}
	exports.toBytes = toBytes;
	/**
	 * Copies several Uint8Arrays into one.
	 */
	function concatBytes(...arrays) {
	    let sum = 0;
	    for (let i = 0; i < arrays.length; i++) {
	        const a = arrays[i];
	        if (!isBytes(a))
	            throw new Error('Uint8Array expected');
	        sum += a.length;
	    }
	    const res = new Uint8Array(sum);
	    for (let i = 0, pad = 0; i < arrays.length; i++) {
	        const a = arrays[i];
	        res.set(a, pad);
	        pad += a.length;
	    }
	    return res;
	}
	exports.concatBytes = concatBytes;
	// For runtime check if class implements interface
	class Hash {
	    // Safe version that clones internal state
	    clone() {
	        return this._cloneInto();
	    }
	}
	exports.Hash = Hash;
	const toStr = {}.toString;
	function checkOpts(defaults, opts) {
	    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
	        throw new Error('Options should be object or undefined');
	    const merged = Object.assign(defaults, opts);
	    return merged;
	}
	exports.checkOpts = checkOpts;
	function wrapConstructor(hashCons) {
	    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
	    const tmp = hashCons();
	    hashC.outputLen = tmp.outputLen;
	    hashC.blockLen = tmp.blockLen;
	    hashC.create = () => hashCons();
	    return hashC;
	}
	exports.wrapConstructor = wrapConstructor;
	function wrapConstructorWithOpts(hashCons) {
	    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
	    const tmp = hashCons({});
	    hashC.outputLen = tmp.outputLen;
	    hashC.blockLen = tmp.blockLen;
	    hashC.create = (opts) => hashCons(opts);
	    return hashC;
	}
	exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
	function wrapXOFConstructorWithOpts(hashCons) {
	    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
	    const tmp = hashCons({});
	    hashC.outputLen = tmp.outputLen;
	    hashC.blockLen = tmp.blockLen;
	    hashC.create = (opts) => hashCons(opts);
	    return hashC;
	}
	exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
	/**
	 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
	 */
	function randomBytes(bytesLength = 32) {
	    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
	        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
	    }
	    throw new Error('crypto.getRandomValues must be defined');
	}
	exports.randomBytes = randomBytes;
	
} (utils$b));

Object.defineProperty(_sha2, "__esModule", { value: true });
_sha2.SHA2 = void 0;
const _assert_js_1$1 = _assert;
const utils_js_1$7 = utils$b;
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1$7.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1$7.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1$1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1$7.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1$7.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1$1.exists)(this);
        (0, _assert_js_1$1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1$7.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
_sha2.SHA2 = SHA2;

Object.defineProperty(sha256, "__esModule", { value: true });
sha256.sha224 = sha256.sha256 = void 0;
const _sha2_js_1 = _sha2;
const utils_js_1$6 = utils$b;
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1$6.rotr)(W15, 7) ^ (0, utils_js_1$6.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1$6.rotr)(W2, 17) ^ (0, utils_js_1$6.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1$6.rotr)(E, 6) ^ (0, utils_js_1$6.rotr)(E, 11) ^ (0, utils_js_1$6.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1$6.rotr)(A, 2) ^ (0, utils_js_1$6.rotr)(A, 13) ^ (0, utils_js_1$6.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
sha256.sha256 = (0, utils_js_1$6.wrapConstructor)(() => new SHA256());
sha256.sha224 = (0, utils_js_1$6.wrapConstructor)(() => new SHA224());

var modular = {};

var utils$a = {};

Object.defineProperty(utils$a, "__esModule", { value: true });
utils$a.validateObject = utils$a.createHmacDrbg = utils$a.bitMask = utils$a.bitSet = utils$a.bitGet = utils$a.bitLen = utils$a.utf8ToBytes = utils$a.equalBytes = utils$a.concatBytes = utils$a.ensureBytes = utils$a.numberToVarBytesBE = utils$a.numberToBytesLE = utils$a.numberToBytesBE = utils$a.bytesToNumberLE = utils$a.bytesToNumberBE = utils$a.hexToBytes = utils$a.hexToNumber = utils$a.numberToHexUnpadded = utils$a.bytesToHex = utils$a.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n$3 = BigInt(0);
const _1n$3 = BigInt(1);
const _2n$2 = BigInt(2);
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
utils$a.isBytes = isBytes;
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex$3(bytes) {
    if (!isBytes(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
utils$a.bytesToHex = bytesToHex$3;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
utils$a.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber$1(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
utils$a.hexToNumber = hexToNumber$1;
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes$2(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
utils$a.hexToBytes = hexToBytes$2;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber$1(bytesToHex$3(bytes));
}
utils$a.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!isBytes(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber$1(bytesToHex$3(Uint8Array.from(bytes).reverse()));
}
utils$a.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes$2(n.toString(16).padStart(len * 2, '0'));
}
utils$a.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
utils$a.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes$2(numberToHexUnpadded(n));
}
utils$a.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes$2(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
utils$a.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes$1(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
            throw new Error('Uint8Array expected');
        sum += a.length;
    }
    let res = new Uint8Array(sum);
    let pad = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
utils$a.concatBytes = concatBytes$1;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
utils$a.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes$1(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
utils$a.utf8ToBytes = utf8ToBytes$1;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n$3; n >>= _1n$3, len += 1)
        ;
    return len;
}
utils$a.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n$3;
}
utils$a.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n$3 : _0n$3) << BigInt(pos));
};
utils$a.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n$2 << BigInt(n - 1)) - _1n$3;
utils$a.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes$1(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
utils$a.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
utils$a.validateObject = validateObject;

Object.defineProperty(modular, "__esModule", { value: true });
modular.mapHashToField = modular.getMinHashLength = modular.getFieldBytesLength = modular.hashToPrivateScalar = modular.FpSqrtEven = modular.FpSqrtOdd = modular.Field = modular.nLength = modular.FpIsSquare = modular.FpDiv = modular.FpInvertBatch = modular.FpPow = modular.validateField = modular.isNegativeLE = modular.FpSqrt = modular.tonelliShanks = modular.invert = modular.pow2 = modular.pow = modular.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1$5 = utils$a;
// prettier-ignore
const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
BigInt(9); BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n$2 ? result : b + result;
}
modular.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n$2 || power < _0n$2)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n$2)
        return _0n$2;
    let res = _1n$2;
    while (power > _0n$2) {
        if (power & _1n$2)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n$2;
    }
    return res;
}
modular.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n$2) {
        res *= res;
        res %= modulo;
    }
    return res;
}
modular.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n$2 || modulo <= _0n$2) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n$2, u = _1n$2;
    while (a !== _0n$2) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        // prettier-ignore
        b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$2)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
modular.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ≡ 1    if a is a square (mod p)
    // (a | p) ≡ -1   if a is not a square (mod p)
    // (a | p) ≡ 0    if a ≡ 0 (mod p)
    const legendreC = (P - _1n$2) / _2n$1;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n$2, S = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S++)
        ;
    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq
    for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$2; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n$2) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n$2) / _2n$1;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n$2 << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
modular.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ≡ 3 (mod 4)
    // √n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n$2) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n$1);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n$1), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
modular.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$2) === _1n$2;
modular.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1$5.validateObject)(field, opts);
}
modular.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n$2)
        throw new Error('Expected power > 0');
    if (power === _0n$2)
        return f.ONE;
    if (power === _1n$2)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n$2) {
        if (power & _1n$2)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n$2;
    }
    return p;
}
modular.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
modular.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
modular.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n$2) / _2n$1; // Integer arithmetic
    return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
modular.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
modular.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n$2)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1$5.bitMask)(BITS),
        ZERO: _0n$2,
        ONE: _1n$2,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n$2 <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n$2,
        isOdd: (num) => (num & _1n$2) === _1n$2,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1$5.numberToBytesLE)(num, BYTES) : (0, utils_js_1$5.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1$5.bytesToNumberLE)(bytes) : (0, utils_js_1$5.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
modular.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
modular.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
modular.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1$5.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1$5.bytesToNumberLE)(hash) : (0, utils_js_1$5.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n$2) + _1n$2;
}
modular.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
modular.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
modular.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1$5.bytesToNumberBE)(key) : (0, utils_js_1$5.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n$2) + _1n$2;
    return isLE ? (0, utils_js_1$5.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1$5.numberToBytesBE)(reduced, fieldLen);
}
modular.mapHashToField = mapHashToField;

var weierstrass = {};

var curve = {};

Object.defineProperty(curve, "__esModule", { value: true });
curve.validateBasic = curve.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1$1 = modular;
const utils_js_1$4 = utils$a;
const _0n$1 = BigInt(0);
const _1n$1 = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n$1) {
                if (n & _1n$1)
                    p = p.add(d);
                d = d.double();
                n >>= _1n$1;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n$1;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
curve.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_js_1$1.validateField)(curve.Fp);
    (0, utils_js_1$4.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1$1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
curve.validateBasic = validateBasic;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
	/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	// Short Weierstrass curve. The formula is: y² = x³ + ax + b
	const mod = modular;
	const ut = utils$a;
	const utils_js_1 = utils$a;
	const curve_js_1 = curve;
	function validatePointOpts(curve) {
	    const opts = (0, curve_js_1.validateBasic)(curve);
	    ut.validateObject(opts, {
	        a: 'field',
	        b: 'field',
	    }, {
	        allowedPrivateKeyLengths: 'array',
	        wrapPrivateKey: 'boolean',
	        isTorsionFree: 'function',
	        clearCofactor: 'function',
	        allowInfinityPoint: 'boolean',
	        fromBytes: 'function',
	        toBytes: 'function',
	    });
	    const { endo, Fp, a } = opts;
	    if (endo) {
	        if (!Fp.eql(a, Fp.ZERO)) {
	            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
	        }
	        if (typeof endo !== 'object' ||
	            typeof endo.beta !== 'bigint' ||
	            typeof endo.splitScalar !== 'function') {
	            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
	        }
	    }
	    return Object.freeze({ ...opts });
	}
	// ASN.1 DER encoding utilities
	const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
	exports.DER = {
	    // asn.1 DER encoding utils
	    Err: class DERErr extends Error {
	        constructor(m = '') {
	            super(m);
	        }
	    },
	    _parseInt(data) {
	        const { Err: E } = exports.DER;
	        if (data.length < 2 || data[0] !== 0x02)
	            throw new E('Invalid signature integer tag');
	        const len = data[1];
	        const res = data.subarray(2, len + 2);
	        if (!len || res.length !== len)
	            throw new E('Invalid signature integer: wrong length');
	        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
	        // since we always use positive integers here. It must always be empty:
	        // - add zero byte if exists
	        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
	        if (res[0] & 0b10000000)
	            throw new E('Invalid signature integer: negative');
	        if (res[0] === 0x00 && !(res[1] & 0b10000000))
	            throw new E('Invalid signature integer: unnecessary leading zero');
	        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
	    },
	    toSig(hex) {
	        // parse DER signature
	        const { Err: E } = exports.DER;
	        const data = typeof hex === 'string' ? h2b(hex) : hex;
	        if (!ut.isBytes(data))
	            throw new Error('ui8a expected');
	        let l = data.length;
	        if (l < 2 || data[0] != 0x30)
	            throw new E('Invalid signature tag');
	        if (data[1] !== l - 2)
	            throw new E('Invalid signature: incorrect length');
	        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
	        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
	        if (rBytesLeft.length)
	            throw new E('Invalid signature: left bytes after parsing');
	        return { r, s };
	    },
	    hexFromSig(sig) {
	        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
	        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
	        const h = (num) => {
	            const hex = num.toString(16);
	            return hex.length & 1 ? `0${hex}` : hex;
	        };
	        const s = slice(h(sig.s));
	        const r = slice(h(sig.r));
	        const shl = s.length / 2;
	        const rhl = r.length / 2;
	        const sl = h(shl);
	        const rl = h(rhl);
	        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
	    },
	};
	// Be friendly to bad ECMAScript parsers by not using bigint literals
	// prettier-ignore
	const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
	function weierstrassPoints(opts) {
	    const CURVE = validatePointOpts(opts);
	    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
	    const toBytes = CURVE.toBytes ||
	        ((_c, point, _isCompressed) => {
	            const a = point.toAffine();
	            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
	        });
	    const fromBytes = CURVE.fromBytes ||
	        ((bytes) => {
	            // const head = bytes[0];
	            const tail = bytes.subarray(1);
	            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
	            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
	            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
	            return { x, y };
	        });
	    /**
	     * y² = x³ + ax + b: Short weierstrass curve formula
	     * @returns y²
	     */
	    function weierstrassEquation(x) {
	        const { a, b } = CURVE;
	        const x2 = Fp.sqr(x); // x * x
	        const x3 = Fp.mul(x2, x); // x2 * x
	        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
	    }
	    // Validate whether the passed curve params are valid.
	    // We check if curve equation works for generator point.
	    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
	    // ProjectivePoint class has not been initialized yet.
	    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
	        throw new Error('bad generator point: equation left != right');
	    // Valid group elements reside in range 1..n-1
	    function isWithinCurveOrder(num) {
	        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
	    }
	    function assertGE(num) {
	        if (!isWithinCurveOrder(num))
	            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
	    }
	    // Validates if priv key is valid and converts it to bigint.
	    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
	    function normPrivateKeyToScalar(key) {
	        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
	        if (lengths && typeof key !== 'bigint') {
	            if (ut.isBytes(key))
	                key = ut.bytesToHex(key);
	            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
	            if (typeof key !== 'string' || !lengths.includes(key.length))
	                throw new Error('Invalid key');
	            key = key.padStart(nByteLength * 2, '0');
	        }
	        let num;
	        try {
	            num =
	                typeof key === 'bigint'
	                    ? key
	                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
	        }
	        catch (error) {
	            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
	        }
	        if (wrapPrivateKey)
	            num = mod.mod(num, n); // disabled by default, enabled for BLS
	        assertGE(num); // num in range [1..N-1]
	        return num;
	    }
	    const pointPrecomputes = new Map();
	    function assertPrjPoint(other) {
	        if (!(other instanceof Point))
	            throw new Error('ProjectivePoint expected');
	    }
	    /**
	     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
	     * Default Point works in 2d / affine coordinates: (x, y)
	     * We're doing calculations in projective, because its operations don't require costly inversion.
	     */
	    class Point {
	        constructor(px, py, pz) {
	            this.px = px;
	            this.py = py;
	            this.pz = pz;
	            if (px == null || !Fp.isValid(px))
	                throw new Error('x required');
	            if (py == null || !Fp.isValid(py))
	                throw new Error('y required');
	            if (pz == null || !Fp.isValid(pz))
	                throw new Error('z required');
	        }
	        // Does not validate if the point is on-curve.
	        // Use fromHex instead, or call assertValidity() later.
	        static fromAffine(p) {
	            const { x, y } = p || {};
	            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
	                throw new Error('invalid affine point');
	            if (p instanceof Point)
	                throw new Error('projective point not allowed');
	            const is0 = (i) => Fp.eql(i, Fp.ZERO);
	            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
	            if (is0(x) && is0(y))
	                return Point.ZERO;
	            return new Point(x, y, Fp.ONE);
	        }
	        get x() {
	            return this.toAffine().x;
	        }
	        get y() {
	            return this.toAffine().y;
	        }
	        /**
	         * Takes a bunch of Projective Points but executes only one
	         * inversion on all of them. Inversion is very slow operation,
	         * so this improves performance massively.
	         * Optimization: converts a list of projective points to a list of identical points with Z=1.
	         */
	        static normalizeZ(points) {
	            const toInv = Fp.invertBatch(points.map((p) => p.pz));
	            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
	        }
	        /**
	         * Converts hash string or Uint8Array to Point.
	         * @param hex short/long ECDSA hex
	         */
	        static fromHex(hex) {
	            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
	            P.assertValidity();
	            return P;
	        }
	        // Multiplies generator point by privateKey.
	        static fromPrivateKey(privateKey) {
	            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
	        }
	        // "Private method", don't use it directly
	        _setWindowSize(windowSize) {
	            this._WINDOW_SIZE = windowSize;
	            pointPrecomputes.delete(this);
	        }
	        // A point on curve is valid if it conforms to equation.
	        assertValidity() {
	            if (this.is0()) {
	                // (0, 1, 0) aka ZERO is invalid in most contexts.
	                // In BLS, ZERO can be serialized, so we allow it.
	                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
	                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
	                    return;
	                throw new Error('bad point: ZERO');
	            }
	            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
	            const { x, y } = this.toAffine();
	            // Check if x, y are valid field elements
	            if (!Fp.isValid(x) || !Fp.isValid(y))
	                throw new Error('bad point: x or y not FE');
	            const left = Fp.sqr(y); // y²
	            const right = weierstrassEquation(x); // x³ + ax + b
	            if (!Fp.eql(left, right))
	                throw new Error('bad point: equation left != right');
	            if (!this.isTorsionFree())
	                throw new Error('bad point: not in prime-order subgroup');
	        }
	        hasEvenY() {
	            const { y } = this.toAffine();
	            if (Fp.isOdd)
	                return !Fp.isOdd(y);
	            throw new Error("Field doesn't support isOdd");
	        }
	        /**
	         * Compare one point to another.
	         */
	        equals(other) {
	            assertPrjPoint(other);
	            const { px: X1, py: Y1, pz: Z1 } = this;
	            const { px: X2, py: Y2, pz: Z2 } = other;
	            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
	            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
	            return U1 && U2;
	        }
	        /**
	         * Flips point to one corresponding to (x, -y) in Affine coordinates.
	         */
	        negate() {
	            return new Point(this.px, Fp.neg(this.py), this.pz);
	        }
	        // Renes-Costello-Batina exception-free doubling formula.
	        // There is 30% faster Jacobian formula, but it is not complete.
	        // https://eprint.iacr.org/2015/1060, algorithm 3
	        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
	        double() {
	            const { a, b } = CURVE;
	            const b3 = Fp.mul(b, _3n);
	            const { px: X1, py: Y1, pz: Z1 } = this;
	            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
	            let t0 = Fp.mul(X1, X1); // step 1
	            let t1 = Fp.mul(Y1, Y1);
	            let t2 = Fp.mul(Z1, Z1);
	            let t3 = Fp.mul(X1, Y1);
	            t3 = Fp.add(t3, t3); // step 5
	            Z3 = Fp.mul(X1, Z1);
	            Z3 = Fp.add(Z3, Z3);
	            X3 = Fp.mul(a, Z3);
	            Y3 = Fp.mul(b3, t2);
	            Y3 = Fp.add(X3, Y3); // step 10
	            X3 = Fp.sub(t1, Y3);
	            Y3 = Fp.add(t1, Y3);
	            Y3 = Fp.mul(X3, Y3);
	            X3 = Fp.mul(t3, X3);
	            Z3 = Fp.mul(b3, Z3); // step 15
	            t2 = Fp.mul(a, t2);
	            t3 = Fp.sub(t0, t2);
	            t3 = Fp.mul(a, t3);
	            t3 = Fp.add(t3, Z3);
	            Z3 = Fp.add(t0, t0); // step 20
	            t0 = Fp.add(Z3, t0);
	            t0 = Fp.add(t0, t2);
	            t0 = Fp.mul(t0, t3);
	            Y3 = Fp.add(Y3, t0);
	            t2 = Fp.mul(Y1, Z1); // step 25
	            t2 = Fp.add(t2, t2);
	            t0 = Fp.mul(t2, t3);
	            X3 = Fp.sub(X3, t0);
	            Z3 = Fp.mul(t2, t1);
	            Z3 = Fp.add(Z3, Z3); // step 30
	            Z3 = Fp.add(Z3, Z3);
	            return new Point(X3, Y3, Z3);
	        }
	        // Renes-Costello-Batina exception-free addition formula.
	        // There is 30% faster Jacobian formula, but it is not complete.
	        // https://eprint.iacr.org/2015/1060, algorithm 1
	        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
	        add(other) {
	            assertPrjPoint(other);
	            const { px: X1, py: Y1, pz: Z1 } = this;
	            const { px: X2, py: Y2, pz: Z2 } = other;
	            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
	            const a = CURVE.a;
	            const b3 = Fp.mul(CURVE.b, _3n);
	            let t0 = Fp.mul(X1, X2); // step 1
	            let t1 = Fp.mul(Y1, Y2);
	            let t2 = Fp.mul(Z1, Z2);
	            let t3 = Fp.add(X1, Y1);
	            let t4 = Fp.add(X2, Y2); // step 5
	            t3 = Fp.mul(t3, t4);
	            t4 = Fp.add(t0, t1);
	            t3 = Fp.sub(t3, t4);
	            t4 = Fp.add(X1, Z1);
	            let t5 = Fp.add(X2, Z2); // step 10
	            t4 = Fp.mul(t4, t5);
	            t5 = Fp.add(t0, t2);
	            t4 = Fp.sub(t4, t5);
	            t5 = Fp.add(Y1, Z1);
	            X3 = Fp.add(Y2, Z2); // step 15
	            t5 = Fp.mul(t5, X3);
	            X3 = Fp.add(t1, t2);
	            t5 = Fp.sub(t5, X3);
	            Z3 = Fp.mul(a, t4);
	            X3 = Fp.mul(b3, t2); // step 20
	            Z3 = Fp.add(X3, Z3);
	            X3 = Fp.sub(t1, Z3);
	            Z3 = Fp.add(t1, Z3);
	            Y3 = Fp.mul(X3, Z3);
	            t1 = Fp.add(t0, t0); // step 25
	            t1 = Fp.add(t1, t0);
	            t2 = Fp.mul(a, t2);
	            t4 = Fp.mul(b3, t4);
	            t1 = Fp.add(t1, t2);
	            t2 = Fp.sub(t0, t2); // step 30
	            t2 = Fp.mul(a, t2);
	            t4 = Fp.add(t4, t2);
	            t0 = Fp.mul(t1, t4);
	            Y3 = Fp.add(Y3, t0);
	            t0 = Fp.mul(t5, t4); // step 35
	            X3 = Fp.mul(t3, X3);
	            X3 = Fp.sub(X3, t0);
	            t0 = Fp.mul(t3, t1);
	            Z3 = Fp.mul(t5, Z3);
	            Z3 = Fp.add(Z3, t0); // step 40
	            return new Point(X3, Y3, Z3);
	        }
	        subtract(other) {
	            return this.add(other.negate());
	        }
	        is0() {
	            return this.equals(Point.ZERO);
	        }
	        wNAF(n) {
	            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
	                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
	                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
	            });
	        }
	        /**
	         * Non-constant-time multiplication. Uses double-and-add algorithm.
	         * It's faster, but should only be used when you don't care about
	         * an exposed private key e.g. sig verification, which works over *public* keys.
	         */
	        multiplyUnsafe(n) {
	            const I = Point.ZERO;
	            if (n === _0n)
	                return I;
	            assertGE(n); // Will throw on 0
	            if (n === _1n)
	                return this;
	            const { endo } = CURVE;
	            if (!endo)
	                return wnaf.unsafeLadder(this, n);
	            // Apply endomorphism
	            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
	            let k1p = I;
	            let k2p = I;
	            let d = this;
	            while (k1 > _0n || k2 > _0n) {
	                if (k1 & _1n)
	                    k1p = k1p.add(d);
	                if (k2 & _1n)
	                    k2p = k2p.add(d);
	                d = d.double();
	                k1 >>= _1n;
	                k2 >>= _1n;
	            }
	            if (k1neg)
	                k1p = k1p.negate();
	            if (k2neg)
	                k2p = k2p.negate();
	            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
	            return k1p.add(k2p);
	        }
	        /**
	         * Constant time multiplication.
	         * Uses wNAF method. Windowed method may be 10% faster,
	         * but takes 2x longer to generate and consumes 2x memory.
	         * Uses precomputes when available.
	         * Uses endomorphism for Koblitz curves.
	         * @param scalar by which the point would be multiplied
	         * @returns New point
	         */
	        multiply(scalar) {
	            assertGE(scalar);
	            let n = scalar;
	            let point, fake; // Fake point is used to const-time mult
	            const { endo } = CURVE;
	            if (endo) {
	                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
	                let { p: k1p, f: f1p } = this.wNAF(k1);
	                let { p: k2p, f: f2p } = this.wNAF(k2);
	                k1p = wnaf.constTimeNegate(k1neg, k1p);
	                k2p = wnaf.constTimeNegate(k2neg, k2p);
	                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
	                point = k1p.add(k2p);
	                fake = f1p.add(f2p);
	            }
	            else {
	                const { p, f } = this.wNAF(n);
	                point = p;
	                fake = f;
	            }
	            // Normalize `z` for both points, but return only real one
	            return Point.normalizeZ([point, fake])[0];
	        }
	        /**
	         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
	         * Not using Strauss-Shamir trick: precomputation tables are faster.
	         * The trick could be useful if both P and Q are not G (not in our case).
	         * @returns non-zero affine point
	         */
	        multiplyAndAddUnsafe(Q, a, b) {
	            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
	            const mul = (P, a // Select faster multiply() method
	            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
	            const sum = mul(this, a).add(mul(Q, b));
	            return sum.is0() ? undefined : sum;
	        }
	        // Converts Projective point to affine (x, y) coordinates.
	        // Can accept precomputed Z^-1 - for example, from invertBatch.
	        // (x, y, z) ∋ (x=x/z, y=y/z)
	        toAffine(iz) {
	            const { px: x, py: y, pz: z } = this;
	            const is0 = this.is0();
	            // If invZ was 0, we return zero point. However we still want to execute
	            // all operations, so we replace invZ with a random number, 1.
	            if (iz == null)
	                iz = is0 ? Fp.ONE : Fp.inv(z);
	            const ax = Fp.mul(x, iz);
	            const ay = Fp.mul(y, iz);
	            const zz = Fp.mul(z, iz);
	            if (is0)
	                return { x: Fp.ZERO, y: Fp.ZERO };
	            if (!Fp.eql(zz, Fp.ONE))
	                throw new Error('invZ was invalid');
	            return { x: ax, y: ay };
	        }
	        isTorsionFree() {
	            const { h: cofactor, isTorsionFree } = CURVE;
	            if (cofactor === _1n)
	                return true; // No subgroups, always torsion-free
	            if (isTorsionFree)
	                return isTorsionFree(Point, this);
	            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
	        }
	        clearCofactor() {
	            const { h: cofactor, clearCofactor } = CURVE;
	            if (cofactor === _1n)
	                return this; // Fast-path
	            if (clearCofactor)
	                return clearCofactor(Point, this);
	            return this.multiplyUnsafe(CURVE.h);
	        }
	        toRawBytes(isCompressed = true) {
	            this.assertValidity();
	            return toBytes(Point, this, isCompressed);
	        }
	        toHex(isCompressed = true) {
	            return ut.bytesToHex(this.toRawBytes(isCompressed));
	        }
	    }
	    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
	    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
	    const _bits = CURVE.nBitLength;
	    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
	    // Validate if generator point is on curve
	    return {
	        CURVE,
	        ProjectivePoint: Point,
	        normPrivateKeyToScalar,
	        weierstrassEquation,
	        isWithinCurveOrder,
	    };
	}
	exports.weierstrassPoints = weierstrassPoints;
	function validateOpts(curve) {
	    const opts = (0, curve_js_1.validateBasic)(curve);
	    ut.validateObject(opts, {
	        hash: 'hash',
	        hmac: 'function',
	        randomBytes: 'function',
	    }, {
	        bits2int: 'function',
	        bits2int_modN: 'function',
	        lowS: 'boolean',
	    });
	    return Object.freeze({ lowS: true, ...opts });
	}
	function weierstrass(curveDef) {
	    const CURVE = validateOpts(curveDef);
	    const { Fp, n: CURVE_ORDER } = CURVE;
	    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
	    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
	    function isValidFieldElement(num) {
	        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
	    }
	    function modN(a) {
	        return mod.mod(a, CURVE_ORDER);
	    }
	    function invN(a) {
	        return mod.invert(a, CURVE_ORDER);
	    }
	    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
	        ...CURVE,
	        toBytes(_c, point, isCompressed) {
	            const a = point.toAffine();
	            const x = Fp.toBytes(a.x);
	            const cat = ut.concatBytes;
	            if (isCompressed) {
	                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
	            }
	            else {
	                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
	            }
	        },
	        fromBytes(bytes) {
	            const len = bytes.length;
	            const head = bytes[0];
	            const tail = bytes.subarray(1);
	            // this.assertValidity() is done inside of fromHex
	            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
	                const x = ut.bytesToNumberBE(tail);
	                if (!isValidFieldElement(x))
	                    throw new Error('Point is not on curve');
	                const y2 = weierstrassEquation(x); // y² = x³ + ax + b
	                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
	                const isYOdd = (y & _1n) === _1n;
	                // ECDSA
	                const isHeadOdd = (head & 1) === 1;
	                if (isHeadOdd !== isYOdd)
	                    y = Fp.neg(y);
	                return { x, y };
	            }
	            else if (len === uncompressedLen && head === 0x04) {
	                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
	                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
	                return { x, y };
	            }
	            else {
	                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
	            }
	        },
	    });
	    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
	    function isBiggerThanHalfOrder(number) {
	        const HALF = CURVE_ORDER >> _1n;
	        return number > HALF;
	    }
	    function normalizeS(s) {
	        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
	    }
	    // slice bytes num
	    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
	    /**
	     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
	     */
	    class Signature {
	        constructor(r, s, recovery) {
	            this.r = r;
	            this.s = s;
	            this.recovery = recovery;
	            this.assertValidity();
	        }
	        // pair (bytes of r, bytes of s)
	        static fromCompact(hex) {
	            const l = CURVE.nByteLength;
	            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
	            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
	        }
	        // DER encoded ECDSA signature
	        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
	        static fromDER(hex) {
	            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
	            return new Signature(r, s);
	        }
	        assertValidity() {
	            // can use assertGE here
	            if (!isWithinCurveOrder(this.r))
	                throw new Error('r must be 0 < r < CURVE.n');
	            if (!isWithinCurveOrder(this.s))
	                throw new Error('s must be 0 < s < CURVE.n');
	        }
	        addRecoveryBit(recovery) {
	            return new Signature(this.r, this.s, recovery);
	        }
	        recoverPublicKey(msgHash) {
	            const { r, s, recovery: rec } = this;
	            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
	            if (rec == null || ![0, 1, 2, 3].includes(rec))
	                throw new Error('recovery id invalid');
	            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
	            if (radj >= Fp.ORDER)
	                throw new Error('recovery id 2 or 3 invalid');
	            const prefix = (rec & 1) === 0 ? '02' : '03';
	            const R = Point.fromHex(prefix + numToNByteStr(radj));
	            const ir = invN(radj); // r^-1
	            const u1 = modN(-h * ir); // -hr^-1
	            const u2 = modN(s * ir); // sr^-1
	            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
	            if (!Q)
	                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
	            Q.assertValidity();
	            return Q;
	        }
	        // Signatures should be low-s, to prevent malleability.
	        hasHighS() {
	            return isBiggerThanHalfOrder(this.s);
	        }
	        normalizeS() {
	            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
	        }
	        // DER-encoded
	        toDERRawBytes() {
	            return ut.hexToBytes(this.toDERHex());
	        }
	        toDERHex() {
	            return exports.DER.hexFromSig({ r: this.r, s: this.s });
	        }
	        // padded bytes of r, then padded bytes of s
	        toCompactRawBytes() {
	            return ut.hexToBytes(this.toCompactHex());
	        }
	        toCompactHex() {
	            return numToNByteStr(this.r) + numToNByteStr(this.s);
	        }
	    }
	    const utils = {
	        isValidPrivateKey(privateKey) {
	            try {
	                normPrivateKeyToScalar(privateKey);
	                return true;
	            }
	            catch (error) {
	                return false;
	            }
	        },
	        normPrivateKeyToScalar: normPrivateKeyToScalar,
	        /**
	         * Produces cryptographically secure private key from random of size
	         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
	         */
	        randomPrivateKey: () => {
	            const length = mod.getMinHashLength(CURVE.n);
	            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
	        },
	        /**
	         * Creates precompute table for an arbitrary EC point. Makes point "cached".
	         * Allows to massively speed-up `point.multiply(scalar)`.
	         * @returns cached point
	         * @example
	         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
	         * fast.multiply(privKey); // much faster ECDH now
	         */
	        precompute(windowSize = 8, point = Point.BASE) {
	            point._setWindowSize(windowSize);
	            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
	            return point;
	        },
	    };
	    /**
	     * Computes public key for a private key. Checks for validity of the private key.
	     * @param privateKey private key
	     * @param isCompressed whether to return compact (default), or full key
	     * @returns Public key, full when isCompressed=false; short when isCompressed=true
	     */
	    function getPublicKey(privateKey, isCompressed = true) {
	        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
	    }
	    /**
	     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
	     */
	    function isProbPub(item) {
	        const arr = ut.isBytes(item);
	        const str = typeof item === 'string';
	        const len = (arr || str) && item.length;
	        if (arr)
	            return len === compressedLen || len === uncompressedLen;
	        if (str)
	            return len === 2 * compressedLen || len === 2 * uncompressedLen;
	        if (item instanceof Point)
	            return true;
	        return false;
	    }
	    /**
	     * ECDH (Elliptic Curve Diffie Hellman).
	     * Computes shared public key from private key and public key.
	     * Checks: 1) private key validity 2) shared key is on-curve.
	     * Does NOT hash the result.
	     * @param privateA private key
	     * @param publicB different public key
	     * @param isCompressed whether to return compact (default), or full key
	     * @returns shared public key
	     */
	    function getSharedSecret(privateA, publicB, isCompressed = true) {
	        if (isProbPub(privateA))
	            throw new Error('first arg must be private key');
	        if (!isProbPub(publicB))
	            throw new Error('second arg must be public key');
	        const b = Point.fromHex(publicB); // check for being on-curve
	        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
	    }
	    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
	    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
	    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
	    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
	    const bits2int = CURVE.bits2int ||
	        function (bytes) {
	            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
	            // for some cases, since bytes.length * 8 is not actual bitLength.
	            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
	            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
	            return delta > 0 ? num >> BigInt(delta) : num;
	        };
	    const bits2int_modN = CURVE.bits2int_modN ||
	        function (bytes) {
	            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
	        };
	    // NOTE: pads output with zero as per spec
	    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
	    /**
	     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
	     */
	    function int2octets(num) {
	        if (typeof num !== 'bigint')
	            throw new Error('bigint expected');
	        if (!(_0n <= num && num < ORDER_MASK))
	            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
	        // works with order, can have different size than numToField!
	        return ut.numberToBytesBE(num, CURVE.nByteLength);
	    }
	    // Steps A, D of RFC6979 3.2
	    // Creates RFC6979 seed; converts msg/privKey to numbers.
	    // Used only in sign, not in verify.
	    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
	    // Also it can be bigger for P224 + SHA256
	    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
	        if (['recovered', 'canonical'].some((k) => k in opts))
	            throw new Error('sign() legacy options not supported');
	        const { hash, randomBytes } = CURVE;
	        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
	        if (lowS == null)
	            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
	        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
	        if (prehash)
	            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
	        // We can't later call bits2octets, since nested bits2int is broken for curves
	        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
	        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
	        const h1int = bits2int_modN(msgHash);
	        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
	        const seedArgs = [int2octets(d), int2octets(h1int)];
	        // extraEntropy. RFC6979 3.6: additional k' (optional).
	        if (ent != null) {
	            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
	            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
	            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
	        }
	        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
	        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
	        // Converts signature params into point w r/s, checks result for validity.
	        function k2sig(kBytes) {
	            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
	            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
	            if (!isWithinCurveOrder(k))
	                return; // Important: all mod() calls here must be done over N
	            const ik = invN(k); // k^-1 mod n
	            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
	            const r = modN(q.x); // r = q.x mod n
	            if (r === _0n)
	                return;
	            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
	            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
	            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
	            const s = modN(ik * modN(m + r * d)); // Not using blinding here
	            if (s === _0n)
	                return;
	            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
	            let normS = s;
	            if (lowS && isBiggerThanHalfOrder(s)) {
	                normS = normalizeS(s); // if lowS was passed, ensure s is always
	                recovery ^= 1; // // in the bottom half of N
	            }
	            return new Signature(r, normS, recovery); // use normS, not s
	        }
	        return { seed, k2sig };
	    }
	    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
	    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
	    /**
	     * Signs message hash with a private key.
	     * ```
	     * sign(m, d, k) where
	     *   (x, y) = G × k
	     *   r = x mod n
	     *   s = (m + dr)/k mod n
	     * ```
	     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
	     * @param privKey private key
	     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
	     * @returns signature with recovery param
	     */
	    function sign(msgHash, privKey, opts = defaultSigOpts) {
	        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
	        const C = CURVE;
	        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
	        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
	    }
	    // Enable precomputes. Slows down first publicKey computation by 20ms.
	    Point.BASE._setWindowSize(8);
	    // utils.precompute(8, ProjectivePoint.BASE)
	    /**
	     * Verifies a signature against message hash and public key.
	     * Rejects lowS signatures by default: to override,
	     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
	     *
	     * ```
	     * verify(r, s, h, P) where
	     *   U1 = hs^-1 mod n
	     *   U2 = rs^-1 mod n
	     *   R = U1⋅G - U2⋅P
	     *   mod(R.x, n) == r
	     * ```
	     */
	    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
	        const sg = signature;
	        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
	        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
	        if ('strict' in opts)
	            throw new Error('options.strict was renamed to lowS');
	        const { lowS, prehash } = opts;
	        let _sig = undefined;
	        let P;
	        try {
	            if (typeof sg === 'string' || ut.isBytes(sg)) {
	                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
	                // Since DER can also be 2*nByteLength bytes, we check for it first.
	                try {
	                    _sig = Signature.fromDER(sg);
	                }
	                catch (derError) {
	                    if (!(derError instanceof exports.DER.Err))
	                        throw derError;
	                    _sig = Signature.fromCompact(sg);
	                }
	            }
	            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
	                const { r, s } = sg;
	                _sig = new Signature(r, s);
	            }
	            else {
	                throw new Error('PARSE');
	            }
	            P = Point.fromHex(publicKey);
	        }
	        catch (error) {
	            if (error.message === 'PARSE')
	                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
	            return false;
	        }
	        if (lowS && _sig.hasHighS())
	            return false;
	        if (prehash)
	            msgHash = CURVE.hash(msgHash);
	        const { r, s } = _sig;
	        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
	        const is = invN(s); // s^-1
	        const u1 = modN(h * is); // u1 = hs^-1 mod n
	        const u2 = modN(r * is); // u2 = rs^-1 mod n
	        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P
	        if (!R)
	            return false;
	        const v = modN(R.x);
	        return v === r;
	    }
	    return {
	        CURVE,
	        getPublicKey,
	        getSharedSecret,
	        sign,
	        verify,
	        ProjectivePoint: Point,
	        Signature,
	        utils,
	    };
	}
	exports.weierstrass = weierstrass;
	/**
	 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
	 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
	 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
	 * b = False and y = sqrt(Z * (u / v)) otherwise.
	 * @param Fp
	 * @param Z
	 * @returns
	 */
	function SWUFpSqrtRatio(Fp, Z) {
	    // Generic implementation
	    const q = Fp.ORDER;
	    let l = _0n;
	    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
	        l += _1n;
	    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
	    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
	    // 2n ** c1 == 2n << (c1-1)
	    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
	    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
	    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
	    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
	    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
	    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
	    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
	    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
	    let sqrtRatio = (u, v) => {
	        let tv1 = c6; // 1. tv1 = c6
	        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
	        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
	        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
	        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
	        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
	        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
	        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
	        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
	        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
	        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
	        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
	        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
	        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
	        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
	        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
	        // 17. for i in (c1, c1 - 1, ..., 2):
	        for (let i = c1; i > _1n; i--) {
	            let tv5 = i - _2n; // 18.    tv5 = i - 2
	            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
	            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
	            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
	            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
	            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
	            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
	            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
	            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
	        }
	        return { isValid: isQR, value: tv3 };
	    };
	    if (Fp.ORDER % _4n === _3n) {
	        // sqrt_ratio_3mod4(u, v)
	        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
	        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
	        sqrtRatio = (u, v) => {
	            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
	            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
	            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
	            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
	            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
	            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
	            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
	            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
	            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
	            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
	        };
	    }
	    // No curves uses that
	    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
	    return sqrtRatio;
	}
	exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
	/**
	 * Simplified Shallue-van de Woestijne-Ulas Method
	 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
	 */
	function mapToCurveSimpleSWU(Fp, opts) {
	    mod.validateField(Fp);
	    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
	        throw new Error('mapToCurveSimpleSWU: invalid opts');
	    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
	    if (!Fp.isOdd)
	        throw new Error('Fp.isOdd is not implemented!');
	    // Input: u, an element of F.
	    // Output: (x, y), a point on E.
	    return (u) => {
	        // prettier-ignore
	        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
	        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
	        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
	        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
	        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
	        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
	        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
	        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
	        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
	        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
	        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
	        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
	        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
	        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
	        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
	        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
	        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
	        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
	        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
	        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
	        y = Fp.mul(y, value); // 20.   y = y * y1
	        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
	        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
	        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
	        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
	        x = Fp.div(x, tv4); // 25.   x = x / tv4
	        return { x, y };
	    };
	}
	exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
	
} (weierstrass));

var hashToCurve = {};

Object.defineProperty(hashToCurve, "__esModule", { value: true });
hashToCurve.createHasher = hashToCurve.isogenyMap = hashToCurve.hash_to_field = hashToCurve.expand_message_xof = hashToCurve.expand_message_xmd = void 0;
const modular_js_1 = modular;
const utils_js_1$3 = utils$a;
function validateDST(dst) {
    if ((0, utils_js_1$3.isBytes)(dst))
        return dst;
    if (typeof dst === 'string')
        return (0, utils_js_1$3.utf8ToBytes)(dst);
    throw new Error('DST must be Uint8Array or string');
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1$3.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function abytes(item) {
    if (!(0, utils_js_1$3.isBytes)(item))
        throw new Error('Uint8Array expected');
}
function isNum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    abytes(msg);
    abytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1$3.concatBytes)((0, utils_js_1$3.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, utils_js_1$3.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1$3.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1$3.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1$3.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1$3.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
hashToCurve.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    abytes(msg);
    abytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1$3.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
hashToCurve.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1$3.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    abytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
hashToCurve.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
hashToCurve.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
hashToCurve.createHasher = createHasher;

var _shortw_utils = {};

var hmac = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hmac = exports.HMAC = void 0;
	const _assert_js_1 = _assert;
	const utils_js_1 = utils$b;
	// HMAC (RFC 2104)
	class HMAC extends utils_js_1.Hash {
	    constructor(hash, _key) {
	        super();
	        this.finished = false;
	        this.destroyed = false;
	        (0, _assert_js_1.hash)(hash);
	        const key = (0, utils_js_1.toBytes)(_key);
	        this.iHash = hash.create();
	        if (typeof this.iHash.update !== 'function')
	            throw new Error('Expected instance of class which extends utils.Hash');
	        this.blockLen = this.iHash.blockLen;
	        this.outputLen = this.iHash.outputLen;
	        const blockLen = this.blockLen;
	        const pad = new Uint8Array(blockLen);
	        // blockLen can be bigger than outputLen
	        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
	        for (let i = 0; i < pad.length; i++)
	            pad[i] ^= 0x36;
	        this.iHash.update(pad);
	        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
	        this.oHash = hash.create();
	        // Undo internal XOR && apply outer XOR
	        for (let i = 0; i < pad.length; i++)
	            pad[i] ^= 0x36 ^ 0x5c;
	        this.oHash.update(pad);
	        pad.fill(0);
	    }
	    update(buf) {
	        (0, _assert_js_1.exists)(this);
	        this.iHash.update(buf);
	        return this;
	    }
	    digestInto(out) {
	        (0, _assert_js_1.exists)(this);
	        (0, _assert_js_1.bytes)(out, this.outputLen);
	        this.finished = true;
	        this.iHash.digestInto(out);
	        this.oHash.update(out);
	        this.oHash.digestInto(out);
	        this.destroy();
	    }
	    digest() {
	        const out = new Uint8Array(this.oHash.outputLen);
	        this.digestInto(out);
	        return out;
	    }
	    _cloneInto(to) {
	        // Create new instance without calling constructor since key already in state and we don't know it.
	        to || (to = Object.create(Object.getPrototypeOf(this), {}));
	        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
	        to = to;
	        to.finished = finished;
	        to.destroyed = destroyed;
	        to.blockLen = blockLen;
	        to.outputLen = outputLen;
	        to.oHash = oHash._cloneInto(to.oHash);
	        to.iHash = iHash._cloneInto(to.iHash);
	        return to;
	    }
	    destroy() {
	        this.destroyed = true;
	        this.oHash.destroy();
	        this.iHash.destroy();
	    }
	}
	exports.HMAC = HMAC;
	/**
	 * HMAC: RFC2104 message authentication code.
	 * @param hash - function that would be used e.g. sha256
	 * @param key - message key
	 * @param message - message data
	 */
	const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
	exports.hmac = hmac;
	exports.hmac.create = (hash, key) => new HMAC(hash, key);
	
} (hmac));

Object.defineProperty(_shortw_utils, "__esModule", { value: true });
_shortw_utils.createCurve = _shortw_utils.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = hmac;
const utils_1$o = utils$b;
const weierstrass_js_1 = weierstrass;
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1$o.concatBytes)(...msgs)),
        randomBytes: utils_1$o.randomBytes,
    };
}
_shortw_utils.getHash = getHash;
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
_shortw_utils.createCurve = createCurve;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
	/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	const sha256_1 = sha256;
	const utils_1 = utils$b;
	const modular_js_1 = modular;
	const weierstrass_js_1 = weierstrass;
	const utils_js_1 = utils$a;
	const hash_to_curve_js_1 = hashToCurve;
	const _shortw_utils_js_1 = _shortw_utils;
	const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
	const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
	const _1n = BigInt(1);
	const _2n = BigInt(2);
	const divNearest = (a, b) => (a + b / _2n) / b;
	/**
	 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
	 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
	 */
	function sqrtMod(y) {
	    const P = secp256k1P;
	    // prettier-ignore
	    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
	    // prettier-ignore
	    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
	    const b2 = (y * y * y) % P; // x^3, 11
	    const b3 = (b2 * b2 * y) % P; // x^7
	    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
	    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
	    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
	    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
	    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
	    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
	    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
	    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
	    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
	    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
	    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
	    const root = (0, modular_js_1.pow2)(t2, _2n, P);
	    if (!Fp.eql(Fp.sqr(root), y))
	        throw new Error('Cannot find square root');
	    return root;
	}
	const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
	exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
	    a: BigInt(0), // equation params: a, b
	    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
	    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
	    n: secp256k1N, // Curve order, total count of valid points in the field
	    // Base point (x, y) aka generator point
	    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
	    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
	    h: BigInt(1), // Cofactor
	    lowS: true, // Allow only low-S signatures by default in sign() and verify()
	    /**
	     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
	     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
	     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
	     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
	     */
	    endo: {
	        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
	        splitScalar: (k) => {
	            const n = secp256k1N;
	            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
	            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
	            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
	            const b2 = a1;
	            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
	            const c1 = divNearest(b2 * k, n);
	            const c2 = divNearest(-b1 * k, n);
	            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
	            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
	            const k1neg = k1 > POW_2_128;
	            const k2neg = k2 > POW_2_128;
	            if (k1neg)
	                k1 = n - k1;
	            if (k2neg)
	                k2 = n - k2;
	            if (k1 > POW_2_128 || k2 > POW_2_128) {
	                throw new Error('splitScalar: Endomorphism failed, k=' + k);
	            }
	            return { k1neg, k1, k2neg, k2 };
	        },
	    },
	}, sha256_1.sha256);
	// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
	// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
	const _0n = BigInt(0);
	const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
	const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
	/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
	const TAGGED_HASH_PREFIXES = {};
	function taggedHash(tag, ...messages) {
	    let tagP = TAGGED_HASH_PREFIXES[tag];
	    if (tagP === undefined) {
	        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
	        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
	        TAGGED_HASH_PREFIXES[tag] = tagP;
	    }
	    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
	}
	// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
	const pointToBytes = (point) => point.toRawBytes(true).slice(1);
	const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
	const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
	const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
	const Point = exports.secp256k1.ProjectivePoint;
	const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
	// Calculate point, scalar and bytes
	function schnorrGetExtPubKey(priv) {
	    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
	    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
	    const scalar = p.hasEvenY() ? d_ : modN(-d_);
	    return { scalar: scalar, bytes: pointToBytes(p) };
	}
	/**
	 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
	 * @returns valid point checked for being on-curve
	 */
	function lift_x(x) {
	    if (!fe(x))
	        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.
	    const xx = modP(x * x);
	    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
	    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
	    if (y % _2n !== _0n)
	        y = modP(-y); // Return the unique point P such that x(P) = x and
	    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
	    p.assertValidity();
	    return p;
	}
	/**
	 * Create tagged hash, convert it to bigint, reduce modulo-n.
	 */
	function challenge(...args) {
	    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
	}
	/**
	 * Schnorr public key is just `x` coordinate of Point as per BIP340.
	 */
	function schnorrGetPublicKey(privateKey) {
	    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
	}
	/**
	 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
	 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
	 */
	function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
	    const m = (0, utils_js_1.ensureBytes)('message', message);
	    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
	    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
	    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
	    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
	    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
	    if (k_ === _0n)
	        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
	    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.
	    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
	    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
	    sig.set(rx, 0);
	    sig.set(numTo32b(modN(k + e * d)), 32);
	    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
	    if (!schnorrVerify(sig, m, px))
	        throw new Error('sign: Invalid signature produced');
	    return sig;
	}
	/**
	 * Verifies Schnorr signature.
	 * Will swallow errors & return false except for initial type validation of arguments.
	 */
	function schnorrVerify(signature, message, publicKey) {
	    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
	    const m = (0, utils_js_1.ensureBytes)('message', message);
	    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
	    try {
	        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
	        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
	        if (!fe(r))
	            return false;
	        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
	        if (!ge(s))
	            return false;
	        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
	        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
	        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
	            return false; // -eP == (n-e)P
	        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
	    }
	    catch (error) {
	        return false;
	    }
	}
	exports.schnorr = (() => ({
	    getPublicKey: schnorrGetPublicKey,
	    sign: schnorrSign,
	    verify: schnorrVerify,
	    utils: {
	        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
	        lift_x,
	        pointToBytes,
	        numberToBytesBE: utils_js_1.numberToBytesBE,
	        bytesToNumberBE: utils_js_1.bytesToNumberBE,
	        taggedHash,
	        mod: modular_js_1.mod,
	    },
	}))();
	const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
	    // xNum
	    [
	        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
	        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
	        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
	        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
	    ],
	    // xDen
	    [
	        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
	        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
	        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
	    ],
	    // yNum
	    [
	        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
	        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
	        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
	        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
	    ],
	    // yDen
	    [
	        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
	        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
	        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
	        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
	    ],
	].map((i) => i.map((j) => BigInt(j)))))();
	const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
	    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
	    B: BigInt('1771'),
	    Z: Fp.create(BigInt('-11')),
	}))();
	const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
	    const { x, y } = mapSWU(Fp.create(scalars[0]));
	    return isoMap(x, y);
	}, {
	    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
	    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
	    p: Fp.ORDER,
	    m: 1,
	    k: 128,
	    expand: 'xmd',
	    hash: sha256_1.sha256,
	}))();
	exports.hashToCurve = (() => htf.hashToCurve)();
	exports.encodeToCurve = (() => htf.encodeToCurve)();
	
} (secp256k1));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.secp256k1 = void 0;
	var secp256k1_1 = secp256k1;
	Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function () { return secp256k1_1.secp256k1; } }); 
} (secp256k1$1));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
	const buffer_1 = require$$0$b;
	const secp256k1_1 = secp256k1$1;
	/**
	 * 2^64-1
	 */
	exports.MAX_UINT64 = BigInt('0xffffffffffffffff');
	/**
	 * The max integer that the evm can handle (2^256-1)
	 */
	exports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
	/**
	 * The max integer that the evm can handle (2^256-1) as a bigint
	 * 2^256-1 equals to 340282366920938463463374607431768211455
	 * We use literal value instead of calculated value for compatibility issue.
	 */
	exports.MAX_INTEGER_BIGINT = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');
	exports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;
	exports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);
	/**
	 * 2^256
	 */
	exports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
	/**
	 * Keccak-256 hash of null
	 */
	exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
	/**
	 * Keccak-256 hash of null
	 */
	exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');
	/**
	 * Keccak-256 of an RLP of an empty array
	 */
	exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
	/**
	 * Keccak-256 of an RLP of an empty array
	 */
	exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
	/**
	 * Keccak-256 hash of the RLP of null
	 */
	exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
	/**
	 * Keccak-256 hash of the RLP of null
	 */
	exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');
	/**
	 *  RLP encoded empty string
	 */
	exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);
	exports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
	
} (constants$2));

var units = {};

Object.defineProperty(units, "__esModule", { value: true });
units.GWEI_TO_WEI = void 0;
/** Easy conversion from Gwei to wei */
units.GWEI_TO_WEI = BigInt(1000000000);

var account = {};

var dist$1 = {};

Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.RLP = dist$1.utils = dist$1.decode = dist$1.encode = void 0;
/**
 * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i = 0; i < input.length; i++) {
            const encoded = encode(input[i]);
            output.push(encoded);
            outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
dist$1.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex$2(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex$1(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex$1(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes$1(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (typeof input === 'undefined' || input === null || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
dist$1.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex$2(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes$1(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex$1(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven$1(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed$1(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix$2(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed$1(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed$1(v)) {
            return hexToBytes$1(padToEven$1(stripHexPrefix$2(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes$1(numberToHex$1(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
dist$1.utils = {
    bytesToHex: bytesToHex$2,
    concatBytes,
    hexToBytes: hexToBytes$1,
    utf8ToBytes,
};
dist$1.RLP = { encode, decode };

var keccak$1 = {};

var sha3$2 = {};

var _u64 = {};

Object.defineProperty(_u64, "__esModule", { value: true });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
_u64.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
_u64.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
_u64.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
_u64.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
_u64.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
_u64.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
_u64.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
_u64.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
_u64.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
_u64.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
_u64.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
_u64.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
_u64.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
_u64.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
_u64.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
_u64.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
_u64.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
_u64.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
_u64.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
_u64.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
_u64.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
_u64.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
_u64.default = u64;

Object.defineProperty(sha3$2, "__esModule", { value: true });
sha3$2.shake256 = sha3$2.shake128 = sha3$2.keccak_512 = sha3$2.keccak_384 = sha3$2.keccak_256 = sha3$2.keccak_224 = sha3$2.sha3_512 = sha3$2.sha3_384 = sha3$2.sha3_256 = sha3$2.sha3_224 = sha3$2.Keccak = sha3$2.keccakP = void 0;
const _assert_js_1 = _assert;
const _u64_js_1 = _u64;
const utils_js_1$2 = utils$b;
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
sha3$2.keccakP = keccakP;
class Keccak extends utils_js_1$2.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1$2.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1$2.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
sha3$2.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1$2.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
sha3$2.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
sha3$2.sha3_256 = gen(0x06, 136, 256 / 8);
sha3$2.sha3_384 = gen(0x06, 104, 384 / 8);
sha3$2.sha3_512 = gen(0x06, 72, 512 / 8);
sha3$2.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
sha3$2.keccak_256 = gen(0x01, 136, 256 / 8);
sha3$2.keccak_384 = gen(0x01, 104, 384 / 8);
sha3$2.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1$2.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
sha3$2.shake128 = genShake(0x1f, 168, 128 / 8);
sha3$2.shake256 = genShake(0x1f, 136, 256 / 8);

var utils$9 = {exports: {}};

utils$9.exports;

(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
	const _assert_1 = __importDefault(_assert);
	const utils_1 = utils$b;
	const assertBool = _assert_1.default.bool;
	exports.assertBool = assertBool;
	const assertBytes = _assert_1.default.bytes;
	exports.assertBytes = assertBytes;
	var utils_2 = utils$b;
	Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
	Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
	Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
	Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
	Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
	// buf.toString('utf8') -> bytesToUtf8(buf)
	function bytesToUtf8(data) {
	    if (!(data instanceof Uint8Array)) {
	        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
	    }
	    return new TextDecoder().decode(data);
	}
	exports.bytesToUtf8 = bytesToUtf8;
	function hexToBytes(data) {
	    const sliced = data.startsWith("0x") ? data.substring(2) : data;
	    return (0, utils_1.hexToBytes)(sliced);
	}
	exports.hexToBytes = hexToBytes;
	// buf.equals(buf2) -> equalsBytes(buf, buf2)
	function equalsBytes(a, b) {
	    if (a.length !== b.length) {
	        return false;
	    }
	    for (let i = 0; i < a.length; i++) {
	        if (a[i] !== b[i]) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.equalsBytes = equalsBytes;
	// Internal utils
	function wrapHash(hash) {
	    return (msg) => {
	        _assert_1.default.bytes(msg);
	        return hash(msg);
	    };
	}
	exports.wrapHash = wrapHash;
	// TODO(v3): switch away from node crypto, remove this unnecessary variable.
	exports.crypto = (() => {
	    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
	    const nodeRequire = typeof commonjsRequire === "function" &&
	        commonjsRequire.bind(module);
	    return {
	        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
	        web: webCrypto
	    };
	})(); 
} (utils$9, utils$9.exports));

var utilsExports$1 = utils$9.exports;

Object.defineProperty(keccak$1, "__esModule", { value: true });
keccak$1.keccak512 = keccak$1.keccak384 = keccak$1.keccak256 = keccak$1.keccak224 = void 0;
const sha3_1$1 = sha3$2;
const utils_js_1$1 = utilsExports$1;
keccak$1.keccak224 = (0, utils_js_1$1.wrapHash)(sha3_1$1.keccak_224);
keccak$1.keccak256 = (() => {
    const k = (0, utils_js_1$1.wrapHash)(sha3_1$1.keccak_256);
    k.create = sha3_1$1.keccak_256.create;
    return k;
})();
keccak$1.keccak384 = (0, utils_js_1$1.wrapHash)(sha3_1$1.keccak_384);
keccak$1.keccak512 = (0, utils_js_1$1.wrapHash)(sha3_1$1.keccak_512);

var bytes = {};

var helpers = {};

var internal = {};

/*
The MIT License

Copyright (c) 2016 Nick Dodson. nickdodson.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
 */
Object.defineProperty(internal, "__esModule", { value: true });
internal.isHexString = internal.getKeys = internal.fromAscii = internal.fromUtf8 = internal.toAscii = internal.arrayContainsArray = internal.getBinarySize = internal.padToEven = internal.stripHexPrefix = internal.isHexPrefixed = void 0;
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param str the string input value
 * @return a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
function isHexPrefixed(str) {
    if (typeof str !== 'string') {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
    }
    return str[0] === '0' && str[1] === 'x';
}
internal.isHexPrefixed = isHexPrefixed;
/**
 * Removes '0x' from a given `String` if present
 * @param str the string value
 * @returns the string without 0x prefix
 */
const stripHexPrefix$1 = (str) => {
    if (typeof str !== 'string')
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
    return isHexPrefixed(str) ? str.slice(2) : str;
};
internal.stripHexPrefix = stripHexPrefix$1;
/**
 * Pads a `String` to have an even length
 * @param value
 * @return output
 */
function padToEven(value) {
    let a = value;
    if (typeof a !== 'string') {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
    }
    if (a.length % 2)
        a = `0${a}`;
    return a;
}
internal.padToEven = padToEven;
/**
 * Get the binary size of a string
 * @param str
 * @returns the number of bytes contained within the string
 */
function getBinarySize(str) {
    if (typeof str !== 'string') {
        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
    }
    return Buffer.byteLength(str, 'utf8');
}
internal.getBinarySize = getBinarySize;
/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param superset
 * @param subset
 *
 */
function arrayContainsArray(superset, subset, some) {
    if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
    }
    if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
    }
    return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);
}
internal.arrayContainsArray = arrayContainsArray;
/**
 * Should be called to get ascii from its hex representation
 *
 * @param string in hex
 * @returns ascii string representation of hex value
 */
function toAscii(hex) {
    let str = '';
    let i = 0;
    const l = hex.length;
    if (hex.substring(0, 2) === '0x')
        i = 2;
    for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }
    return str;
}
internal.toAscii = toAscii;
/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @param string
 * @param optional padding
 * @returns hex representation of input string
 */
function fromUtf8(stringValue) {
    const str = Buffer.from(stringValue, 'utf8');
    return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;
}
internal.fromUtf8 = fromUtf8;
/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @param  string
 * @param  optional padding
 * @returns  hex representation of input string
 */
function fromAscii(stringValue) {
    let hex = '';
    for (let i = 0; i < stringValue.length; i++) {
        const code = stringValue.charCodeAt(i);
        const n = code.toString(16);
        hex += n.length < 2 ? `0${n}` : n;
    }
    return `0x${hex}`;
}
internal.fromAscii = fromAscii;
/**
 * Returns the keys from an array of objects.
 * @example
 * ```js
 * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']
 *````
 * @param  params
 * @param  key
 * @param  allowEmpty
 * @returns output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
    if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
    }
    if (typeof key !== 'string') {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
    }
    const result = [];
    for (let i = 0; i < params.length; i++) {
        let value = params[i][key];
        if (allowEmpty === true && !value) {
            value = '';
        }
        else if (typeof value !== 'string') {
            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
        }
        result.push(value);
    }
    return result;
}
internal.getKeys = getKeys;
/**
 * Is the string a hex string.
 *
 * @param  value
 * @param  length
 * @returns  output the string is a hex string
 */
function isHexString(value, length) {
    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
    if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)
        return false;
    return true;
}
internal.isHexString = isHexString;

Object.defineProperty(helpers, "__esModule", { value: true });
helpers.assertIsString = helpers.assertIsArray = helpers.assertIsBuffer = helpers.assertIsHexString = void 0;
const internal_1 = internal;
/**
 * Throws if a string is not hex prefixed
 * @param {string} input string to check hex prefix of
 */
const assertIsHexString = function (input) {
    if (!(0, internal_1.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers.assertIsHexString = assertIsHexString;
/**
 * Throws if input is not a buffer
 * @param {Buffer} input value to check
 */
const assertIsBuffer = function (input) {
    if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers.assertIsBuffer = assertIsBuffer;
/**
 * Throws if input is not an array
 * @param {number[]} input value to check
 */
const assertIsArray = function (input) {
    if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers.assertIsArray = assertIsArray;
/**
 * Throws if input is not a string
 * @param {string} input value to check
 */
const assertIsString = function (input) {
    if (typeof input !== 'string') {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
    }
};
helpers.assertIsString = assertIsString;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
	const helpers_1 = helpers;
	const internal_1 = internal;
	/**
	 * Converts a `Number` into a hex `String`
	 * @param {Number} i
	 * @return {String}
	 */
	const intToHex = function (i) {
	    if (!Number.isSafeInteger(i) || i < 0) {
	        throw new Error(`Received an invalid integer type: ${i}`);
	    }
	    return `0x${i.toString(16)}`;
	};
	exports.intToHex = intToHex;
	/**
	 * Converts an `Number` to a `Buffer`
	 * @param {Number} i
	 * @return {Buffer}
	 */
	const intToBuffer = function (i) {
	    const hex = (0, exports.intToHex)(i);
	    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');
	};
	exports.intToBuffer = intToBuffer;
	/**
	 * Returns a buffer filled with 0s.
	 * @param bytes the number of bytes the buffer should be
	 */
	const zeros = function (bytes) {
	    return Buffer.allocUnsafe(bytes).fill(0);
	};
	exports.zeros = zeros;
	/**
	 * Pads a `Buffer` with zeros till it has `length` bytes.
	 * Truncates the beginning or end of input if its length exceeds `length`.
	 * @param msg the value to pad (Buffer)
	 * @param length the number of bytes the output should be
	 * @param right whether to start padding form the left or right
	 * @return (Buffer)
	 */
	const setLength = function (msg, length, right) {
	    const buf = (0, exports.zeros)(length);
	    if (right) {
	        if (msg.length < length) {
	            msg.copy(buf);
	            return buf;
	        }
	        return msg.slice(0, length);
	    }
	    else {
	        if (msg.length < length) {
	            msg.copy(buf, length - msg.length);
	            return buf;
	        }
	        return msg.slice(-length);
	    }
	};
	/**
	 * Left Pads a `Buffer` with leading zeros till it has `length` bytes.
	 * Or it truncates the beginning if it exceeds.
	 * @param msg the value to pad (Buffer)
	 * @param length the number of bytes the output should be
	 * @return (Buffer)
	 */
	const setLengthLeft = function (msg, length) {
	    (0, helpers_1.assertIsBuffer)(msg);
	    return setLength(msg, length, false);
	};
	exports.setLengthLeft = setLengthLeft;
	/**
	 * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.
	 * it truncates the end if it exceeds.
	 * @param msg the value to pad (Buffer)
	 * @param length the number of bytes the output should be
	 * @return (Buffer)
	 */
	const setLengthRight = function (msg, length) {
	    (0, helpers_1.assertIsBuffer)(msg);
	    return setLength(msg, length, true);
	};
	exports.setLengthRight = setLengthRight;
	/**
	 * Trims leading zeros from a `Buffer`, `String` or `Number[]`.
	 * @param a (Buffer|Array|String)
	 * @return (Buffer|Array|String)
	 */
	const stripZeros = function (a) {
	    let first = a[0];
	    while (a.length > 0 && first.toString() === '0') {
	        a = a.slice(1);
	        first = a[0];
	    }
	    return a;
	};
	/**
	 * Trims leading zeros from a `Buffer`.
	 * @param a (Buffer)
	 * @return (Buffer)
	 */
	const unpadBuffer = function (a) {
	    (0, helpers_1.assertIsBuffer)(a);
	    return stripZeros(a);
	};
	exports.unpadBuffer = unpadBuffer;
	/**
	 * Trims leading zeros from an `Array` (of numbers).
	 * @param a (number[])
	 * @return (number[])
	 */
	const unpadArray = function (a) {
	    (0, helpers_1.assertIsArray)(a);
	    return stripZeros(a);
	};
	exports.unpadArray = unpadArray;
	/**
	 * Trims leading zeros from a hex-prefixed `String`.
	 * @param a (String)
	 * @return (String)
	 */
	const unpadHexString = function (a) {
	    (0, helpers_1.assertIsHexString)(a);
	    a = (0, internal_1.stripHexPrefix)(a);
	    return ('0x' + stripZeros(a));
	};
	exports.unpadHexString = unpadHexString;
	/**
	 * Attempts to turn a value into a `Buffer`.
	 * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects
	 * with a `toArray()` or `toBuffer()` method.
	 * @param v the value
	 */
	const toBuffer = function (v) {
	    if (v === null || v === undefined) {
	        return Buffer.allocUnsafe(0);
	    }
	    if (Buffer.isBuffer(v)) {
	        return Buffer.from(v);
	    }
	    if (Array.isArray(v) || v instanceof Uint8Array) {
	        return Buffer.from(v);
	    }
	    if (typeof v === 'string') {
	        if (!(0, internal_1.isHexString)(v)) {
	            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
	        }
	        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');
	    }
	    if (typeof v === 'number') {
	        return (0, exports.intToBuffer)(v);
	    }
	    if (typeof v === 'bigint') {
	        if (v < BigInt(0)) {
	            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);
	        }
	        let n = v.toString(16);
	        if (n.length % 2)
	            n = '0' + n;
	        return Buffer.from(n, 'hex');
	    }
	    if (v.toArray) {
	        // converts a BN to a Buffer
	        return Buffer.from(v.toArray());
	    }
	    if (v.toBuffer) {
	        return Buffer.from(v.toBuffer());
	    }
	    throw new Error('invalid type');
	};
	exports.toBuffer = toBuffer;
	/**
	 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
	 * @param buf `Buffer` object to convert
	 */
	const bufferToHex = function (buf) {
	    buf = (0, exports.toBuffer)(buf);
	    return '0x' + buf.toString('hex');
	};
	exports.bufferToHex = bufferToHex;
	/**
	 * Converts a {@link Buffer} to a {@link bigint}
	 */
	function bufferToBigInt(buf) {
	    const hex = (0, exports.bufferToHex)(buf);
	    if (hex === '0x') {
	        return BigInt(0);
	    }
	    return BigInt(hex);
	}
	exports.bufferToBigInt = bufferToBigInt;
	/**
	 * Converts a {@link bigint} to a {@link Buffer}
	 */
	function bigIntToBuffer(num) {
	    return (0, exports.toBuffer)('0x' + num.toString(16));
	}
	exports.bigIntToBuffer = bigIntToBuffer;
	/**
	 * Converts a `Buffer` to a `Number`.
	 * @param buf `Buffer` object to convert
	 * @throws If the input number exceeds 53 bits.
	 */
	const bufferToInt = function (buf) {
	    const res = Number(bufferToBigInt(buf));
	    if (!Number.isSafeInteger(res))
	        throw new Error('Number exceeds 53 bits');
	    return res;
	};
	exports.bufferToInt = bufferToInt;
	/**
	 * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.
	 * @param num Signed integer value
	 */
	const fromSigned = function (num) {
	    return BigInt.asIntN(256, bufferToBigInt(num));
	};
	exports.fromSigned = fromSigned;
	/**
	 * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
	 * @param num
	 */
	const toUnsigned = function (num) {
	    return bigIntToBuffer(BigInt.asUintN(256, num));
	};
	exports.toUnsigned = toUnsigned;
	/**
	 * Adds "0x" to a given `String` if it does not already start with "0x".
	 */
	const addHexPrefix = function (str) {
	    if (typeof str !== 'string') {
	        return str;
	    }
	    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;
	};
	exports.addHexPrefix = addHexPrefix;
	/**
	 * Shortens a string  or buffer's hex string representation to maxLength (default 50).
	 *
	 * Examples:
	 *
	 * Input:  '657468657265756d000000000000000000000000000000000000000000000000'
	 * Output: '657468657265756d0000000000000000000000000000000000…'
	 */
	function short(buffer, maxLength = 50) {
	    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString('hex') : buffer;
	    if (bufferStr.length <= maxLength) {
	        return bufferStr;
	    }
	    return bufferStr.slice(0, maxLength) + '…';
	}
	exports.short = short;
	/**
	 * Returns the utf8 string representation from a hex string.
	 *
	 * Examples:
	 *
	 * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'
	 * Input 2: '657468657265756d'
	 * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'
	 *
	 * Output (all 3 input variants): 'ethereum'
	 *
	 * Note that this method is not intended to be used with hex strings
	 * representing quantities in both big endian or little endian notation.
	 *
	 * @param string Hex string, should be `0x` prefixed
	 * @return Utf8 string
	 */
	const toUtf8 = function (hex) {
	    const zerosRegexp = /^(00)+|(00)+$/g;
	    hex = (0, internal_1.stripHexPrefix)(hex);
	    if (hex.length % 2 !== 0) {
	        throw new Error('Invalid non-even hex string input for toUtf8() provided');
	    }
	    const bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');
	    return bufferVal.toString('utf8');
	};
	exports.toUtf8 = toUtf8;
	/**
	 * Converts a `Buffer` or `Array` to JSON.
	 * @param ba (Buffer|Array)
	 * @return (Array|String|null)
	 */
	const baToJSON = function (ba) {
	    if (Buffer.isBuffer(ba)) {
	        return `0x${ba.toString('hex')}`;
	    }
	    else if (ba instanceof Array) {
	        const array = [];
	        for (let i = 0; i < ba.length; i++) {
	            array.push((0, exports.baToJSON)(ba[i]));
	        }
	        return array;
	    }
	};
	exports.baToJSON = baToJSON;
	/**
	 * Checks provided Buffers for leading zeroes and throws if found.
	 *
	 * Examples:
	 *
	 * Valid values: 0x1, 0x, 0x01, 0x1234
	 * Invalid values: 0x0, 0x00, 0x001, 0x0001
	 *
	 * Note: This method is useful for validating that RLP encoded integers comply with the rule that all
	 * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes
	 * @param values An object containing string keys and Buffer values
	 * @throws if any provided value is found to have leading zero bytes
	 */
	const validateNoLeadingZeroes = function (values) {
	    for (const [k, v] of Object.entries(values)) {
	        if (v !== undefined && v.length > 0 && v[0] === 0) {
	            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);
	        }
	    }
	};
	exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
	function arrToBufArr(arr) {
	    if (!Array.isArray(arr)) {
	        return Buffer.from(arr);
	    }
	    return arr.map((a) => arrToBufArr(a));
	}
	exports.arrToBufArr = arrToBufArr;
	function bufArrToArr(arr) {
	    if (!Array.isArray(arr)) {
	        return Uint8Array.from(arr ?? []);
	    }
	    return arr.map((a) => bufArrToArr(a));
	}
	exports.bufArrToArr = bufArrToArr;
	/**
	 * Converts a {@link bigint} to a `0x` prefixed hex string
	 */
	const bigIntToHex = (num) => {
	    return '0x' + num.toString(16);
	};
	exports.bigIntToHex = bigIntToHex;
	/**
	 * Convert value from bigint to an unpadded Buffer
	 * (useful for RLP transport)
	 * @param value value to convert
	 */
	function bigIntToUnpaddedBuffer(value) {
	    return (0, exports.unpadBuffer)(bigIntToBuffer(value));
	}
	exports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;
	function intToUnpaddedBuffer(value) {
	    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));
	}
	exports.intToUnpaddedBuffer = intToUnpaddedBuffer;
	
} (bytes));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
	const rlp_1 = dist$1;
	const keccak_1 = keccak$1;
	const secp256k1_1 = secp256k1$1;
	const utils_1 = utilsExports$1;
	const bytes_1 = bytes;
	const constants_1 = constants$2;
	const helpers_1 = helpers;
	const internal_1 = internal;
	const _0n = BigInt(0);
	class Account {
	    /**
	     * This constructor assigns and validates the values.
	     * Use the static factory methods to assist in creating an Account from varying data types.
	     */
	    constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
	        this.nonce = nonce;
	        this.balance = balance;
	        this.storageRoot = storageRoot;
	        this.codeHash = codeHash;
	        this._validate();
	    }
	    static fromAccountData(accountData) {
	        const { nonce, balance, storageRoot, codeHash } = accountData;
	        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);
	    }
	    static fromRlpSerializedAccount(serialized) {
	        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
	        if (!Array.isArray(values)) {
	            throw new Error('Invalid serialized account input. Must be array');
	        }
	        return this.fromValuesArray(values);
	    }
	    static fromValuesArray(values) {
	        const [nonce, balance, storageRoot, codeHash] = values;
	        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);
	    }
	    _validate() {
	        if (this.nonce < _0n) {
	            throw new Error('nonce must be greater than zero');
	        }
	        if (this.balance < _0n) {
	            throw new Error('balance must be greater than zero');
	        }
	        if (this.storageRoot.length !== 32) {
	            throw new Error('storageRoot must have a length of 32');
	        }
	        if (this.codeHash.length !== 32) {
	            throw new Error('codeHash must have a length of 32');
	        }
	    }
	    /**
	     * Returns a Buffer Array of the raw Buffers for the account, in order.
	     */
	    raw() {
	        return [
	            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
	            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
	            this.storageRoot,
	            this.codeHash,
	        ];
	    }
	    /**
	     * Returns the RLP serialization of the account as a `Buffer`.
	     */
	    serialize() {
	        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
	    }
	    /**
	     * Returns a `Boolean` determining if the account is a contract.
	     */
	    isContract() {
	        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
	    }
	    /**
	     * Returns a `Boolean` determining if the account is empty complying to the definition of
	     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
	     * "An account is considered empty when it has no code and zero nonce and zero balance."
	     */
	    isEmpty() {
	        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
	    }
	}
	exports.Account = Account;
	/**
	 * Checks if the address is a valid. Accepts checksummed addresses too.
	 */
	const isValidAddress = function (hexAddress) {
	    try {
	        (0, helpers_1.assertIsString)(hexAddress);
	    }
	    catch (e) {
	        return false;
	    }
	    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
	};
	exports.isValidAddress = isValidAddress;
	/**
	 * Returns a checksummed address.
	 *
	 * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
	 * has the effect of checksummed addresses for one chain having invalid checksums for others.
	 * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).
	 *
	 * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not
	 * backwards compatible to the original widely adopted checksum format standard introduced in
	 * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.
	 * Usage of this EIP is therefore discouraged unless you have a very targeted use case.
	 */
	const toChecksumAddress = function (hexAddress, eip1191ChainId) {
	    (0, helpers_1.assertIsHexString)(hexAddress);
	    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
	    let prefix = '';
	    if (eip1191ChainId !== undefined) {
	        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
	        prefix = chainId.toString() + '0x';
	    }
	    const buf = Buffer.from(prefix + address, 'utf8');
	    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
	    let ret = '0x';
	    for (let i = 0; i < address.length; i++) {
	        if (parseInt(hash[i], 16) >= 8) {
	            ret += address[i].toUpperCase();
	        }
	        else {
	            ret += address[i];
	        }
	    }
	    return ret;
	};
	exports.toChecksumAddress = toChecksumAddress;
	/**
	 * Checks if the address is a valid checksummed address.
	 *
	 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
	 */
	const isValidChecksumAddress = function (hexAddress, eip1191ChainId) {
	    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
	};
	exports.isValidChecksumAddress = isValidChecksumAddress;
	/**
	 * Generates an address of a newly created contract.
	 * @param from The address which is creating this new address
	 * @param nonce The nonce of the from account
	 */
	const generateAddress = function (from, nonce) {
	    (0, helpers_1.assertIsBuffer)(from);
	    (0, helpers_1.assertIsBuffer)(nonce);
	    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
	        // in RLP we want to encode null in the case of zero nonce
	        // read the RLP documentation for an answer if you dare
	        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
	    }
	    // Only take the lower 160bits of the hash
	    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
	};
	exports.generateAddress = generateAddress;
	/**
	 * Generates an address for a contract created using CREATE2.
	 * @param from The address which is creating this new address
	 * @param salt A salt
	 * @param initCode The init code of the contract being created
	 */
	const generateAddress2 = function (from, salt, initCode) {
	    (0, helpers_1.assertIsBuffer)(from);
	    (0, helpers_1.assertIsBuffer)(salt);
	    (0, helpers_1.assertIsBuffer)(initCode);
	    if (from.length !== 20) {
	        throw new Error('Expected from to be of length 20');
	    }
	    if (salt.length !== 32) {
	        throw new Error('Expected salt to be of length 32');
	    }
	    const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));
	    return (0, bytes_1.toBuffer)(address).slice(-20);
	};
	exports.generateAddress2 = generateAddress2;
	/**
	 * Checks if the private key satisfies the rules of the curve secp256k1.
	 */
	const isValidPrivate = function (privateKey) {
	    return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);
	};
	exports.isValidPrivate = isValidPrivate;
	/**
	 * Checks if the public key satisfies the rules of the curve secp256k1
	 * and the requirements of Ethereum.
	 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
	 * @param sanitize Accept public keys in other formats
	 */
	const isValidPublic = function (publicKey, sanitize = false) {
	    (0, helpers_1.assertIsBuffer)(publicKey);
	    if (publicKey.length === 64) {
	        // Convert to SEC1 for secp256k1
	        // Automatically checks whether point is on curve
	        try {
	            secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));
	            return true;
	        }
	        catch (e) {
	            return false;
	        }
	    }
	    if (!sanitize) {
	        return false;
	    }
	    try {
	        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
	        return true;
	    }
	    catch (e) {
	        return false;
	    }
	};
	exports.isValidPublic = isValidPublic;
	/**
	 * Returns the ethereum address of a given public key.
	 * Accepts "Ethereum public keys" and SEC1 encoded keys.
	 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
	 * @param sanitize Accept public keys in other formats
	 */
	const pubToAddress = function (pubKey, sanitize = false) {
	    (0, helpers_1.assertIsBuffer)(pubKey);
	    if (sanitize && pubKey.length !== 64) {
	        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));
	    }
	    if (pubKey.length !== 64) {
	        throw new Error('Expected pubKey to be of length 64');
	    }
	    // Only take the lower 160bits of the hash
	    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
	};
	exports.pubToAddress = pubToAddress;
	exports.publicToAddress = exports.pubToAddress;
	/**
	 * Returns the ethereum public key of a given private key.
	 * @param privateKey A private key must be 256 bits wide
	 */
	const privateToPublic = function (privateKey) {
	    (0, helpers_1.assertIsBuffer)(privateKey);
	    // skip the type flag and use the X, Y points
	    return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
	};
	exports.privateToPublic = privateToPublic;
	/**
	 * Returns the ethereum address of a given private key.
	 * @param privateKey A private key must be 256 bits wide
	 */
	const privateToAddress = function (privateKey) {
	    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
	};
	exports.privateToAddress = privateToAddress;
	/**
	 * Converts a public key to the Ethereum format.
	 */
	const importPublic = function (publicKey) {
	    (0, helpers_1.assertIsBuffer)(publicKey);
	    if (publicKey.length !== 64) {
	        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));
	    }
	    return publicKey;
	};
	exports.importPublic = importPublic;
	/**
	 * Returns the zero address.
	 */
	const zeroAddress = function () {
	    const addressLength = 20;
	    const addr = (0, bytes_1.zeros)(addressLength);
	    return (0, bytes_1.bufferToHex)(addr);
	};
	exports.zeroAddress = zeroAddress;
	/**
	 * Checks if a given address is the zero address.
	 */
	const isZeroAddress = function (hexAddress) {
	    try {
	        (0, helpers_1.assertIsString)(hexAddress);
	    }
	    catch (e) {
	        return false;
	    }
	    const zeroAddr = (0, exports.zeroAddress)();
	    return zeroAddr === hexAddress;
	};
	exports.isZeroAddress = isZeroAddress;
	function accountBodyFromSlim(body) {
	    const [nonce, balance, storageRoot, codeHash] = body;
	    return [
	        nonce,
	        balance,
	        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,
	        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash,
	    ];
	}
	exports.accountBodyFromSlim = accountBodyFromSlim;
	const emptyUint8Arr = new Uint8Array(0);
	function accountBodyToSlim(body) {
	    const [nonce, balance, storageRoot, codeHash] = body;
	    return [
	        nonce,
	        balance,
	        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
	        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash,
	    ];
	}
	exports.accountBodyToSlim = accountBodyToSlim;
	/**
	 * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account
	 * @param body Array of 4 Buffer-like items to represent the account
	 * @returns RLP encoded version of the account
	 */
	function accountBodyToRLP(body, couldBeSlim = true) {
	    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
	    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));
	}
	exports.accountBodyToRLP = accountBodyToRLP;
	
} (account));

var address = {};

Object.defineProperty(address, "__esModule", { value: true });
address.Address = void 0;
const account_1 = account;
const bytes_1$2 = bytes;
/**
 * Handling and generating Ethereum addresses
 */
class Address {
    constructor(buf) {
        if (buf.length !== 20) {
            throw new Error('Invalid address length');
        }
        this.buf = buf;
    }
    /**
     * Returns the zero address.
     */
    static zero() {
        return new Address((0, bytes_1$2.zeros)(20));
    }
    /**
     * Returns an Address object from a hex-encoded string.
     * @param str - Hex-encoded address
     */
    static fromString(str) {
        if (!(0, account_1.isValidAddress)(str)) {
            throw new Error('Invalid address');
        }
        return new Address((0, bytes_1$2.toBuffer)(str));
    }
    /**
     * Returns an address for a given public key.
     * @param pubKey The two points of an uncompressed key
     */
    static fromPublicKey(pubKey) {
        if (!Buffer.isBuffer(pubKey)) {
            throw new Error('Public key should be Buffer');
        }
        const buf = (0, account_1.pubToAddress)(pubKey);
        return new Address(buf);
    }
    /**
     * Returns an address for a given private key.
     * @param privateKey A private key must be 256 bits wide
     */
    static fromPrivateKey(privateKey) {
        if (!Buffer.isBuffer(privateKey)) {
            throw new Error('Private key should be Buffer');
        }
        const buf = (0, account_1.privateToAddress)(privateKey);
        return new Address(buf);
    }
    /**
     * Generates an address for a newly created contract.
     * @param from The address which is creating this new address
     * @param nonce The nonce of the from account
     */
    static generate(from, nonce) {
        if (typeof nonce !== 'bigint') {
            throw new Error('Expected nonce to be a bigint');
        }
        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1$2.bigIntToBuffer)(nonce)));
    }
    /**
     * Generates an address for a contract created using CREATE2.
     * @param from The address which is creating this new address
     * @param salt A salt
     * @param initCode The init code of the contract being created
     */
    static generate2(from, salt, initCode) {
        if (!Buffer.isBuffer(salt)) {
            throw new Error('Expected salt to be a Buffer');
        }
        if (!Buffer.isBuffer(initCode)) {
            throw new Error('Expected initCode to be a Buffer');
        }
        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
    }
    /**
     * Is address equal to another.
     */
    equals(address) {
        return this.buf.equals(address.buf);
    }
    /**
     * Is address zero.
     */
    isZero() {
        return this.equals(Address.zero());
    }
    /**
     * True if address is in the address range defined
     * by EIP-1352
     */
    isPrecompileOrSystemAddress() {
        const address = (0, bytes_1$2.bufferToBigInt)(this.buf);
        const rangeMin = BigInt(0);
        const rangeMax = BigInt('0xffff');
        return address >= rangeMin && address <= rangeMax;
    }
    /**
     * Returns hex encoding of address.
     */
    toString() {
        return '0x' + this.buf.toString('hex');
    }
    /**
     * Returns Buffer representation of address.
     */
    toBuffer() {
        return Buffer.from(this.buf);
    }
}
address.Address = Address;

var withdrawal = {};

var types$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toType = exports.TypeOutput = void 0;
	const bytes_1 = bytes;
	const internal_1 = internal;
	/**
	 * Type output options
	 */
	var TypeOutput;
	(function (TypeOutput) {
	    TypeOutput[TypeOutput["Number"] = 0] = "Number";
	    TypeOutput[TypeOutput["BigInt"] = 1] = "BigInt";
	    TypeOutput[TypeOutput["Buffer"] = 2] = "Buffer";
	    TypeOutput[TypeOutput["PrefixedHexString"] = 3] = "PrefixedHexString";
	})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
	function toType(input, outputType) {
	    if (input === null) {
	        return null;
	    }
	    if (input === undefined) {
	        return undefined;
	    }
	    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {
	        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
	    }
	    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {
	        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
	    }
	    const output = (0, bytes_1.toBuffer)(input);
	    switch (outputType) {
	        case TypeOutput.Buffer:
	            return output;
	        case TypeOutput.BigInt:
	            return (0, bytes_1.bufferToBigInt)(output);
	        case TypeOutput.Number: {
	            const bigInt = (0, bytes_1.bufferToBigInt)(output);
	            if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
	                throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');
	            }
	            return Number(bigInt);
	        }
	        case TypeOutput.PrefixedHexString:
	            return (0, bytes_1.bufferToHex)(output);
	        default:
	            throw new Error('unknown outputType');
	    }
	}
	exports.toType = toType;
	
} (types$1));

Object.defineProperty(withdrawal, "__esModule", { value: true });
withdrawal.Withdrawal = void 0;
const address_1$2 = address;
const bytes_1$1 = bytes;
const types_1$1 = types$1;
/**
 * Representation of EIP-4895 withdrawal data
 */
class Withdrawal {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
     */
    constructor(index, validatorIndex, address, 
    /**
     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot
     */
    amount) {
        this.index = index;
        this.validatorIndex = validatorIndex;
        this.address = address;
        this.amount = amount;
    }
    static fromWithdrawalData(withdrawalData) {
        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData, } = withdrawalData;
        const index = (0, types_1$1.toType)(indexData, types_1$1.TypeOutput.BigInt);
        const validatorIndex = (0, types_1$1.toType)(validatorIndexData, types_1$1.TypeOutput.BigInt);
        const address = new address_1$2.Address((0, types_1$1.toType)(addressData, types_1$1.TypeOutput.Buffer));
        const amount = (0, types_1$1.toType)(amountData, types_1$1.TypeOutput.BigInt);
        return new Withdrawal(index, validatorIndex, address, amount);
    }
    static fromValuesArray(withdrawalArray) {
        if (withdrawalArray.length !== 4) {
            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
        }
        const [index, validatorIndex, address, amount] = withdrawalArray;
        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });
    }
    /**
     * Convert a withdrawal to a buffer array
     * @param withdrawal the withdrawal to convert
     * @returns buffer array of the withdrawal
     */
    static toBufferArray(withdrawal) {
        const { index, validatorIndex, address, amount } = withdrawal;
        const indexBuffer = (0, types_1$1.toType)(index, types_1$1.TypeOutput.BigInt) === BigInt(0)
            ? Buffer.alloc(0)
            : (0, types_1$1.toType)(index, types_1$1.TypeOutput.Buffer);
        const validatorIndexBuffer = (0, types_1$1.toType)(validatorIndex, types_1$1.TypeOutput.BigInt) === BigInt(0)
            ? Buffer.alloc(0)
            : (0, types_1$1.toType)(validatorIndex, types_1$1.TypeOutput.Buffer);
        let addressBuffer;
        if (address instanceof address_1$2.Address) {
            addressBuffer = address.buf;
        }
        else {
            addressBuffer = (0, types_1$1.toType)(address, types_1$1.TypeOutput.Buffer);
        }
        const amountBuffer = (0, types_1$1.toType)(amount, types_1$1.TypeOutput.BigInt) === BigInt(0)
            ? Buffer.alloc(0)
            : (0, types_1$1.toType)(amount, types_1$1.TypeOutput.Buffer);
        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];
    }
    raw() {
        return Withdrawal.toBufferArray(this);
    }
    toValue() {
        return {
            index: this.index,
            validatorIndex: this.validatorIndex,
            address: this.address.buf,
            amount: this.amount,
        };
    }
    toJSON() {
        return {
            index: (0, bytes_1$1.bigIntToHex)(this.index),
            validatorIndex: (0, bytes_1$1.bigIntToHex)(this.validatorIndex),
            address: '0x' + this.address.buf.toString('hex'),
            amount: (0, bytes_1$1.bigIntToHex)(this.amount),
        };
    }
}
withdrawal.Withdrawal = Withdrawal;

var signature = {};

Object.defineProperty(signature, "__esModule", { value: true });
signature.hashPersonalMessage = signature.isValidSignature = signature.fromRpcSig = signature.toCompactSig = signature.toRpcSig = signature.ecrecover = signature.ecsign = void 0;
const keccak_1 = keccak$1;
const secp256k1_1 = secp256k1$1;
const bytes_1 = bytes;
const constants_1$g = constants$2;
const helpers_1 = helpers;
/**
 * Returns the ECDSA signature of a message hash.
 *
 * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value
 * accordingly, otherwise return a "static" `v` just derived from the `recovery` bit
 */
function ecsign(msgHash, privateKey, chainId) {
    const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);
    const buf = sig.toCompactRawBytes();
    const r = Buffer.from(buf.slice(0, 32));
    const s = Buffer.from(buf.slice(32, 64));
    const v = chainId === undefined
        ? BigInt(sig.recovery + 27)
        : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
    return { r, s, v };
}
signature.ecsign = ecsign;
function calculateSigRecovery(v, chainId) {
    if (v === BigInt(0) || v === BigInt(1))
        return v;
    if (chainId === undefined) {
        return v - BigInt(27);
    }
    return v - (chainId * BigInt(2) + BigInt(35));
}
function isValidSigRecovery(recovery) {
    return recovery === BigInt(0) || recovery === BigInt(1);
}
/**
 * ECDSA public key recovery from signature.
 * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions
 * @returns Recovered public key
 */
const ecrecover = function (msgHash, v, r, s, chainId) {
    const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
    const recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
    const senderPubKey = sig.recoverPublicKey(msgHash);
    return Buffer.from(senderPubKey.toRawBytes(false).slice(1));
};
signature.ecrecover = ecrecover;
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions
 * @returns Signature
 */
const toRpcSig = function (v, r, s, chainId) {
    const recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
};
signature.toRpcSig = toRpcSig;
/**
 * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).
 * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions
 * @returns Signature
 */
const toCompactSig = function (v, r, s, chainId) {
    const recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    let ss = s;
    if ((v > BigInt(28) && v % BigInt(2) === BigInt(1)) || v === BigInt(1) || v === BigInt(28)) {
        ss = Buffer.from(s);
        ss[0] |= 0x80;
    }
    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
};
signature.toCompactSig = toCompactSig;
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 *
 * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)
 * `v + 27` is returned for the `v` value
 * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes
 * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.
 */
const fromRpcSig = function (sig) {
    const buf = (0, bytes_1.toBuffer)(sig);
    let r;
    let s;
    let v;
    if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));
    }
    else if (buf.length === 64) {
        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
        s[0] &= 0x7f;
    }
    else {
        throw new Error('Invalid signature length');
    }
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v = v + BigInt(27);
    }
    return {
        v,
        r,
        s,
    };
};
signature.fromRpcSig = fromRpcSig;
/**
 * Validate a ECDSA signature.
 * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
const isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    const rBigInt = (0, bytes_1.bufferToBigInt)(r);
    const sBigInt = (0, bytes_1.bufferToBigInt)(s);
    if (rBigInt === BigInt(0) ||
        rBigInt >= constants_1$g.SECP256K1_ORDER ||
        sBigInt === BigInt(0) ||
        sBigInt >= constants_1$g.SECP256K1_ORDER) {
        return false;
    }
    if (homesteadOrLater && sBigInt >= constants_1$g.SECP256K1_ORDER_DIV_2) {
        return false;
    }
    return true;
};
signature.isValidSignature = isValidSignature;
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
const hashPersonalMessage = function (message) {
    (0, helpers_1.assertIsBuffer)(message);
    const prefix = Buffer.from(`\u0019Ethereum Signed Message:\n${message.length}`, 'utf-8');
    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));
};
signature.hashPersonalMessage = hashPersonalMessage;

var encoding = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;
	// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/
	/**
	 *
	 * @param s byte sequence
	 * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node
	 *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)
	 */
	const hasTerminator = (nibbles) => {
	    return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;
	};
	exports.hasTerminator = hasTerminator;
	const nibblesToBytes = (nibbles, bytes) => {
	    for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {
	        bytes[bi] = (nibbles[ni] << 4) | nibbles[ni + 1];
	    }
	};
	exports.nibblesToBytes = nibblesToBytes;
	const nibblesToCompactBytes = (nibbles) => {
	    let terminator = 0;
	    if ((0, exports.hasTerminator)(nibbles)) {
	        terminator = 1;
	        // Remove the terminator from the sequence
	        nibbles = nibbles.subarray(0, nibbles.length - 1);
	    }
	    const buf = new Uint8Array(nibbles.length / 2 + 1);
	    // Shift the terminator info into the first nibble of buf[0]
	    buf[0] = terminator << 5;
	    // If odd length, then add that flag into the first nibble and put the odd nibble to
	    // second part of buf[0] which otherwise will be left padded with a 0
	    if ((nibbles.length & 1) === 1) {
	        buf[0] |= 1 << 4;
	        buf[0] |= nibbles[0];
	        nibbles = nibbles.subarray(1);
	    }
	    // create bytes out of the rest even nibbles
	    (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));
	    return buf;
	};
	exports.nibblesToCompactBytes = nibblesToCompactBytes;
	const bytesToNibbles = (str) => {
	    const l = str.length * 2 + 1;
	    const nibbles = new Uint8Array(l);
	    for (let i = 0; i < str.length; i++) {
	        const b = str[i];
	        nibbles[i * 2] = b / 16;
	        nibbles[i * 2 + 1] = b % 16;
	    }
	    // This will get removed from calling function if the first nibble
	    // indicates that terminator is not present
	    nibbles[l - 1] = 16;
	    return nibbles;
	};
	exports.bytesToNibbles = bytesToNibbles;
	const compactBytesToNibbles = (compact) => {
	    if (compact.length === 0) {
	        return compact;
	    }
	    let base = (0, exports.bytesToNibbles)(compact);
	    // delete terminator flag if terminator flag was not in first nibble
	    if (base[0] < 2) {
	        base = base.subarray(0, base.length - 1);
	    }
	    // chop the terminator nibble and the even padding (if there is one)
	    // i.e.  chop 2 left nibbles when even else 1 when odd
	    const chop = 2 - (base[0] & 1);
	    return base.subarray(chop);
	};
	exports.compactBytesToNibbles = compactBytesToNibbles;
	/**
	 * A test helper to generates compact path for a subset of key bytes
	 *
	 * TODO: Commenting the code for now as this seems to be helper function
	 * (from geth codebase )
	 *
	 */
	//
	//
	// export const getPathTo = (tillBytes: number, key: Buffer) => {
	//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)
	//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length
	//   // This seems to be a test helper to generate paths so correctness of this isn't necessary
	//   hexNibbles[hexNibbles.length - 1] = 0
	//   const compactBytes = nibblesToCompactBytes(hexNibbles)
	//   return [Buffer.from(compactBytes)]
	// }
	
} (encoding));

var asyncEventEmitter = {};

/**
 * Ported to Typescript from original implementation below:
 * https://github.com/ahultgren/async-eventemitter -- MIT licensed
 *
 * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed
 * that was contributed to Definitely Typed below:
 * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter
 */
Object.defineProperty(asyncEventEmitter, "__esModule", { value: true });
asyncEventEmitter.AsyncEventEmitter = void 0;
const events_1 = require$$0$e;
async function runInSeries(context, tasks, data) {
    let error;
    for await (const task of tasks) {
        try {
            if (task.length < 2) {
                //sync
                task.call(context, data);
            }
            else {
                await new Promise((resolve, reject) => {
                    task.call(context, data, (error) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    });
                });
            }
        }
        catch (e) {
            error = e;
        }
    }
    if (error) {
        throw error;
    }
}
class AsyncEventEmitter extends events_1.EventEmitter {
    emit(event, ...args) {
        let [data, callback] = args;
        const self = this;
        let listeners = self._events[event] ?? [];
        // Optional data argument
        if (callback === undefined && typeof data === 'function') {
            callback = data;
            data = undefined;
        }
        // Special treatment of internal newListener and removeListener events
        if (event === 'newListener' || event === 'removeListener') {
            data = {
                event: data,
                fn: callback,
            };
            callback = undefined;
        }
        // A single listener is just a function not an array...
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);
        return self.listenerCount(event) > 0;
    }
    once(event, listener) {
        const self = this;
        let g;
        if (typeof listener !== 'function') {
            throw new TypeError('listener must be a function');
        }
        // Hack to support set arity
        if (listener.length >= 2) {
            g = function (e, next) {
                self.removeListener(event, g);
                void listener(e, next);
            };
        }
        else {
            g = function (e) {
                self.removeListener(event, g);
                void listener(e, g);
            };
        }
        self.on(event, g);
        return self;
    }
    first(event, listener) {
        let listeners = this._events[event] ?? [];
        // Contract
        if (typeof listener !== 'function') {
            throw new TypeError('listener must be a function');
        }
        // Listeners are not always an array
        if (!Array.isArray(listeners)) {
            this._events[event] = listeners = [listeners];
        }
        listeners.unshift(listener);
        return this;
    }
    before(event, target, listener) {
        return this.beforeOrAfter(event, target, listener);
    }
    after(event, target, listener) {
        return this.beforeOrAfter(event, target, listener, 'after');
    }
    beforeOrAfter(event, target, listener, beforeOrAfter) {
        let listeners = this._events[event] ?? [];
        let i;
        let index;
        const add = beforeOrAfter === 'after' ? 1 : 0;
        // Contract
        if (typeof listener !== 'function') {
            throw new TypeError('listener must be a function');
        }
        if (typeof target !== 'function') {
            throw new TypeError('target must be a function');
        }
        // Listeners are not always an array
        if (!Array.isArray(listeners)) {
            this._events[event] = listeners = [listeners];
        }
        index = listeners.length;
        for (i = listeners.length; i--;) {
            if (listeners[i] === target) {
                index = i + add;
                break;
            }
        }
        listeners.splice(index, 0, listener);
        return this;
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    addListener(event, listener) {
        return super.addListener(event, listener);
    }
    prependListener(event, listener) {
        return super.prependListener(event, listener);
    }
    prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
    }
    removeAllListeners(event) {
        return super.removeAllListeners(event);
    }
    removeListener(event, listener) {
        return super.removeListener(event, listener);
    }
    eventNames() {
        return super.eventNames();
    }
    listeners(event) {
        return super.listeners(event);
    }
    listenerCount(event) {
        return super.listenerCount(event);
    }
    getMaxListeners() {
        return super.getMaxListeners();
    }
    setMaxListeners(maxListeners) {
        return super.setMaxListeners(maxListeners);
    }
}
asyncEventEmitter.AsyncEventEmitter = AsyncEventEmitter;

var lock = {};

Object.defineProperty(lock, "__esModule", { value: true });
lock.Lock = void 0;
// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts
class Lock {
    constructor() {
        this.permits = 1;
        this.promiseResolverQueue = [];
    }
    /**
     * Returns a promise used to wait for a permit to become available. This method should be awaited on.
     * @returns  A promise that gets resolved when execution is allowed to proceed.
     */
    async acquire() {
        if (this.permits > 0) {
            this.permits -= 1;
            return Promise.resolve(true);
        }
        // If there is no permit available, we return a promise that resolves once the semaphore gets
        // signaled enough times that permits is equal to one.
        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
    }
    /**
     * Increases the number of permits by one. If there are other functions waiting, one of them will
     * continue to execute in a future iteration of the event loop.
     */
    release() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
            // eslint-disable-next-line no-console
            console.warn('Lock.permits should never be > 0 when there is someone waiting.');
        }
        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
            // If there is someone else waiting, immediately consume the permit that was released
            // at the beginning of this function and let the waiting function resume.
            this.permits -= 1;
            const nextResolver = this.promiseResolverQueue.shift();
            if (nextResolver) {
                nextResolver(true);
            }
        }
    }
}
lock.Lock = Lock;

var provider = {};

var microFtch = {};

Object.defineProperty(microFtch, "__esModule", { value: true });
microFtch.InvalidStatusCodeError = microFtch.InvalidCertError = void 0;
const DEFAULT_OPT = Object.freeze({
    redirect: true,
    expectStatusCode: 200,
    headers: {},
    full: false,
    keepAlive: true,
    cors: false,
    referrer: false,
    sslAllowSelfSigned: false,
    _redirectCount: 0,
});
class InvalidCertError extends Error {
    constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
    }
}
microFtch.InvalidCertError = InvalidCertError;
class InvalidStatusCodeError extends Error {
    constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
    }
}
microFtch.InvalidStatusCodeError = InvalidStatusCodeError;
function detectType(b, type) {
    if (!type || type === 'text' || type === 'json') {
        try {
            let text = new TextDecoder('utf8', { fatal: true }).decode(b);
            if (type === 'text')
                return text;
            try {
                return JSON.parse(text);
            }
            catch (err) {
                if (type === 'json')
                    throw err;
                return text;
            }
        }
        catch (err) {
            if (type === 'text' || type === 'json')
                throw err;
        }
    }
    return b;
}
let agents = {};
function fetchNode(url, _options) {
    let options = { ...DEFAULT_OPT, ..._options };
    const http = require$$1$6;
    const https = require$$1$7;
    const zlib$1 = zlib;
    const { promisify } = require$$0$f;
    const { resolve: urlResolve } = Url;
    const isSecure = !!/^https/.test(url);
    let opts = {
        method: options.method || 'GET',
        headers: { 'Accept-Encoding': 'gzip, deflate, br' },
    };
    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();
    if (options.keepAlive) {
        const agentOpt = {
            keepAlive: true,
            keepAliveMsecs: 30 * 1000,
            maxFreeSockets: 1024,
            maxCachedSessions: 1024,
        };
        const agentKey = [
            isSecure,
            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),
        ].join();
        opts.agent =
            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
    }
    if (options.type === 'json')
        opts.headers['Content-Type'] = 'application/json';
    if (options.data) {
        if (!options.method)
            opts.method = 'POST';
        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;
    }
    opts.headers = { ...opts.headers, ...options.headers };
    if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
    const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {
            if (options._redirectCount == 10)
                throw new Error('Request failed. Too much redirects.');
            options._redirectCount += 1;
            return await fetchNode(urlResolve(url, res.headers['location']), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
            res.resume();
            throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
            buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers['content-encoding'];
        if (encoding === 'br')
            bytes = await promisify(zlib$1.brotliDecompress)(bytes);
        if (encoding === 'gzip' || encoding === 'deflate')
            bytes = await promisify(zlib$1.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
            return { headers: res.headers, status, body };
        return body;
    };
    return new Promise((resolve, reject) => {
        const handleError = async (err) => {
            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                try {
                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
                }
                catch (e) {
                    if (e && e.fingerprint256) {
                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);
                    }
                }
            }
            reject(err);
        };
        const req = (isSecure ? https : http).request(url, opts, (res) => {
            res.on('error', handleError);
            (async () => {
                try {
                    resolve(await handleRes(res));
                }
                catch (error) {
                    reject(error);
                }
            })();
        });
        req.on('error', handleError);
        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));
        const mfetchSecureConnect = (socket) => {
            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');
            if (!fp256 && socket.isSessionReused())
                return;
            if (pinned.includes(fp256))
                return;
            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
            return req.abort();
        };
        if (options.sslPinnedCertificates) {
            req.on('socket', (socket) => {
                const hasListeners = socket
                    .listeners('secureConnect')
                    .map((i) => (i.name || '').replace('bound ', ''))
                    .includes('mfetchSecureConnect');
                if (hasListeners)
                    return;
                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));
            });
        }
        if (options.keepAlive)
            req.setNoDelay(true);
        if (opts.body)
            req.write(opts.body);
        req.end();
    });
}
const SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));
const FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',
    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',
    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));
async function fetchBrowser(url, _options) {
    let options = { ...DEFAULT_OPT, ..._options };
    const headers = new Headers();
    if (options.type === 'json')
        headers.set('Content-Type', 'application/json');
    let parsed = new URL(url);
    if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set('Authorization', `Basic ${auth}`);
        parsed.username = '';
        parsed.password = '';
    }
    url = '' + parsed;
    for (let k in options.headers) {
        const name = k.toLowerCase();
        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))
            headers.set(k, options.headers[k]);
    }
    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };
    if (!options.referrer)
        opts.referrerPolicy = 'no-referrer';
    if (options.cors)
        opts.mode = 'cors';
    if (options.data) {
        if (!options.method)
            opts.method = 'POST';
        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;
    }
    const res = await fetch(url, opts);
    if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
    if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
    return body;
}
const IS_NODE = !!(typeof process == 'object' &&
    process.versions &&
    process.versions.node &&
    process.versions.v8);
function fetchUrl(url, options) {
    const fn = IS_NODE ? fetchNode : fetchBrowser;
    return fn(url, options);
}
microFtch.default = fetchUrl;

Object.defineProperty(provider, "__esModule", { value: true });
provider.getProvider = provider.fetchFromProvider = void 0;
const micro_ftch_1 = microFtch;
const fetchFromProvider = async (url, params) => {
    const res = await (0, micro_ftch_1.default)(url, {
        headers: {
            'content-type': 'application/json',
        },
        type: 'json',
        data: {
            method: params.method,
            params: params.params,
            jsonrpc: '2.0',
            id: 1,
        },
    });
    return res.result;
};
provider.fetchFromProvider = fetchFromProvider;
const getProvider = (provider) => {
    if (typeof provider === 'string') {
        return provider;
    }
    else if (provider?.connection?.url !== undefined) {
        return provider.connection.url;
    }
    else {
        throw new Error('Must provide valid provider URL or Web3Provider');
    }
};
provider.getProvider = getProvider;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;
	/**
	 * Constants
	 */
	__exportStar(constants$2, exports);
	/**
	 * Units helpers
	 */
	__exportStar(units, exports);
	/**
	 * Account class and helper functions
	 */
	__exportStar(account, exports);
	/**
	 * Address type
	 */
	__exportStar(address, exports);
	/**
	 * Withdrawal type
	 */
	__exportStar(withdrawal, exports);
	/**
	 * ECDSA signature
	 */
	__exportStar(signature, exports);
	/**
	 * Utilities for manipulating Buffers, byte arrays, etc.
	 */
	__exportStar(bytes, exports);
	/**
	 * Helpful TypeScript types
	 */
	__exportStar(types$1, exports);
	/**
	 * Helper function for working with compact encoding
	 */
	__exportStar(encoding, exports);
	/**
	 * Export ethjs-util methods
	 */
	__exportStar(asyncEventEmitter, exports);
	var internal_1 = internal;
	Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function () { return internal_1.arrayContainsArray; } });
	Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function () { return internal_1.fromAscii; } });
	Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function () { return internal_1.fromUtf8; } });
	Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function () { return internal_1.getBinarySize; } });
	Object.defineProperty(exports, "getKeys", { enumerable: true, get: function () { return internal_1.getKeys; } });
	Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function () { return internal_1.isHexPrefixed; } });
	Object.defineProperty(exports, "isHexString", { enumerable: true, get: function () { return internal_1.isHexString; } });
	Object.defineProperty(exports, "padToEven", { enumerable: true, get: function () { return internal_1.padToEven; } });
	Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function () { return internal_1.stripHexPrefix; } });
	Object.defineProperty(exports, "toAscii", { enumerable: true, get: function () { return internal_1.toAscii; } });
	__exportStar(lock, exports);
	__exportStar(provider, exports);
	
} (dist$2));

var dist = {};

var utils$8 = {};

Object.defineProperty(utils$8, "__esModule", { value: true });
const sha3$1 = sha3Exports;
/**
 * Keccak256 hash
 * @param data The data
 */
function keccak256$1(data) {
    return '0x' + sha3$1.keccak_256(toByteArray(data));
}
utils$8.keccak256 = keccak256$1;
/**
 * Adding padding to string on the left
 * @param value The value
 * @param chars The chars
 */
utils$8.padLeft = (value, chars) => {
    const hasPrefix = /^0x/i.test(value) || typeof value === 'number';
    value = value.toString().replace(/^0x/i, '');
    const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;
    return (hasPrefix ? '0x' : '') + new Array(padding).join('0') + value;
};
/**
 * Convert bytes to hex
 * @param bytes The bytes
 */
function bytesToHex$1(bytes) {
    const hex = [];
    for (let i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xf).toString(16));
    }
    return `0x${hex.join('').replace(/^0+/, '')}`;
}
utils$8.bytesToHex = bytesToHex$1;
/**
 * To byte array
 * @param value The value
 */
function toByteArray(value) {
    if (value == null) {
        throw new Error('cannot convert null value to array');
    }
    if (typeof value === 'string') {
        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!match) {
            throw new Error('invalid hexidecimal string');
        }
        if (match[1] !== '0x') {
            throw new Error('hex string must have 0x prefix');
        }
        value = value.substring(2);
        if (value.length % 2) {
            value = '0' + value;
        }
        const result = [];
        for (let i = 0; i < value.length; i += 2) {
            result.push(parseInt(value.substr(i, 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isByteArray(value)) {
        return addSlice(new Uint8Array(value));
    }
    throw new Error('invalid arrayify value');
}
utils$8.toByteArray = toByteArray;
/**
 * Is byte array
 * @param value The value
 */
function isByteArray(value) {
    if (!value ||
        // tslint:disable-next-line: radix
        parseInt(String(value.length)) != value.length ||
        typeof value === 'string') {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        // tslint:disable-next-line: radix
        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
            return false;
        }
    }
    return true;
}
/**
 * Add slice to array
 * @param array The array
 */
function addSlice(array) {
    if (array.slice !== undefined) {
        return array;
    }
    array.slice = () => {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}

Object.defineProperty(dist, "__esModule", { value: true });
const utils_1$n = utils$8;
/**
 * Returns true if the bloom is a valid bloom
 * @param bloom The bloom
 */
function isBloom$1(bloom) {
    if (typeof bloom !== 'string') {
        return false;
    }
    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
    }
    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||
        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
    }
    return false;
}
dist.isBloom = isBloom$1;
/**
 * Returns true if the value is part of the given bloom
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param value The value
 */
function isInBloom$1(bloom, value) {
    if (typeof value === 'object' && value.constructor === Uint8Array) {
        value = utils_1$n.bytesToHex(value);
    }
    const hash = utils_1$n.keccak256(value).replace('0x', '');
    for (let i = 0; i < 12; i += 4) {
        // calculate bit position in bloom filter that must be active
        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +
            parseInt(hash.substr(i + 2, 2), 16)) &
            2047;
        // test if bitpos in bloom is active
        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
        const offset = 1 << bitpos % 4;
        if ((code & offset) !== offset) {
            return false;
        }
    }
    return true;
}
dist.isInBloom = isInBloom$1;
/**
 * Code points to int
 * @param codePoint The code point
 */
function codePointToInt(codePoint) {
    if (codePoint >= 48 && codePoint <= 57) {
        /* ['0'..'9'] -> [0..9] */
        return codePoint - 48;
    }
    if (codePoint >= 65 && codePoint <= 70) {
        /* ['A'..'F'] -> [10..15] */
        return codePoint - 55;
    }
    if (codePoint >= 97 && codePoint <= 102) {
        /* ['a'..'f'] -> [10..15] */
        return codePoint - 87;
    }
    throw new Error('invalid bloom');
}
/**
 * Returns true if the ethereum users address is part of the given bloom.
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param address the address to test
 */
function isUserEthereumAddressInBloom$1(bloom, ethereumAddress) {
    if (!isBloom$1(bloom)) {
        throw new Error('Invalid bloom given');
    }
    if (!isAddress$1(ethereumAddress)) {
        throw new Error(`Invalid ethereum address given: "${ethereumAddress}"`);
    }
    // you have to pad the ethereum address to 32 bytes
    // else the bloom filter does not work
    // this is only if your matching the USERS
    // ethereum address. Contract address do not need this
    // hence why we have 2 methods
    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)
    const address = utils_1$n.padLeft(ethereumAddress, 64);
    return isInBloom$1(bloom, address);
}
dist.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom$1;
/**
 * Returns true if the contract address is part of the given bloom.
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param contractAddress the contract address to test
 */
function isContractAddressInBloom$1(bloom, contractAddress) {
    if (!isBloom$1(bloom)) {
        throw new Error('Invalid bloom given');
    }
    if (!isAddress$1(contractAddress)) {
        throw new Error(`Invalid contract address given: "${contractAddress}"`);
    }
    return isInBloom$1(bloom, contractAddress);
}
dist.isContractAddressInBloom = isContractAddressInBloom$1;
/**
 * Returns true if the topic is part of the given bloom.
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param topic the topic encoded hex
 */
function isTopicInBloom$1(bloom, topic) {
    if (!isBloom$1(bloom)) {
        throw new Error('Invalid bloom given');
    }
    if (!isTopic$1(topic)) {
        throw new Error('Invalid topic');
    }
    return isInBloom$1(bloom, topic);
}
dist.isTopicInBloom = isTopicInBloom$1;
/**
 * Checks if its a valid topic
 * @param topic encoded hex topic
 */
function isTopic$1(topic) {
    if (typeof topic !== 'string') {
        return false;
    }
    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
    }
    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||
        /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
    }
    return false;
}
dist.isTopic = isTopic$1;
/**
 * Is valid address
 * @param address The address
 */
function isAddress$1(address) {
    if (typeof address !== 'string') {
        return false;
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        return true;
    }
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        return true;
    }
    return false;
}
dist.isAddress = isAddress$1;

var keccak = {};

var utils$7 = {exports: {}};

utils$7.exports;

(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
	const _assert_1 = __importDefault(_assert);
	const utils_1 = utils$b;
	const assertBool = _assert_1.default.bool;
	exports.assertBool = assertBool;
	const assertBytes = _assert_1.default.bytes;
	exports.assertBytes = assertBytes;
	var utils_2 = utils$b;
	Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
	Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
	Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
	Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
	Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
	// buf.toString('utf8') -> bytesToUtf8(buf)
	function bytesToUtf8(data) {
	    if (!(data instanceof Uint8Array)) {
	        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
	    }
	    return new TextDecoder().decode(data);
	}
	exports.bytesToUtf8 = bytesToUtf8;
	function hexToBytes(data) {
	    const sliced = data.startsWith("0x") ? data.substring(2) : data;
	    return (0, utils_1.hexToBytes)(sliced);
	}
	exports.hexToBytes = hexToBytes;
	// buf.equals(buf2) -> equalsBytes(buf, buf2)
	function equalsBytes(a, b) {
	    if (a.length !== b.length) {
	        return false;
	    }
	    for (let i = 0; i < a.length; i++) {
	        if (a[i] !== b[i]) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.equalsBytes = equalsBytes;
	// Internal utils
	function wrapHash(hash) {
	    return (msg) => {
	        _assert_1.default.bytes(msg);
	        return hash(msg);
	    };
	}
	exports.wrapHash = wrapHash;
	// TODO(v3): switch away from node crypto, remove this unnecessary variable.
	exports.crypto = (() => {
	    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
	    const nodeRequire = typeof commonjsRequire === "function" &&
	        commonjsRequire.bind(module);
	    return {
	        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
	        web: webCrypto
	    };
	})(); 
} (utils$7, utils$7.exports));

var utilsExports = utils$7.exports;

Object.defineProperty(keccak, "__esModule", { value: true });
keccak.keccak512 = keccak.keccak384 = keccak.keccak256 = keccak.keccak224 = void 0;
const sha3_1 = sha3$2;
const utils_js_1 = utilsExports;
keccak.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
keccak.keccak256 = (() => {
    const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
keccak.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
keccak.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);

/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file utils.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */
var BN$2 = bnExports$2;
var numberToBN = src;
var utf8 = utf8$1;
var ethereumjsUtil = dist$2;
var ethereumBloomFilters = dist;
var { keccak256 } = keccak;
/**
 * Returns true if object is BN, otherwise false
 *
 * @method isBN
 * @param {Object} object
 * @return {Boolean}
 */
var isBN = function (object) {
    return BN$2.isBN(object);
};
/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object} object
 * @return {Boolean}
 */
var isBigNumber = function (object) {
    return object && object.constructor && object.constructor.name === 'BigNumber';
};
/**
 * Takes an input and transforms it into an BN
 *
 * @method toBN
 * @param {Number|String|BN} number, string, HEX string or BN
 * @return {BN} BN
 */
var toBN = function (number) {
    try {
        return numberToBN.apply(null, arguments);
    }
    catch (e) {
        throw new Error(e + ' Given value: "' + number + '"');
    }
};
/**
 * Takes and input transforms it into BN and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BN} number
 * @return {String}
 */
var toTwosComplement = function (number) {
    return '0x' + toBN(number).toTwos(256).toString(16, 64);
};
/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX address
 * @return {Boolean}
 */
var isAddress = function (address) {
    // check if it has the basic requirements of an address
    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
        // If it's ALL lowercase or ALL upppercase
    }
    else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
        return true;
        // Otherwise check each case
    }
    else {
        return checkAddressChecksum(address);
    }
};
/**
 * Checks if the given string is a checksummed address
 *
 * @method checkAddressChecksum
 * @param {String} address the given HEX address
 * @return {Boolean}
 */
var checkAddressChecksum = function (address) {
    // Check each case
    address = address.replace(/^0x/i, '');
    var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '');
    for (var i = 0; i < 40; i++) {
        // the nth letter should be uppercase if the nth digit of casemap is 1
        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
            return false;
        }
    }
    return true;
};
/**
 * Should be called to pad string to expected length
 *
 * @method leftPad
 * @param {String} string to be padded
 * @param {Number} chars that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var leftPad = function (string, chars, sign) {
    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';
    string = string.toString(16).replace(/^0x/i, '');
    var padding = (chars - string.length + 1 >= 0) ? chars - string.length + 1 : 0;
    return (hasPrefix ? '0x' : '') + new Array(padding).join(sign ? sign : "0") + string;
};
/**
 * Should be called to pad string to expected length
 *
 * @method rightPad
 * @param {String} string to be padded
 * @param {Number} chars that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var rightPad = function (string, chars, sign) {
    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';
    string = string.toString(16).replace(/^0x/i, '');
    var padding = (chars - string.length + 1 >= 0) ? chars - string.length + 1 : 0;
    return (hasPrefix ? '0x' : '') + string + (new Array(padding).join(sign ? sign : "0"));
};
/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method utf8ToHex
 * @param {String} str
 * @returns {String} hex representation of input string
 */
var utf8ToHex = function (str) {
    str = utf8.encode(str);
    var hex = "";
    // remove \u0000 padding from either side
    str = str.replace(/^(?:\u0000)*/, '');
    str = str.split("").reverse().join("");
    str = str.replace(/^(?:\u0000)*/, '');
    str = str.split("").reverse().join("");
    for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        // if (code !== 0) {
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
        // }
    }
    return "0x" + hex;
};
/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method hexToUtf8
 * @param {String} hex
 * @returns {String} ascii string representation of hex value
 */
var hexToUtf8 = function (hex) {
    if (!isHexStrict(hex))
        throw new Error('The parameter "' + hex + '" must be a valid HEX string.');
    var str = "";
    var code = 0;
    hex = hex.replace(/^0x/i, '');
    // remove 00 padding from either side
    hex = hex.replace(/^(?:00)*/, '');
    hex = hex.split("").reverse().join("");
    hex = hex.replace(/^(?:00)*/, '');
    hex = hex.split("").reverse().join("");
    var l = hex.length;
    for (var i = 0; i < l; i += 2) {
        code = parseInt(hex.slice(i, i + 2), 16);
        // if (code !== 0) {
        str += String.fromCharCode(code);
        // }
    }
    return utf8.decode(str);
};
/**
 * Converts value to it's number representation.
 * However, if the value is larger than the maximum safe integer, returns the value as a string.
 *
 * @method hexToNumber
 * @param {String|Number|BN} value
 * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow
 * @return {Number|String}
 */
var hexToNumber = function (value, bigIntOnOverflow = false) {
    if (!value) {
        return value;
    }
    if (typeof value === 'string' && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
    }
    const n = toBN(value);
    if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {
        return BigInt(n);
    }
    return n.toNumber();
};
/**
 * Converts value to it's decimal representation in string
 *
 * @method hexToNumberString
 * @param {String|Number|BN} value
 * @return {String}
 */
var hexToNumberString = function (value) {
    if (!value)
        return value;
    if (typeof value === 'string' && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
    }
    return toBN(value).toString(10);
};
/**
 * Converts value to it's hex representation
 *
 * @method numberToHex
 * @param {String|Number|BN} value
 * @return {String}
 */
var numberToHex = function (value) {
    if ((value === null || value === undefined)) {
        return value;
    }
    if (!isFinite(value) && !isHexStrict(value)) {
        throw new Error('Given input "' + value + '" is not a number.');
    }
    var number = toBN(value);
    var result = number.toString(16);
    return number.lt(new BN$2(0)) ? '-0x' + result.slice(1) : '0x' + result;
};
/**
 * Convert a byte array to a hex string
 *
 * Note: Implementation from crypto-js
 *
 * @method bytesToHex
 * @param {Array} bytes
 * @return {String} the hex string
 */
var bytesToHex = function (bytes) {
    for (var hex = [], i = 0; i < bytes.length; i++) {
        /* jshint ignore:start */
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
        /* jshint ignore:end */
    }
    return '0x' + hex.join("");
};
/**
 * Convert a hex string to a byte array
 *
 * Note: Implementation from crypto-js
 *
 * @method hexToBytes
 * @param {string} hex
 * @return {Array} the byte array
 */
var hexToBytes = function (hex) {
    hex = hex.toString(16);
    if (!isHexStrict(hex)) {
        throw new Error('Given value "' + hex + '" is not a valid hex string.');
    }
    hex = hex.replace(/^0x/i, '');
    for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.slice(c, c + 2), 16));
    return bytes;
};
/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BN|Object|Buffer} value
 * @param {Boolean} returnType
 * @return {String}
 */
var toHex = function (value, returnType) {
    /*jshint maxcomplexity: false */
    if (isAddress(value)) {
        return returnType ? 'address' : '0x' + value.toLowerCase().replace(/^0x/i, '');
    }
    if (typeof value === 'boolean') {
        return returnType ? 'bool' : value ? '0x01' : '0x00';
    }
    if (Buffer.isBuffer(value)) {
        return '0x' + value.toString('hex');
    }
    if (typeof value === 'object' && !!value && !isBigNumber(value) && !isBN(value)) {
        return returnType ? 'string' : utf8ToHex(JSON.stringify(value));
    }
    // if its a negative number, pass it through numberToHex
    if (typeof value === 'string') {
        if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {
            return returnType ? 'int256' : numberToHex(value);
        }
        else if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {
            return returnType ? 'bytes' : value;
        }
        else if (!isFinite(value)) {
            return returnType ? 'string' : utf8ToHex(value);
        }
    }
    return returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value);
};
/**
 * Check if string is HEX, requires a 0x in front
 *
 * @method isHexStrict
 * @param {String} hex to be checked
 * @returns {Boolean}
 */
var isHexStrict = function (hex) {
    return ((typeof hex === 'string' || typeof hex === 'number') && /^(-)?0x[0-9a-f]*$/i.test(hex));
};
/**
 * Check if string is HEX
 *
 * @method isHex
 * @param {String} hex to be checked
 * @returns {Boolean}
 */
var isHex = function (hex) {
    return ((typeof hex === 'string' || typeof hex === 'number') && /^(-0x|0x)?[0-9a-f]*$/i.test(hex));
};
/**
 * Remove 0x prefix from string
 *
 * @method stripHexPrefix
 * @param {String} str to be checked
 * @returns {String}
 */
var stripHexPrefix = function (str) {
    if (str !== 0 && isHex(str))
        return str.replace(/^(-)?0x/i, '$1');
    return str;
};
/**
 * Returns true if given string is a valid Ethereum block header bloom.
 *
 * @method isBloom
 * @param {String} bloom encoded bloom filter
 * @return {Boolean}
 */
var isBloom = function (bloom) {
    return ethereumBloomFilters.isBloom(bloom);
};
/**
 * Returns true if the ethereum users address is part of the given bloom
 * note: false positives are possible.
 *
 * @method isUserEthereumAddressInBloom
 * @param {String} ethereumAddress encoded bloom filter
 * @param {String} bloom ethereum addresss
 * @return {Boolean}
 */
var isUserEthereumAddressInBloom = function (bloom, ethereumAddress) {
    return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);
};
/**
 * Returns true if the contract address is part of the given bloom
 * note: false positives are possible.
 *
 * @method isUserEthereumAddressInBloom
 * @param {String} bloom encoded bloom filter
 * @param {String} contractAddress contract addresss
 * @return {Boolean}
 */
var isContractAddressInBloom = function (bloom, contractAddress) {
    return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);
};
/**
 * Returns true if given string is a valid log topic.
 *
 * @method isTopic
 * @param {String} topic encoded topic
 * @return {Boolean}
 */
var isTopic = function (topic) {
    return ethereumBloomFilters.isTopic(topic);
};
/**
 * Returns true if the topic is part of the given bloom
 * note: false positives are possible.
 *
 * @method isTopicInBloom
 * @param {String} bloom encoded bloom filter
 * @param {String} topic encoded topic
 * @return {Boolean}
 */
var isTopicInBloom = function (bloom, topic) {
    return ethereumBloomFilters.isTopicInBloom(bloom, topic);
};
/**
 * Returns true if the value is part of the given bloom
 * note: false positives are possible.
 *
 * @method isInBloom
 * @param {String} bloom encoded bloom filter
 * @param {String | Uint8Array} topic encoded value
 * @return {Boolean}
 */
var isInBloom = function (bloom, topic) {
    return ethereumBloomFilters.isInBloom(bloom, topic);
};
/**
 * Hashes values to a sha3 hash using keccak 256
 *
 * To hash a HEX string the hex must have 0x in front.
 *
 * @method sha3
 * @return {String} the sha3 string
 */
var SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
var sha3 = function (value) {
    if (isBN(value)) {
        value = value.toString();
    }
    if (isHexStrict(value) && /^0x/i.test((value).toString())) {
        value = ethereumjsUtil.toBuffer(value);
    }
    else if (typeof value === 'string') {
        // Assume value is an arbitrary string
        value = Buffer.from(value, 'utf-8');
    }
    var returnValue = ethereumjsUtil.bufferToHex(keccak256(value));
    if (returnValue === SHA3_NULL_S) {
        return null;
    }
    else {
        return returnValue;
    }
};
// expose the under the hood keccak256
sha3._Hash = keccak256;
/**
 * @method sha3Raw
 *
 * @param value
 *
 * @returns {string}
 */
var sha3Raw = function (value) {
    value = sha3(value);
    if (value === null) {
        return SHA3_NULL_S;
    }
    return value;
};
/**
 * Auto converts any given value into it's hex representation,
 * then converts hex to number.
 *
 * @method toNumber
 * @param {String|Number|BN} value
 * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow
 * @return {Number|String}
 */
var toNumber = function (value, bigIntOnOverflow = false) {
    return typeof value === 'number' ? value : hexToNumber(toHex(value), bigIntOnOverflow);
};
// 1.x currently accepts 0x... strings, bn.js after update doesn't. it would be a breaking change
var BNwrapped = function (value) {
    // check negative
    if (typeof value == "string" && value.includes("0x")) {
        const [negative, hexValue] = value.toLocaleLowerCase().startsWith('-') ? ["-", value.slice(3)] : ["", value.slice(2)];
        return new BN$2(negative + hexValue, 16);
    }
    else {
        return new BN$2(value);
    }
};
Object.setPrototypeOf(BNwrapped, BN$2);
Object.setPrototypeOf(BNwrapped.prototype, BN$2.prototype);
var utils$6 = {
    BN: BNwrapped,
    isBN: isBN,
    isBigNumber: isBigNumber,
    toBN: toBN,
    isAddress: isAddress,
    isBloom: isBloom,
    isUserEthereumAddressInBloom: isUserEthereumAddressInBloom,
    isContractAddressInBloom: isContractAddressInBloom,
    isTopic: isTopic,
    isTopicInBloom: isTopicInBloom,
    isInBloom: isInBloom,
    checkAddressChecksum: checkAddressChecksum,
    utf8ToHex: utf8ToHex,
    hexToUtf8: hexToUtf8,
    hexToNumber: hexToNumber,
    hexToNumberString: hexToNumberString,
    numberToHex: numberToHex,
    toHex: toHex,
    hexToBytes: hexToBytes,
    bytesToHex: bytesToHex,
    isHex: isHex,
    isHexStrict: isHexStrict,
    stripHexPrefix: stripHexPrefix,
    leftPad: leftPad,
    rightPad: rightPad,
    toTwosComplement: toTwosComplement,
    sha3: sha3,
    sha3Raw: sha3Raw,
    toNumber: toNumber
};

/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file soliditySha3.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */
var BN$1 = bnExports$2;
var utils$5 = utils$6;
var _elementaryName = function (name) {
    /*jshint maxcomplexity:false */
    if (name.startsWith('int[')) {
        return 'int256' + name.slice(3);
    }
    else if (name === 'int') {
        return 'int256';
    }
    else if (name.startsWith('uint[')) {
        return 'uint256' + name.slice(4);
    }
    else if (name === 'uint') {
        return 'uint256';
    }
    else if (name.startsWith('fixed[')) {
        return 'fixed128x128' + name.slice(5);
    }
    else if (name === 'fixed') {
        return 'fixed128x128';
    }
    else if (name.startsWith('ufixed[')) {
        return 'ufixed128x128' + name.slice(6);
    }
    else if (name === 'ufixed') {
        return 'ufixed128x128';
    }
    return name;
};
// Parse N from type<N>
var _parseTypeN = function (type) {
    var typesize = /^\D+(\d+).*$/.exec(type);
    return typesize ? parseInt(typesize[1], 10) : null;
};
// Parse N from type[<N>]
var _parseTypeNArray = function (type) {
    var arraySize = /^\D+\d*\[(\d+)\]$/.exec(type);
    return arraySize ? parseInt(arraySize[1], 10) : null;
};
var _parseNumber = function (arg) {
    var type = typeof arg;
    if (type === 'string') {
        if (utils$5.isHexStrict(arg)) {
            return new BN$1(arg.replace(/0x/i, ''), 16);
        }
        else {
            return new BN$1(arg, 10);
        }
    }
    else if (type === 'number') {
        return new BN$1(arg);
    }
    else if (utils$5.isBigNumber(arg)) {
        return new BN$1(arg.toString(10));
    }
    else if (utils$5.isBN(arg)) {
        return arg;
    }
    else {
        throw new Error(arg + ' is not a number');
    }
};
var _solidityPack = function (type, value, arraySize) {
    /*jshint maxcomplexity:false */
    var size, num;
    type = _elementaryName(type);
    if (type === 'bytes') {
        if (value.replace(/^0x/i, '').length % 2 !== 0) {
            throw new Error('Invalid bytes characters ' + value.length);
        }
        return value;
    }
    else if (type === 'string') {
        return utils$5.utf8ToHex(value);
    }
    else if (type === 'bool') {
        return value ? '01' : '00';
    }
    else if (type.startsWith('address')) {
        if (arraySize) {
            size = 64;
        }
        else {
            size = 40;
        }
        if (!utils$5.isAddress(value)) {
            throw new Error(value + ' is not a valid address, or the checksum is invalid.');
        }
        return utils$5.leftPad(value.toLowerCase(), size);
    }
    size = _parseTypeN(type);
    if (type.startsWith('bytes')) {
        if (!size) {
            throw new Error('bytes[] not yet supported in solidity');
        }
        // must be 32 byte slices when in an array
        if (arraySize) {
            size = 32;
        }
        if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {
            throw new Error('Invalid bytes' + size + ' for ' + value);
        }
        return utils$5.rightPad(value, size * 2);
    }
    else if (type.startsWith('uint')) {
        if ((size % 8) || (size < 8) || (size > 256)) {
            throw new Error('Invalid uint' + size + ' size');
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
            throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());
        }
        if (num.lt(new BN$1(0))) {
            throw new Error('Supplied uint ' + num.toString() + ' is negative');
        }
        return size ? utils$5.leftPad(num.toString('hex'), size / 8 * 2) : num;
    }
    else if (type.startsWith('int')) {
        if ((size % 8) || (size < 8) || (size > 256)) {
            throw new Error('Invalid int' + size + ' size');
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
            throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());
        }
        if (num.lt(new BN$1(0))) {
            return num.toTwos(size).toString('hex');
        }
        else {
            return size ? utils$5.leftPad(num.toString('hex'), size / 8 * 2) : num;
        }
    }
    else {
        // FIXME: support all other types
        throw new Error('Unsupported or invalid type: ' + type);
    }
};
var _processSolidityEncodePackedArgs = function (arg) {
    /*jshint maxcomplexity:false */
    if (Array.isArray(arg)) {
        throw new Error('Autodetection of array types is not supported.');
    }
    var type, value = '';
    var hexArg, arraySize;
    // if type is given
    if (!!arg && typeof arg === 'object' && (arg.hasOwnProperty('v') || arg.hasOwnProperty('t') || arg.hasOwnProperty('value') || arg.hasOwnProperty('type'))) {
        type = arg.hasOwnProperty('t') ? arg.t : arg.type;
        value = arg.hasOwnProperty('v') ? arg.v : arg.value;
        // otherwise try to guess the type
    }
    else {
        type = utils$5.toHex(arg, true);
        value = utils$5.toHex(arg);
        if (!type.startsWith('int') && !type.startsWith('uint')) {
            type = 'bytes';
        }
    }
    if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {
        value = new BN$1(value);
    }
    // get the array size
    if (Array.isArray(value)) {
        arraySize = _parseTypeNArray(type);
        if (arraySize && value.length !== arraySize) {
            throw new Error(type + ' is not matching the given array ' + JSON.stringify(value));
        }
        else {
            arraySize = value.length;
        }
    }
    if (Array.isArray(value)) {
        hexArg = value.map(function (val) {
            return _solidityPack(type, val, arraySize).toString('hex').replace('0x', '');
        });
        return hexArg.join('');
    }
    else {
        hexArg = _solidityPack(type, value, arraySize);
        return hexArg.toString('hex').replace('0x', '');
    }
};
/**
 * Hashes solidity values to a sha3 hash using keccak 256
 *
 * @method soliditySha3
 * @return {Object} the sha3
 */
var soliditySha3$1 = function () {
    /*jshint maxcomplexity:false */
    var args = Array.prototype.slice.call(arguments);
    var hexArgs = args.map(_processSolidityEncodePackedArgs);
    // console.log(args, hexArgs);
    // console.log('0x'+ hexArgs.join(''));
    return utils$5.sha3('0x' + hexArgs.join(''));
};
/**
 * Hashes solidity values to a sha3 hash using keccak 256 but does return the hash of value `null` instead of `null`
 *
 * @method soliditySha3Raw
 * @return {Object} the sha3
 */
var soliditySha3Raw = function () {
    return utils$5.sha3Raw('0x' + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(''));
};
/**
 * Encode packed args to hex
 *
 * @method encodePacked
 * @return {String} the hex encoded arguments
 */
var encodePacked = function () {
    /*jshint maxcomplexity:false */
    var args = Array.prototype.slice.call(arguments);
    var hexArgs = args.map(_processSolidityEncodePackedArgs);
    return '0x' + hexArgs.join('').toLowerCase();
};
var soliditySha3_1 = {
    soliditySha3: soliditySha3$1,
    soliditySha3Raw: soliditySha3Raw,
    encodePacked: encodePacked
};

/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file utils.js
 * @author Marek Kotewicz <marek@parity.io>
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */
var ethjsUnit = lib$1;
var utils$4 = utils$6;
var soliditySha3 = soliditySha3_1;
var randombytes = randombytes$2;
var BN = bnExports$2;
/**
 * Fires an error in an event emitter and callback and returns the eventemitter
 *
 * @method _fireError
 * @param {Object} error a string, a error, or an object with {message, data}
 * @param {Object} emitter
 * @param {Function} reject
 * @param {Function} callback
 * @param {any} optionalData
 * @return {Object} the emitter
 */
var _fireError = function (error, emitter, reject, callback, optionalData) {
    /*jshint maxcomplexity: 10 */
    // add data if given
    if (!!error && typeof error === 'object' && !(error instanceof Error) && error.data) {
        if (!!error.data && typeof error.data === 'object' || Array.isArray(error.data)) {
            error.data = JSON.stringify(error.data, null, 2);
        }
        error = error.message + "\n" + error.data;
    }
    if (typeof error === 'string') {
        error = new Error(error);
    }
    if (typeof callback === 'function') {
        callback(error, optionalData);
    }
    if (typeof reject === 'function') {
        // suppress uncatched error if an error listener is present
        // OR suppress uncatched error if an callback listener is present
        if (emitter &&
            (typeof emitter.listeners === 'function' &&
                emitter.listeners('error').length) || typeof callback === 'function') {
            emitter.catch(function () { });
        }
        // reject later, to be able to return emitter
        setTimeout(function () {
            reject(error);
        }, 1);
    }
    if (emitter && typeof emitter.emit === 'function') {
        // emit later, to be able to return emitter
        setTimeout(function () {
            emitter.emit('error', error, optionalData);
            emitter.removeAllListeners();
        }, 1);
    }
    return emitter;
};
/**
 * Should be used to create full function/event name from json abi
 *
 * @method _jsonInterfaceMethodToString
 * @param {Object} json
 * @return {String} full function/event name
 */
var _jsonInterfaceMethodToString = function (json) {
    if (!!json && typeof json === 'object' && json.name && json.name.indexOf('(') !== -1) {
        return json.name;
    }
    return json.name + '(' + _flattenTypes(false, json.inputs).join(',') + ')';
};
/**
 * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings
 *
 * @method _flattenTypes
 * @param {bool} includeTuple
 * @param {Object} puts
 * @return {Array} parameters as strings
 */
var _flattenTypes = function (includeTuple, puts) {
    // console.log("entered _flattenTypes. inputs/outputs: " + puts)
    var types = [];
    puts.forEach(function (param) {
        if (typeof param.components === 'object') {
            if (param.type.substring(0, 5) !== 'tuple') {
                throw new Error('components found but type is not tuple; report on GitHub');
            }
            var suffix = '';
            var arrayBracket = param.type.indexOf('[');
            if (arrayBracket >= 0) {
                suffix = param.type.substring(arrayBracket);
            }
            var result = _flattenTypes(includeTuple, param.components);
            // console.log("result should have things: " + result)
            if (Array.isArray(result) && includeTuple) {
                // console.log("include tuple word, and its an array. joining...: " + result.types)
                types.push('tuple(' + result.join(',') + ')' + suffix);
            }
            else if (!includeTuple) {
                // console.log("don't include tuple, but its an array. joining...: " + result)
                types.push('(' + result.join(',') + ')' + suffix);
            }
            else {
                // console.log("its a single type within a tuple: " + result.types)
                types.push('(' + result + ')');
            }
        }
        else {
            // console.log("its a type and not directly in a tuple: " + param.type)
            types.push(param.type);
        }
    });
    return types;
};
/**
 * Returns a random hex string by the given bytes size
 *
 * @param {Number} size
 * @returns {string}
 */
var randomHex = function (size) {
    return '0x' + randombytes(size).toString('hex');
};
/**
 * Should be called to get ascii from it's hex representation
 *
 * @method hexToAscii
 * @param {String} hex
 * @returns {String} ascii string representation of hex value
 */
var hexToAscii = function (hex) {
    if (!utils$4.isHexStrict(hex))
        throw new Error('The parameter must be a valid HEX string.');
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i += 2) {
        var code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
    }
    return str;
};
/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method asciiToHex
 * @param {String} str
 * @returns {String} hex representation of input string
 */
var asciiToHex = function (str) {
    if (!str)
        return "0x00";
    var hex = "";
    for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }
    return "0x" + hex;
};
/**
 * Returns value of unit in Wei
 *
 * @method getUnitValue
 * @param {String} unit the unit to convert to, default ether
 * @returns {BN} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
var getUnitValue = function (unit) {
    unit = unit ? unit.toLowerCase() : 'ether';
    if (!ethjsUnit.unitMap[unit]) {
        throw new Error('This unit "' + unit + '" doesn\'t exist, please use the one of the following units' + JSON.stringify(ethjsUnit.unitMap, null, 2));
    }
    return unit;
};
/**
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method fromWei
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default ether
 * @return {String|Object} When given a BN object it returns one as well, otherwise a number
 */
var fromWei = function (number, unit) {
    unit = getUnitValue(unit);
    if (!utils$4.isBN(number) && !(typeof number === 'string')) {
        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');
    }
    return utils$4.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);
};
/**
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method toWei
 * @param {Number|String|BN} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default ether
 * @return {String|Object} When given a BN object it returns one as well, otherwise a number
 */
var toWei = function (number, unit) {
    unit = getUnitValue(unit);
    if (!utils$4.isBN(number) && !(typeof number === 'string')) {
        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');
    }
    return utils$4.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);
};
/**
 * Converts to a checksum address
 *
 * @method toChecksumAddress
 * @param {String} address the given HEX address
 * @return {String}
 */
var toChecksumAddress = function (address) {
    if (typeof address === 'undefined')
        return '';
    if (!/^(0x)?[0-9a-f]{40}$/i.test(address))
        throw new Error('Given address "' + address + '" is not a valid Ethereum address.');
    address = address.toLowerCase().replace(/^0x/i, '');
    var addressHash = utils$4.sha3(address).replace(/^0x/i, '');
    var checksumAddress = '0x';
    for (var i = 0; i < address.length; i++) {
        // If ith character is 8 to f then make it uppercase
        if (parseInt(addressHash[i], 16) > 7) {
            checksumAddress += address[i].toUpperCase();
        }
        else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
};
/**
 * Returns -1 if a<b, 1 if a>b; 0 if a == b.
 * For more details on this type of function, see
 * developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
 * Block tag `safe` and `block number` combination param is not supported
 * @method compareBlockNumbers
 *
 * @param {String|Number|BN} a
 *
 * @param {String|Number|BN} b
 *
 * @returns {Number} -1, 0, or 1
 */
var compareBlockNumbers = function (a, b) {
    // Increasing order: (genesis = earliest), safe, (finalized ~ latest), pending
    // safe vs block-num cant be compared as block number provided can be on left or right side of safe tag, until safe tag block number is extracted and compared
    if (a === b) {
        return 0;
    }
    else if (("genesis" === a || "earliest" === a || 0 === a) && ("genesis" === b || "earliest" === b || 0 === b)) {
        return 0;
    }
    else if ("genesis" === a || "earliest" === a || a === 0) {
        // b !== a, thus a < b
        return -1;
    }
    else if ("genesis" === b || "earliest" === b || b === 0) {
        // b !== a, thus a > b
        return 1;
    }
    else if (a === "latest" || a === "finalized") {
        if (b === "pending") {
            return -1;
        }
        else {
            // b !== ("pending" OR "latest"), thus a > b
            return 1;
        }
    }
    else if (b === "latest" || b === "finalized") {
        if (a === "pending") {
            return 1;
        }
        else {
            // b !== ("pending" OR "latest"), thus a > b
            return -1;
        }
    }
    else if (a === "pending") {
        // b (== OR <) "latest", thus a > b
        return 1;
    }
    else if (b === "pending") {
        return -1;
    }
    else if (a === "safe" || b === "safe") {
        // either a or b is "safe" and the other one did not fall into any of the conditions above, so the other one is a number
        return undefined;
    }
    else {
        let bnA = new BN(a);
        let bnB = new BN(b);
        if (bnA.lt(bnB)) {
            return -1;
        }
        else if (bnA.eq(bnB)) {
            return 0;
        }
        else {
            return 1;
        }
    }
};
var lib = {
    _fireError: _fireError,
    _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,
    _flattenTypes: _flattenTypes,
    // extractDisplayName: extractDisplayName,
    // extractTypeName: extractTypeName,
    randomHex: randomHex,
    BN: utils$4.BN,
    isBN: utils$4.isBN,
    isBigNumber: utils$4.isBigNumber,
    isHex: utils$4.isHex,
    isHexStrict: utils$4.isHexStrict,
    sha3: utils$4.sha3,
    sha3Raw: utils$4.sha3Raw,
    keccak256: utils$4.sha3,
    soliditySha3: soliditySha3.soliditySha3,
    soliditySha3Raw: soliditySha3.soliditySha3Raw,
    encodePacked: soliditySha3.encodePacked,
    isAddress: utils$4.isAddress,
    checkAddressChecksum: utils$4.checkAddressChecksum,
    toChecksumAddress: toChecksumAddress,
    toHex: utils$4.toHex,
    toBN: utils$4.toBN,
    bytesToHex: utils$4.bytesToHex,
    hexToBytes: utils$4.hexToBytes,
    hexToNumberString: utils$4.hexToNumberString,
    hexToNumber: utils$4.hexToNumber,
    toDecimal: utils$4.hexToNumber,
    numberToHex: utils$4.numberToHex,
    fromDecimal: utils$4.numberToHex,
    hexToUtf8: utils$4.hexToUtf8,
    hexToString: utils$4.hexToUtf8,
    toUtf8: utils$4.hexToUtf8,
    stripHexPrefix: utils$4.stripHexPrefix,
    utf8ToHex: utils$4.utf8ToHex,
    stringToHex: utils$4.utf8ToHex,
    fromUtf8: utils$4.utf8ToHex,
    hexToAscii: hexToAscii,
    toAscii: hexToAscii,
    asciiToHex: asciiToHex,
    fromAscii: asciiToHex,
    unitMap: ethjsUnit.unitMap,
    toWei: toWei,
    fromWei: fromWei,
    padLeft: utils$4.leftPad,
    leftPad: utils$4.leftPad,
    padRight: utils$4.rightPad,
    rightPad: utils$4.rightPad,
    toTwosComplement: utils$4.toTwosComplement,
    isBloom: utils$4.isBloom,
    isUserEthereumAddressInBloom: utils$4.isUserEthereumAddressInBloom,
    isContractAddressInBloom: utils$4.isContractAddressInBloom,
    isTopic: utils$4.isTopic,
    isTopicInBloom: utils$4.isTopicInBloom,
    isInBloom: utils$4.isInBloom,
    compareBlockNumbers: compareBlockNumbers,
    toNumber: utils$4.toNumber
};

var config = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.networks = void 0;
	// https://github.com/ethereum-lists/chains/tree/master/_data/chains
	exports.networks = [
	    { chainId: 1, shortName: 'eth' },
	    { chainId: 3, shortName: 'rop' },
	    { chainId: 4, shortName: 'rin' },
	    { chainId: 5, shortName: 'gor' },
	    { chainId: 10, shortName: 'oeth' },
	    { chainId: 11, shortName: 'meta' },
	    { chainId: 12, shortName: 'kal' },
	    { chainId: 18, shortName: 'tst' },
	    { chainId: 25, shortName: 'cro' },
	    { chainId: 28, shortName: 'bobarinkeby' },
	    { chainId: 39, shortName: 'u2u' },
	    { chainId: 40, shortName: 'telosevm' },
	    { chainId: 41, shortName: 'telosevmtestnet' },
	    { chainId: 42, shortName: 'kov' },
	    { chainId: 44, shortName: 'crab' },
	    { chainId: 46, shortName: 'darwinia' },
	    { chainId: 50, shortName: 'xdc' },
	    { chainId: 51, shortName: 'txdc' },
	    { chainId: 56, shortName: 'bnb' },
	    { chainId: 57, shortName: 'sys' },
	    { chainId: 61, shortName: 'etc' },
	    { chainId: 63, shortName: 'metc' },
	    { chainId: 69, shortName: 'okov' },
	    { chainId: 82, shortName: 'meter' },
	    { chainId: 83, shortName: 'meter-test' },
	    { chainId: 97, shortName: 'bnbt' },
	    { chainId: 100, shortName: 'gno' },
	    { chainId: 106, shortName: 'vlx' },
	    { chainId: 108, shortName: 'tt' },
	    { chainId: 111, shortName: 'etl' },
	    { chainId: 122, shortName: 'fuse' },
	    { chainId: 123, shortName: 'spark' },
	    { chainId: 137, shortName: 'matic' },
	    { chainId: 155, shortName: 'tenet-testnet' },
	    { chainId: 246, shortName: 'ewt' },
	    { chainId: 250, shortName: 'ftm' },
	    { chainId: 280, shortName: 'zksync-goerli' },
	    { chainId: 288, shortName: 'boba' },
	    { chainId: 300, shortName: 'ogn' },
	    { chainId: 321, shortName: 'kcs' },
	    { chainId: 322, shortName: 'kcst' },
	    { chainId: 324, shortName: 'zksync' },
	    { chainId: 336, shortName: 'sdn' },
	    { chainId: 338, shortName: 'tcro' },
	    { chainId: 420, shortName: 'ogor' },
	    { chainId: 570, shortName: 'sys-rollux' },
	    { chainId: 588, shortName: 'metis-stardust' },
	    { chainId: 592, shortName: 'astr' },
	    { chainId: 595, shortName: 'maca' },
	    { chainId: 599, shortName: 'metis-goerli' },
	    { chainId: 686, shortName: 'kar' },
	    { chainId: 787, shortName: 'aca' },
	    { chainId: 1001, shortName: 'baobab' },
	    { chainId: 1008, shortName: 'eun' },
	    { chainId: 1088, shortName: 'metis-andromeda' },
	    { chainId: 1101, shortName: 'zkevm' },
	    { chainId: 1111, shortName: 'wemix' },
	    { chainId: 1112, shortName: 'twemix' },
	    { chainId: 1115, shortName: 'tcore' },
	    { chainId: 1116, shortName: 'core' },
	    { chainId: 1284, shortName: 'mbeam' },
	    { chainId: 1285, shortName: 'mriver' },
	    { chainId: 1287, shortName: 'mbase' },
	    { chainId: 1294, shortName: 'bobabeam' },
	    { chainId: 1559, shortName: 'tenet' },
	    { chainId: 1807, shortName: 'rana' },
	    { chainId: 1984, shortName: 'euntest' },
	    { chainId: 2001, shortName: 'milkada' },
	    { chainId: 2002, shortName: 'milkalgo' },
	    { chainId: 2008, shortName: 'cloudwalk_testnet' },
	    { chainId: 2019, shortName: 'pmint_test' },
	    { chainId: 2020, shortName: 'pmint' },
	    { chainId: 2221, shortName: 'tkava' },
	    { chainId: 2222, shortName: 'kava' },
	    { chainId: 3737, shortName: 'csb' },
	    { chainId: 4002, shortName: 'tftm' },
	    { chainId: 4689, shortName: 'iotex-mainnet' },
	    { chainId: 4918, shortName: 'txvm' },
	    { chainId: 4919, shortName: 'xvm' },
	    { chainId: 5000, shortName: 'mantle' },
	    { chainId: 5001, shortName: 'mantle-testnet' },
	    { chainId: 5700, shortName: 'tsys' },
	    { chainId: 7341, shortName: 'shyft' },
	    { chainId: 7700, shortName: 'canto' },
	    { chainId: 8217, shortName: 'cypress' },
	    { chainId: 8453, shortName: 'base' },
	    { chainId: 9000, shortName: 'evmos-testnet' },
	    { chainId: 9001, shortName: 'evmos' },
	    { chainId: 9728, shortName: 'boba-testnet' },
	    { chainId: 10000, shortName: 'smartbch' },
	    { chainId: 10001, shortName: 'smartbchtest' },
	    { chainId: 10200, shortName: 'chi' },
	    { chainId: 11235, shortName: 'islm' },
	    { chainId: 11437, shortName: 'shyftt' },
	    { chainId: 12357, shortName: 'rei-testnet' },
	    { chainId: 23294, shortName: 'sapphire' },
	    { chainId: 23295, shortName: 'sapphire-testnet' },
	    { chainId: 42161, shortName: 'arb1' },
	    { chainId: 42170, shortName: 'arb-nova' },
	    { chainId: 42220, shortName: 'celo' },
	    { chainId: 43113, shortName: 'fuji' },
	    { chainId: 43114, shortName: 'avax' },
	    { chainId: 43288, shortName: 'boba-avax' },
	    { chainId: 44787, shortName: 'alfa' },
	    { chainId: 45000, shortName: 'autobahnnetwork' },
	    { chainId: 47805, shortName: 'rei' },
	    { chainId: 54211, shortName: 'islmt' },
	    { chainId: 56288, shortName: 'boba-bnb' },
	    { chainId: 57000, shortName: 'tsys-rollux' },
	    { chainId: 59140, shortName: 'linea-testnet' },
	    { chainId: 71401, shortName: 'gw-testnet-v1' },
	    { chainId: 71402, shortName: 'gw-mainnet-v1' },
	    { chainId: 73799, shortName: 'vt' },
	    { chainId: 80001, shortName: 'maticmum' },
	    { chainId: 84531, shortName: 'base-gor' },
	    { chainId: 200101, shortName: 'milktada' },
	    { chainId: 200202, shortName: 'milktalgo' },
	    { chainId: 333999, shortName: 'olympus' },
	    { chainId: 421611, shortName: 'arb-rinkeby' },
	    { chainId: 421613, shortName: 'arb-goerli' },
	    { chainId: 534353, shortName: 'scr-alpha' },
	    { chainId: 7777777, shortName: 'zora' },
	    { chainId: 11155111, shortName: 'sep' },
	    { chainId: 245022926, shortName: 'neonevm-devnet' },
	    { chainId: 1313161554, shortName: 'aurora' },
	    { chainId: 1313161555, shortName: 'aurora-testnet' },
	    { chainId: 1666600000, shortName: 'hmy-s0' },
	    { chainId: 1666700000, shortName: 'hmy-b-s0' },
	    { chainId: 11297108099, shortName: 'tpalm' },
	    { chainId: 11297108109, shortName: 'palm' }
	];
	if (process.env.TEST_NETWORK === 'hardhat') {
	    exports.networks.push({ shortName: 'local', chainId: 31337 });
	}
	else if (process.env.TEST_NETWORK === 'ganache') {
	    exports.networks.push({ shortName: 'local', chainId: 1337 });
	}
	
} (config));

Object.defineProperty(eip3770, "__esModule", { value: true });
eip3770.validateEip3770Address = eip3770.validateEthereumAddress = eip3770.validateEip3770NetworkPrefix = eip3770.isValidEip3770NetworkPrefix = eip3770.getEip3770NetworkPrefixFromChainId = eip3770.parseEip3770Address = void 0;
const web3_utils_1 = lib;
const config_1$2 = config;
function parseEip3770Address(fullAddress) {
    const parts = fullAddress.split(':');
    const address = parts.length > 1 ? parts[1] : parts[0];
    const prefix = parts.length > 1 ? parts[0] : '';
    return { prefix, address };
}
eip3770.parseEip3770Address = parseEip3770Address;
function getEip3770NetworkPrefixFromChainId(chainId) {
    const network = config_1$2.networks.find((network) => chainId === network.chainId);
    if (!network) {
        throw new Error('No network prefix supported for the current chainId');
    }
    return network.shortName;
}
eip3770.getEip3770NetworkPrefixFromChainId = getEip3770NetworkPrefixFromChainId;
function isValidEip3770NetworkPrefix(prefix) {
    return config_1$2.networks.some(({ shortName }) => shortName === prefix);
}
eip3770.isValidEip3770NetworkPrefix = isValidEip3770NetworkPrefix;
function validateEip3770NetworkPrefix(prefix, currentChainId) {
    const isCurrentNetworkPrefix = prefix === getEip3770NetworkPrefixFromChainId(currentChainId);
    if (!isValidEip3770NetworkPrefix(prefix) || !isCurrentNetworkPrefix) {
        throw new Error('The network prefix must match the current network');
    }
}
eip3770.validateEip3770NetworkPrefix = validateEip3770NetworkPrefix;
function validateEthereumAddress(address) {
    const isValidAddress = (0, web3_utils_1.isHexStrict)(address) && (0, web3_utils_1.isAddress)(address);
    if (!isValidAddress) {
        throw new Error(`Invalid Ethereum address ${address}`);
    }
}
eip3770.validateEthereumAddress = validateEthereumAddress;
function validateEip3770Address(fullAddress, currentChainId) {
    const { address, prefix } = parseEip3770Address(fullAddress);
    validateEthereumAddress(address);
    if (prefix) {
        validateEip3770NetworkPrefix(prefix, currentChainId);
    }
    return { address, prefix };
}
eip3770.validateEip3770Address = validateEip3770Address;

var eip712 = {};

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateTypedData = exports.getEip712MessageTypes = exports.EIP712_DOMAIN = exports.EIP712_DOMAIN_BEFORE_V130 = void 0;
	const satisfies_1 = __importDefault(satisfies_1$2);
	const EQ_OR_GT_1_3_0 = '>=1.3.0';
	exports.EIP712_DOMAIN_BEFORE_V130 = [
	    {
	        type: 'address',
	        name: 'verifyingContract'
	    }
	];
	exports.EIP712_DOMAIN = [
	    {
	        type: 'uint256',
	        name: 'chainId'
	    },
	    {
	        type: 'address',
	        name: 'verifyingContract'
	    }
	];
	// This function returns the types structure for signing off-chain messages according to EIP-712
	function getEip712MessageTypes(safeVersion) {
	    const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
	    return {
	        EIP712Domain: eip712WithChainId ? exports.EIP712_DOMAIN : exports.EIP712_DOMAIN_BEFORE_V130,
	        SafeTx: [
	            { type: 'address', name: 'to' },
	            { type: 'uint256', name: 'value' },
	            { type: 'bytes', name: 'data' },
	            { type: 'uint8', name: 'operation' },
	            { type: 'uint256', name: 'safeTxGas' },
	            { type: 'uint256', name: 'baseGas' },
	            { type: 'uint256', name: 'gasPrice' },
	            { type: 'address', name: 'gasToken' },
	            { type: 'address', name: 'refundReceiver' },
	            { type: 'uint256', name: 'nonce' }
	        ]
	    };
	}
	exports.getEip712MessageTypes = getEip712MessageTypes;
	function generateTypedData({ safeAddress, safeVersion, chainId, safeTransactionData }) {
	    const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
	    const typedData = {
	        types: getEip712MessageTypes(safeVersion),
	        domain: {
	            verifyingContract: safeAddress
	        },
	        primaryType: 'SafeTx',
	        message: {
	            ...safeTransactionData,
	            value: safeTransactionData.value,
	            safeTxGas: safeTransactionData.safeTxGas,
	            baseGas: safeTransactionData.baseGas,
	            gasPrice: safeTransactionData.gasPrice,
	            nonce: safeTransactionData.nonce
	        }
	    };
	    if (eip712WithChainId) {
	        typedData.domain.chainId = chainId;
	    }
	    return typedData;
	}
	exports.generateTypedData = generateTypedData;
	
} (eip712));

var safeVersions = {};

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasSafeFeature = exports.SAFE_FEATURES = void 0;
	const satisfies_1 = __importDefault(satisfies_1$2);
	var SAFE_FEATURES;
	(function (SAFE_FEATURES) {
	    SAFE_FEATURES["SAFE_TX_GAS_OPTIONAL"] = "SAFE_TX_GAS_OPTIONAL";
	    SAFE_FEATURES["SAFE_TX_GUARDS"] = "SAFE_TX_GUARDS";
	    SAFE_FEATURES["SAFE_FALLBACK_HANDLER"] = "SAFE_FALLBACK_HANDLER";
	    SAFE_FEATURES["ETH_SIGN"] = "ETH_SIGN";
	    SAFE_FEATURES["ACCOUNT_ABSTRACTION"] = "ACCOUNT_ABSTRACTION";
	})(SAFE_FEATURES = exports.SAFE_FEATURES || (exports.SAFE_FEATURES = {}));
	const SAFE_FEATURES_BY_VERSION = {
	    [SAFE_FEATURES.SAFE_TX_GAS_OPTIONAL]: '>=1.3.0',
	    [SAFE_FEATURES.SAFE_TX_GUARDS]: '>=1.3.0',
	    [SAFE_FEATURES.SAFE_FALLBACK_HANDLER]: '>=1.1.1',
	    [SAFE_FEATURES.ETH_SIGN]: '>=1.1.0',
	    [SAFE_FEATURES.ACCOUNT_ABSTRACTION]: '>=1.3.0'
	};
	const hasSafeFeature = (feature, version) => {
	    if (!(feature in SAFE_FEATURES_BY_VERSION)) {
	        return false;
	    }
	    return (0, satisfies_1.default)(version, SAFE_FEATURES_BY_VERSION[feature]);
	};
	exports.hasSafeFeature = hasSafeFeature;
	
} (safeVersions));

var signatures = {};

var SafeSignature = {};

Object.defineProperty(SafeSignature, "__esModule", { value: true });
SafeSignature.EthSafeSignature = void 0;
class EthSafeSignature {
    /**
     * Creates an instance of a Safe signature.
     *
     * @param signer - Ethers signer
     * @param signature - The Safe signature
     * @returns The Safe signature instance
     */
    constructor(signer, signature) {
        this.signer = signer;
        this.data = signature;
    }
    /**
     * Returns the static part of the Safe signature.
     *
     * @returns The static part of the Safe signature
     */
    staticPart( /* dynamicOffset: number */) {
        return this.data;
    }
    /**
     * Returns the dynamic part of the Safe signature.
     *
     * @returns The dynamic part of the Safe signature
     */
    dynamicPart() {
        return '';
    }
}
SafeSignature.EthSafeSignature = EthSafeSignature;

var utils$3 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;
	const ethereumjs_util_1 = dist$4;
	const address_1 = address$1;
	const SafeSignature_1 = SafeSignature;
	function generatePreValidatedSignature(ownerAddress) {
	    const signature = '0x000000000000000000000000' +
	        ownerAddress.slice(2) +
	        '0000000000000000000000000000000000000000000000000000000000000000' +
	        '01';
	    return new SafeSignature_1.EthSafeSignature(ownerAddress, signature);
	}
	exports.generatePreValidatedSignature = generatePreValidatedSignature;
	function isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {
	    let hasPrefix;
	    try {
	        const rsvSig = {
	            r: Buffer.from(signature.slice(2, 66), 'hex'),
	            s: Buffer.from(signature.slice(66, 130), 'hex'),
	            v: parseInt(signature.slice(130, 132), 16)
	        };
	        const recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), 'hex'), rsvSig.v, rsvSig.r, rsvSig.s);
	        const recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));
	        hasPrefix = !(0, address_1.sameString)(recoveredAddress, ownerAddress);
	    }
	    catch (e) {
	        hasPrefix = true;
	    }
	    return hasPrefix;
	}
	exports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;
	const adjustVInSignature = (signingMethod, signature, safeTxHash, signerAddress) => {
	    const ETHEREUM_V_VALUES = [0, 1, 27, 28];
	    const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;
	    let signatureV = parseInt(signature.slice(-2), 16);
	    if (!ETHEREUM_V_VALUES.includes(signatureV)) {
	        throw new Error('Invalid signature');
	    }
	    if (signingMethod === 'eth_sign') {
	        /*
	          The Safe's expected V value for ECDSA signature is:
	          - 27 or 28
	          - 31 or 32 if the message was signed with a EIP-191 prefix. Should be calculated as ECDSA V value + 4
	          Some wallets do that, some wallets don't, V > 30 is used by contracts to differentiate between
	          prefixed and non-prefixed messages. The only way to know if the message was signed with a
	          prefix is to check if the signer address is the same as the recovered address.
	    
	          More info:
	          https://docs.safe.global/safe-core-protocol/signatures
	        */
	        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
	            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
	        }
	        const adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);
	        const signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);
	        if (signatureHasPrefix) {
	            signatureV += 4;
	        }
	    }
	    if (signingMethod === 'eth_signTypedData') {
	        // Metamask with ledger returns V=0/1 here too, we need to adjust it to be ethereum's valid value (27 or 28)
	        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
	            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
	        }
	    }
	    signature = signature.slice(0, -2) + signatureV.toString(16);
	    return signature;
	};
	exports.adjustVInSignature = adjustVInSignature;
	async function generateSignature(ethAdapter, hash) {
	    const signerAddress = await ethAdapter.getSignerAddress();
	    if (!signerAddress) {
	        throw new Error('EthAdapter must be initialized with a signer to use this method');
	    }
	    let signature = await ethAdapter.signMessage(hash);
	    signature = (0, exports.adjustVInSignature)('eth_sign', signature, hash, signerAddress);
	    return new SafeSignature_1.EthSafeSignature(signerAddress, signature);
	}
	exports.generateSignature = generateSignature;
	async function generateEIP712Signature(ethAdapter, safeTransactionEIP712Args, methodVersion) {
	    const signerAddress = await ethAdapter.getSignerAddress();
	    if (!signerAddress) {
	        throw new Error('EthAdapter must be initialized with a signer to use this method');
	    }
	    let signature = await ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);
	    signature = (0, exports.adjustVInSignature)('eth_signTypedData', signature);
	    return new SafeSignature_1.EthSafeSignature(signerAddress, signature);
	}
	exports.generateEIP712Signature = generateEIP712Signature;
	
} (utils$3));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(SafeSignature, exports);
	__exportStar(utils$3, exports);
	
} (signatures));

var transactions = {};

var gas = {};

var __importDefault$O = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(gas, "__esModule", { value: true });
gas.estimateSafeDeploymentGas = gas.estimateSafeTxGas = gas.estimateTxBaseGas = gas.estimateTxGas = gas.estimateGas = void 0;
const bignumber_1$6 = require$$0$7;
const safe_core_sdk_types_1$1 = src$5;
const satisfies_1 = __importDefault$O(satisfies_1$2);
const constants_1$f = constants$4;
const safeDeploymentContracts_1$2 = safeDeploymentContracts;
// Every byte == 00 -> 4  Gas cost
const CALL_DATA_ZERO_BYTE_GAS_COST = 4;
// Every byte != 00 -> 16 Gas cost (68 before Istanbul)
const CALL_DATA_BYTE_GAS_COST = 16;
// gas cost initialization of a Safe
const INITIZATION_GAS_COST = 20000;
// increment nonce gas cost
const INCREMENT_NONCE_GAS_COST = 5000;
// Keccak gas cost for the hash of the Safe transaction
const HASH_GENERATION_GAS_COST = 1500;
// ecrecover gas cost for ecdsa ~= 4K gas, we use 6K
const ECRECOVER_GAS_COST = 6000;
// transfer gas cost
const TRANSAFER_GAS_COST = 32000;
// numbers < 256 (0x00(31*2)..ff) are 192 -> 31 * 4 + 1 * CALL_DATA_BYTE_GAS_COST
// numbers < 65535 (0x(30*2)..ffff) are 256 -> 30 * 4 + 2 * CALL_DATA_BYTE_GAS_COST
// Calculate gas for signatures
// (array count (3 -> r, s, v) + ecrecover costs) * signature count
const GAS_COST_PER_SIGNATURE = 1 * CALL_DATA_BYTE_GAS_COST + 2 * 32 * CALL_DATA_BYTE_GAS_COST + ECRECOVER_GAS_COST;
function estimateDataGasCosts(data) {
    const bytes = data.match(/.{2}/g);
    return bytes.reduce((gasCost, currentByte) => {
        if (currentByte === '0x') {
            return gasCost + 0;
        }
        if (currentByte === '00') {
            return gasCost + CALL_DATA_ZERO_BYTE_GAS_COST;
        }
        return gasCost + CALL_DATA_BYTE_GAS_COST;
    }, 0);
}
async function estimateGas(safeVersion, safeContract, ethAdapter, to, valueInWei, data, operation, customContracts) {
    const chainId = await ethAdapter.getChainId();
    const simulateTxAccessorContract = await (0, safeDeploymentContracts_1$2.getSimulateTxAccessorContract)({
        ethAdapter,
        safeVersion,
        customContracts: customContracts?.[chainId]
    });
    const transactionDataToEstimate = simulateTxAccessorContract.encode('simulate', [
        to,
        valueInWei,
        data,
        operation
    ]);
    const safeFunctionToEstimate = safeContract.encode('simulateAndRevert', [
        await simulateTxAccessorContract.getAddress(),
        transactionDataToEstimate
    ]);
    const safeAddress = safeContract.getAddress();
    const transactionToEstimateGas = {
        to: safeAddress,
        value: '0',
        data: safeFunctionToEstimate,
        from: safeAddress
    };
    try {
        const encodedResponse = await ethAdapter.call(transactionToEstimateGas);
        return Number('0x' + encodedResponse.slice(184).slice(0, 10)).toString();
    }
    catch (error) {
        return parseSafeTxGasErrorResponse(error);
    }
}
gas.estimateGas = estimateGas;
async function estimateTxGas(safeContract, ethAdapter, to, valueInWei, data, operation) {
    let txGasEstimation = bignumber_1$6.BigNumber.from(0);
    const safeAddress = safeContract.getAddress();
    const estimateData = safeContract.encode('requiredTxGas', [
        to,
        valueInWei,
        data,
        operation
    ]);
    try {
        const estimateResponse = await ethAdapter.estimateGas({
            to: safeAddress,
            from: safeAddress,
            data: estimateData
        });
        txGasEstimation = bignumber_1$6.BigNumber.from('0x' + estimateResponse.substring(138)).add(10000);
    }
    catch (error) { }
    if (txGasEstimation.gt(0)) {
        const dataGasEstimation = estimateDataGasCosts(estimateData);
        let additionalGas = 10000;
        for (let i = 0; i < 10; i++) {
            try {
                const estimateResponse = await ethAdapter.call({
                    to: safeAddress,
                    from: safeAddress,
                    data: estimateData,
                    gasPrice: '0',
                    gasLimit: txGasEstimation.add(dataGasEstimation).add(additionalGas).toString()
                });
                if (estimateResponse !== '0x') {
                    break;
                }
            }
            catch (error) { }
            txGasEstimation = txGasEstimation.add(additionalGas);
            additionalGas *= 2;
        }
        return txGasEstimation.add(additionalGas).toString();
    }
    try {
        const estimateGas = await ethAdapter.estimateGas({
            to,
            from: safeAddress,
            value: valueInWei,
            data
        });
        return estimateGas;
    }
    catch (error) {
        if (operation === safe_core_sdk_types_1$1.OperationType.DelegateCall) {
            return '0';
        }
        return Promise.reject(error);
    }
}
gas.estimateTxGas = estimateTxGas;
/**
 * This function estimates the baseGas of a Safe transaction.
 * The baseGas includes costs for:
 * - Generation of the Safe transaction hash (txHash)
 * - Increasing the nonce of the Safe
 * - Verifying the signatures of the Safe transaction
 * - Payment to relayers for executing the transaction
 * - Emitting events ExecutionSuccess or ExecutionFailure
 *
 * Note: it does not include the transaction execution cost (safeTxGas)
 *
 * @async
 * @function estimateTxBaseGas
 * @param {Safe} safe - The Safe instance containing all the information about the safe.
 * @param {SafeTransaction} safeTransaction - The transaction for which the baseGas is to be estimated.
 * @returns {Promise<string>} A Promise that resolves with the estimated baseGas as a string.
 */
async function estimateTxBaseGas(safe, safeTransaction) {
    const safeTransactionData = safeTransaction.data;
    const { to, value, data, operation, safeTxGas, gasToken, refundReceiver } = safeTransactionData;
    const safeThreshold = await safe.getThreshold();
    const safeNonce = await safe.getNonce();
    const signaturesGasCost = safeThreshold * GAS_COST_PER_SIGNATURE;
    const encodeSafeTxGas = safeTxGas || 0;
    const encodeBaseGas = 0;
    const gasPrice = 1;
    const encodeGasToken = gasToken || constants_1$f.ZERO_ADDRESS;
    const encodeRefundReceiver = refundReceiver || constants_1$f.ZERO_ADDRESS;
    const signatures = '0x';
    const safeVersion = await safe.getContractVersion();
    const ethAdapter = safe.getEthAdapter();
    const isL1SafeMasterCopy = safe.getContractManager().isL1SafeMasterCopy;
    const chainId = await safe.getChainId();
    const customContracts = safe.getContractManager().contractNetworks?.[chainId];
    const safeSingletonContract = await (0, safeDeploymentContracts_1$2.getSafeContract)({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
    });
    const execTransactionData = safeSingletonContract.encode('execTransaction', [
        to,
        value,
        data,
        operation,
        encodeSafeTxGas,
        encodeBaseGas,
        gasPrice,
        encodeGasToken,
        encodeRefundReceiver,
        signatures
    ]);
    // If nonce == 0, nonce storage has to be initialized
    const isSafeInitialized = safeNonce !== 0;
    const incrementNonceGasCost = isSafeInitialized ? INCREMENT_NONCE_GAS_COST : INITIZATION_GAS_COST;
    let baseGas = signaturesGasCost +
        estimateDataGasCosts(execTransactionData) +
        incrementNonceGasCost +
        HASH_GENERATION_GAS_COST;
    // Add additional gas costs
    baseGas > 65536 ? (baseGas += 64) : (baseGas += 128);
    // Base tx costs, transfer costs...
    baseGas += TRANSAFER_GAS_COST;
    return baseGas.toString();
}
gas.estimateTxBaseGas = estimateTxBaseGas;
/**
 * This function estimates the safeTxGas of a Safe transaction.
 * The safeTxGas value represents the amount of gas required to execute the Safe transaction itself.
 * It does not include costs such as signature verification, transaction hash generation, nonce incrementing, and so on.
 *
 * The estimation method differs based on the version of the Safe:
 * - For versions >= 1.3.0, the simulate function defined in the simulateTxAccessor.sol Contract is used.
 * - For versions < 1.3.0, the deprecated requiredTxGas method defined in the GnosisSafe.sol contract is used.
 *
 * @async
 * @function estimateSafeTxGas
 * @param {Safe} safe - The Safe instance containing all the necessary information about the safe.
 * @param {SafeTransaction} safeTransaction - The transaction for which the safeTxGas is to be estimated.
 * @returns {Promise<string>} A Promise that resolves with the estimated safeTxGas as a string.
 *
 */
async function estimateSafeTxGas(safe, safeTransaction) {
    const safeVersion = await safe.getContractVersion();
    if ((0, satisfies_1.default)(safeVersion, '>=1.3.0')) {
        const safeTxGas = await estimateSafeTxGasWithSimulate(safe, safeTransaction);
        return addExtraGasForSafety(safeTxGas);
    }
    // deprecated method to estimate the safeTxGas of a Safe transaction
    const safeTxGas = await estimateSafeTxGasWithRequiredTxGas(safe, safeTransaction);
    return addExtraGasForSafety(safeTxGas);
}
gas.estimateSafeTxGas = estimateSafeTxGas;
/**
 * Increase the given safeTxGas gas amount by 5% as a security margin to avoid running out of gas.
 * In some contexts, the safeTxGas might be underestimated, leading to 'out of gas' errors during the Safe transaction execution
 *
 * @param {string} safeTxGas - The original safeTxGas gas amount.
 * @returns {string} The new safeTxGas gas amount, increased by 5% rounded.
 */
function addExtraGasForSafety(safeTxGas) {
    const INCREASE_GAS_FACTOR = 1.05; // increase the gas by 5% as a security margin
    return Math.round(Number(safeTxGas) * INCREASE_GAS_FACTOR).toString();
}
/**
 * This function estimates the safeTxGas of a Safe transaction.
 * Using the deprecated method of requiredTxGas defined in the GnosisSafe contract. This method is meant to be used for Safe versions < 1.3.0.
 * see: https://github.com/safe-global/safe-contracts/blob/v1.2.0/contracts/GnosisSafe.sol#L276
 *
 * @async
 * @function estimateSafeTxGasWithRequiredTxGas
 * @param {Safe} safe - The Safe instance containing all the necessary information about the safe.
 * @param {SafeTransaction} safeTransaction - The transaction for which the safeTxGas is to be estimated.
 * @returns {Promise<string>} A Promise that resolves with the estimated safeTxGas as a string.
 *
 */
async function estimateSafeTxGasWithRequiredTxGas(safe, safeTransaction) {
    const isSafeDeployed = await safe.isSafeDeployed();
    const safeAddress = await safe.getAddress();
    const safeVersion = await safe.getContractVersion();
    const ethAdapter = safe.getEthAdapter();
    const isL1SafeMasterCopy = safe.getContractManager().isL1SafeMasterCopy;
    const chainId = await safe.getChainId();
    const customContracts = safe.getContractManager().contractNetworks?.[chainId];
    const safeSingletonContract = await (0, safeDeploymentContracts_1$2.getSafeContract)({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
    });
    const transactionDataToEstimate = safeSingletonContract.encode('requiredTxGas', [
        safeTransaction.data.to,
        safeTransaction.data.value,
        safeTransaction.data.data,
        safeTransaction.data.operation
    ]);
    const to = isSafeDeployed ? safeAddress : safeSingletonContract.getAddress();
    const transactionToEstimateGas = {
        to,
        value: '0',
        data: transactionDataToEstimate,
        from: safeAddress
    };
    try {
        const encodedResponse = await ethAdapter.call(transactionToEstimateGas);
        const safeTxGas = '0x' + encodedResponse.slice(-32);
        return safeTxGas;
        // if the call throws an error we try to parse the returned value
    }
    catch (error) {
        try {
            const revertData = JSON.parse(error.error.body).error.data;
            if (revertData && revertData.startsWith('Reverted ')) {
                const [, safeTxGas] = revertData.split('Reverted ');
                return Number(safeTxGas).toString();
            }
        }
        catch {
            return '0';
        }
    }
    return '0';
}
// TO-DO: Improve decoding
/*
  const simulateAndRevertResponse = ethAdapter.decodeParameters(
    ['bool', 'bytes'],
    encodedResponse
  )
  const returnedData = ethAdapter.decodeParameters(['uint256', 'bool', 'bytes'], simulateAndRevertResponse[1])
  */
function decodeSafeTxGas(encodedSafeTxGas) {
    return Number('0x' + encodedSafeTxGas.slice(184).slice(0, 10)).toString();
}
function parseSafeTxGasErrorResponse(error) {
    // Ethers
    if (error?.error?.body) {
        const revertData = JSON.parse(error.error.body).error.data;
        if (revertData && revertData.startsWith('Reverted ')) {
            const [, encodedResponse] = revertData.split('Reverted ');
            const safeTxGas = decodeSafeTxGas(encodedResponse);
            return safeTxGas;
        }
    }
    // Web3
    const [, encodedResponse] = error.message.split('return data: ');
    const safeTxGas = decodeSafeTxGas(encodedResponse);
    return safeTxGas;
}
/**
 * This function estimates the safeTxGas of a Safe transaction.
 * It uses the simulate function defined in the SimulateTxAccessor contract. This method is meant to be used for Safe versions >= 1.3.0.
 *
 * @async
 * @function estimateSafeTxGasWithSimulate
 * @param {Safe} safe - The Safe instance containing all the necessary information about the safe.
 * @param {SafeTransaction} safeTransaction - The transaction for which the safeTxGas is to be estimated.
 * @returns {Promise<string>} A Promise that resolves with the estimated safeTxGas as a string.
 *
 */
async function estimateSafeTxGasWithSimulate(safe, safeTransaction) {
    const isSafeDeployed = await safe.isSafeDeployed();
    const safeAddress = await safe.getAddress();
    const safeVersion = await safe.getContractVersion();
    const ethAdapter = safe.getEthAdapter();
    const chainId = await safe.getChainId();
    const customContracts = safe.getContractManager().contractNetworks?.[chainId];
    const isL1SafeMasterCopy = safe.getContractManager().isL1SafeMasterCopy;
    const safeSingletonContract = await (0, safeDeploymentContracts_1$2.getSafeContract)({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
    });
    // new version of the estimation
    const simulateTxAccessorContract = await (0, safeDeploymentContracts_1$2.getSimulateTxAccessorContract)({
        ethAdapter,
        safeVersion,
        customContracts
    });
    const transactionDataToEstimate = simulateTxAccessorContract.encode('simulate', [
        safeTransaction.data.to,
        safeTransaction.data.value,
        safeTransaction.data.data,
        safeTransaction.data.operation
    ]);
    // if the Safe is not deployed we can use the singleton address to simulate
    const to = isSafeDeployed ? safeAddress : safeSingletonContract.getAddress();
    const safeFunctionToEstimate = safeSingletonContract.encode('simulateAndRevert', [
        await simulateTxAccessorContract.getAddress(),
        transactionDataToEstimate
    ]);
    const transactionToEstimateGas = {
        to,
        value: '0',
        data: safeFunctionToEstimate,
        from: safeAddress
    };
    try {
        const encodedResponse = await ethAdapter.call(transactionToEstimateGas);
        const safeTxGas = decodeSafeTxGas(encodedResponse);
        return safeTxGas;
        // if the call throws an error we try to parse the returned value
    }
    catch (error) {
        return parseSafeTxGasErrorResponse(error);
    }
    return '0';
}
/**
 * This function estimates the gas cost of deploying a Safe.
 * It considers also the costs of the Safe setup call.
 * The setup call includes tasks such as setting up initial owners, defining the threshold, and initializing the salt nonce used for address generation.
 *
 * @async
 * @function estimateSafeDeploymentGas
 * @param {Safe} safe - The Safe object containing all necessary information about the safe, including owners, threshold, and saltNonce.
 * @returns {Promise<string>} A Promise that resolves with the estimated gas cost of the safe deployment as a string.
 */
async function estimateSafeDeploymentGas(safe) {
    const isSafeDeployed = await safe.isSafeDeployed();
    if (isSafeDeployed) {
        return '0';
    }
    const ethAdapter = safe.getEthAdapter();
    const safeDeploymentTransaction = await safe.createSafeDeploymentTransaction();
    const estimation = await ethAdapter.estimateGas({
        ...safeDeploymentTransaction,
        from: constants_1$f.ZERO_ADDRESS // if we use the Safe address the estimation always fails due to CREATE2
    });
    return estimation;
}
gas.estimateSafeDeploymentGas = estimateSafeDeploymentGas;

var SafeTransaction = {};

Object.defineProperty(SafeTransaction, "__esModule", { value: true });
class EthSafeTransaction {
    constructor(data) {
        this.signatures = new Map();
        this.data = data;
    }
    addSignature(signature) {
        this.signatures.set(signature.signer.toLowerCase(), signature);
    }
    encodedSignatures() {
        const signers = Array.from(this.signatures.keys()).sort();
        signers.length * 65;
        let staticParts = '';
        let dynamicParts = '';
        signers.forEach((signerAddress) => {
            const signature = this.signatures.get(signerAddress);
            staticParts += signature?.staticPart( /*baseOffset + dynamicParts.length / 2*/).slice(2);
            dynamicParts += signature?.dynamicPart();
        });
        return '0x' + staticParts + dynamicParts;
    }
}
SafeTransaction.default = EthSafeTransaction;

var types = {};

Object.defineProperty(types, "__esModule", { value: true });

var utils$2 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$2;
	hasRequiredUtils$1 = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(utils$2, "__esModule", { value: true });
	utils$2.isSafeMultisigTransactionResponse = utils$2.isMetaTransactionArray = utils$2.decodeMultiSendData = utils$2.encodeMultiSendData = utils$2.standardizeSafeTransactionData = utils$2.standardizeMetaTransactionData = void 0;
	const abi_1 = require$$0$9;
	const bytes_1 = require$$1$9;
	const solidity_1 = require$$2$5;
	const config_1 = config$1;
	const utils_1 = requireUtils();
	const constants_1 = constants$4;
	const safe_core_sdk_types_1 = src$5;
	const satisfies_1 = __importDefault(satisfies_1$2);
	const web3_utils_1 = lib;
	const gas_1 = gas;
	function standardizeMetaTransactionData(tx) {
	    const standardizedTxs = {
	        ...tx,
	        operation: tx.operation ?? safe_core_sdk_types_1.OperationType.Call
	    };
	    return standardizedTxs;
	}
	utils$2.standardizeMetaTransactionData = standardizeMetaTransactionData;
	async function standardizeSafeTransactionData({ safeContract, predictedSafe, ethAdapter, tx, contractNetworks }) {
	    const standardizedTxs = {
	        to: tx.to,
	        value: tx.value,
	        data: tx.data,
	        operation: tx.operation ?? safe_core_sdk_types_1.OperationType.Call,
	        baseGas: tx.baseGas ?? '0',
	        gasPrice: tx.gasPrice ?? '0',
	        gasToken: tx.gasToken || constants_1.ZERO_ADDRESS,
	        refundReceiver: tx.refundReceiver || constants_1.ZERO_ADDRESS,
	        nonce: tx.nonce ?? (safeContract ? await safeContract.getNonce() : 0)
	    };
	    if (typeof tx.safeTxGas !== 'undefined') {
	        return {
	            ...standardizedTxs,
	            safeTxGas: tx.safeTxGas
	        };
	    }
	    let safeVersion;
	    if (predictedSafe) {
	        safeVersion = predictedSafe?.safeDeploymentConfig?.safeVersion || config_1.DEFAULT_SAFE_VERSION;
	    }
	    else {
	        if (!safeContract) {
	            throw new Error('Safe is not deployed');
	        }
	        safeVersion = await safeContract.getVersion();
	    }
	    const hasSafeTxGasOptional = (0, utils_1.hasSafeFeature)(utils_1.SAFE_FEATURES.SAFE_TX_GAS_OPTIONAL, safeVersion);
	    if ((hasSafeTxGasOptional && standardizedTxs.gasPrice === '0') ||
	        (hasSafeTxGasOptional && predictedSafe)) {
	        return {
	            ...standardizedTxs,
	            safeTxGas: '0'
	        };
	    }
	    if (!safeContract) {
	        throw new Error('Safe is not deployed');
	    }
	    let safeTxGas;
	    if ((0, satisfies_1.default)(safeVersion, '>=1.3.0')) {
	        safeTxGas = await (0, gas_1.estimateGas)(safeVersion, safeContract, ethAdapter, standardizedTxs.to, standardizedTxs.value, standardizedTxs.data, standardizedTxs.operation, contractNetworks);
	    }
	    else {
	        safeTxGas = await (0, gas_1.estimateTxGas)(safeContract, ethAdapter, standardizedTxs.to, standardizedTxs.value, standardizedTxs.data, standardizedTxs.operation);
	    }
	    return {
	        ...standardizedTxs,
	        safeTxGas
	    };
	}
	utils$2.standardizeSafeTransactionData = standardizeSafeTransactionData;
	function encodeMetaTransaction(tx) {
	    const data = (0, bytes_1.arrayify)(tx.data);
	    const encoded = (0, solidity_1.pack)(['uint8', 'address', 'uint256', 'uint256', 'bytes'], [tx.operation, tx.to, tx.value, data.length, data]);
	    return encoded.slice(2);
	}
	function encodeMultiSendData(txs) {
	    return '0x' + txs.map((tx) => encodeMetaTransaction(tx)).join('');
	}
	utils$2.encodeMultiSendData = encodeMultiSendData;
	function decodeMultiSendData(encodedData) {
	    const multiSendInterface = new abi_1.Interface([
	        'function multiSend(bytes memory transactions) public payable'
	    ]);
	    const [decodedData] = multiSendInterface.decodeFunctionData('multiSend', encodedData);
	    const txs = [];
	    // Decode after 0x
	    let index = 2;
	    while (index < decodedData.length) {
	        // As we are decoding hex encoded bytes calldata, each byte is represented by 2 chars
	        // uint8 operation, address to, value uint256, dataLength uint256
	        const operation = `0x${decodedData.slice(index, (index += 2))}`;
	        const to = `0x${decodedData.slice(index, (index += 40))}`;
	        const value = `0x${decodedData.slice(index, (index += 64))}`;
	        const dataLength = parseInt(decodedData.slice(index, (index += 64)), 16) * 2;
	        const data = `0x${decodedData.slice(index, (index += dataLength))}`;
	        txs.push({
	            operation: (0, web3_utils_1.hexToNumber)(operation),
	            to: (0, web3_utils_1.toChecksumAddress)(to),
	            value: (0, web3_utils_1.hexToNumberString)(value),
	            data
	        });
	    }
	    return txs;
	}
	utils$2.decodeMultiSendData = decodeMultiSendData;
	function isMetaTransactionArray(safeTransactions) {
	    return safeTransactions?.length !== undefined;
	}
	utils$2.isMetaTransactionArray = isMetaTransactionArray;
	function isSafeMultisigTransactionResponse(safeTransaction) {
	    return safeTransaction.isExecuted !== undefined;
	}
	utils$2.isSafeMultisigTransactionResponse = isSafeMultisigTransactionResponse;
	
	return utils$2;
}

var hasRequiredTransactions;

function requireTransactions () {
	if (hasRequiredTransactions) return transactions;
	hasRequiredTransactions = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(gas, exports);
		__exportStar(SafeTransaction, exports);
		__exportStar(types, exports);
		__exportStar(requireUtils$1(), exports);
		
	} (transactions));
	return transactions;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$c;
	hasRequiredUtils = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(address$1, exports);
		__exportStar(eip3770, exports);
		__exportStar(eip712, exports);
		__exportStar(safeVersions, exports);
		__exportStar(signatures, exports);
		__exportStar(requireTransactions(), exports);
		
	} (utils$c));
	return utils$c;
}

var __classPrivateFieldSet$7 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$7 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FallbackHandlerManager_ethAdapter, _FallbackHandlerManager_safeContract, _FallbackHandlerManager_slot;
Object.defineProperty(fallbackHandlerManager, "__esModule", { value: true });
const utils_1$m = requireUtils();
const constants_1$e = constants$4;
class FallbackHandlerManager {
    constructor(ethAdapter, safeContract) {
        _FallbackHandlerManager_ethAdapter.set(this, void 0);
        _FallbackHandlerManager_safeContract.set(this, void 0);
        // keccak256("fallback_manager.handler.address")
        _FallbackHandlerManager_slot.set(this, '0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5');
        __classPrivateFieldSet$7(this, _FallbackHandlerManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet$7(this, _FallbackHandlerManager_safeContract, safeContract, "f");
    }
    validateFallbackHandlerAddress(fallbackHandlerAddress) {
        const isValidAddress = __classPrivateFieldGet$7(this, _FallbackHandlerManager_ethAdapter, "f").isAddress(fallbackHandlerAddress);
        if (!isValidAddress || (0, utils_1$m.isZeroAddress)(fallbackHandlerAddress)) {
            throw new Error('Invalid fallback handler address provided');
        }
    }
    validateFallbackHandlerIsNotEnabled(currentFallbackHandler, newFallbackHandlerAddress) {
        if ((0, utils_1$m.sameString)(currentFallbackHandler, newFallbackHandlerAddress)) {
            throw new Error('Fallback handler provided is already enabled');
        }
    }
    validateFallbackHandlerIsEnabled(fallbackHandlerAddress) {
        if ((0, utils_1$m.isZeroAddress)(fallbackHandlerAddress)) {
            throw new Error('There is no fallback handler enabled yet');
        }
    }
    async getFallbackHandler() {
        if (!__classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        const safeVersion = await __classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f").getVersion();
        if ((0, utils_1$m.hasSafeFeature)(utils_1$m.SAFE_FEATURES.SAFE_FALLBACK_HANDLER, safeVersion)) {
            return __classPrivateFieldGet$7(this, _FallbackHandlerManager_ethAdapter, "f").getStorageAt(__classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f").getAddress(), __classPrivateFieldGet$7(this, _FallbackHandlerManager_slot, "f"));
        }
        else {
            throw new Error('Current version of the Safe does not support the fallback handler functionality');
        }
    }
    async encodeEnableFallbackHandlerData(fallbackHandlerAddress) {
        if (!__classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateFallbackHandlerAddress(fallbackHandlerAddress);
        const currentFallbackHandler = await this.getFallbackHandler();
        this.validateFallbackHandlerIsNotEnabled(currentFallbackHandler, fallbackHandlerAddress);
        return __classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f").encode('setFallbackHandler', [fallbackHandlerAddress]);
    }
    async encodeDisableFallbackHandlerData() {
        if (!__classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        const currentFallbackHandler = await this.getFallbackHandler();
        this.validateFallbackHandlerIsEnabled(currentFallbackHandler);
        return __classPrivateFieldGet$7(this, _FallbackHandlerManager_safeContract, "f").encode('setFallbackHandler', [constants_1$e.ZERO_ADDRESS]);
    }
}
_FallbackHandlerManager_ethAdapter = new WeakMap(), _FallbackHandlerManager_safeContract = new WeakMap(), _FallbackHandlerManager_slot = new WeakMap();
fallbackHandlerManager.default = FallbackHandlerManager;

var guardManager = {};

var __classPrivateFieldSet$6 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$6 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GuardManager_ethAdapter, _GuardManager_safeContract, _GuardManager_slot;
Object.defineProperty(guardManager, "__esModule", { value: true });
const utils_1$l = requireUtils();
const constants_1$d = constants$4;
class GuardManager {
    constructor(ethAdapter, safeContract) {
        _GuardManager_ethAdapter.set(this, void 0);
        _GuardManager_safeContract.set(this, void 0);
        // keccak256("guard_manager.guard.address")
        _GuardManager_slot.set(this, '0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8');
        __classPrivateFieldSet$6(this, _GuardManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet$6(this, _GuardManager_safeContract, safeContract, "f");
    }
    validateGuardAddress(guardAddress) {
        const isValidAddress = __classPrivateFieldGet$6(this, _GuardManager_ethAdapter, "f").isAddress(guardAddress);
        if (!isValidAddress || (0, utils_1$l.isZeroAddress)(guardAddress)) {
            throw new Error('Invalid guard address provided');
        }
    }
    validateGuardIsNotEnabled(currentGuard, newGuardAddress) {
        if ((0, utils_1$l.sameString)(currentGuard, newGuardAddress)) {
            throw new Error('Guard provided is already enabled');
        }
    }
    validateGuardIsEnabled(guardAddress) {
        if ((0, utils_1$l.isZeroAddress)(guardAddress)) {
            throw new Error('There is no guard enabled yet');
        }
    }
    async getGuard() {
        if (!__classPrivateFieldGet$6(this, _GuardManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        const safeVersion = await __classPrivateFieldGet$6(this, _GuardManager_safeContract, "f").getVersion();
        if ((0, utils_1$l.hasSafeFeature)(utils_1$l.SAFE_FEATURES.SAFE_TX_GUARDS, safeVersion)) {
            return __classPrivateFieldGet$6(this, _GuardManager_ethAdapter, "f").getStorageAt(__classPrivateFieldGet$6(this, _GuardManager_safeContract, "f").getAddress(), __classPrivateFieldGet$6(this, _GuardManager_slot, "f"));
        }
        else {
            throw new Error('Current version of the Safe does not support Safe transaction guards functionality');
        }
    }
    async encodeEnableGuardData(guardAddress) {
        if (!__classPrivateFieldGet$6(this, _GuardManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateGuardAddress(guardAddress);
        const currentGuard = await this.getGuard();
        this.validateGuardIsNotEnabled(currentGuard, guardAddress);
        return __classPrivateFieldGet$6(this, _GuardManager_safeContract, "f").encode('setGuard', [guardAddress]);
    }
    async encodeDisableGuardData() {
        if (!__classPrivateFieldGet$6(this, _GuardManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        const currentGuard = await this.getGuard();
        this.validateGuardIsEnabled(currentGuard);
        return __classPrivateFieldGet$6(this, _GuardManager_safeContract, "f").encode('setGuard', [constants_1$d.ZERO_ADDRESS]);
    }
}
_GuardManager_ethAdapter = new WeakMap(), _GuardManager_safeContract = new WeakMap(), _GuardManager_slot = new WeakMap();
guardManager.default = GuardManager;

var moduleManager = {};

var __classPrivateFieldSet$5 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$5 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ModuleManager_ethAdapter, _ModuleManager_safeContract;
Object.defineProperty(moduleManager, "__esModule", { value: true });
const address_1$1 = address$1;
const constants_1$c = constants$4;
class ModuleManager {
    constructor(ethAdapter, safeContract) {
        _ModuleManager_ethAdapter.set(this, void 0);
        _ModuleManager_safeContract.set(this, void 0);
        __classPrivateFieldSet$5(this, _ModuleManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet$5(this, _ModuleManager_safeContract, safeContract, "f");
    }
    validateModuleAddress(moduleAddress) {
        const isValidAddress = __classPrivateFieldGet$5(this, _ModuleManager_ethAdapter, "f").isAddress(moduleAddress);
        if (!isValidAddress || (0, address_1$1.isRestrictedAddress)(moduleAddress)) {
            throw new Error('Invalid module address provided');
        }
    }
    validateModuleIsNotEnabled(moduleAddress, modules) {
        const moduleIndex = modules.findIndex((module) => (0, address_1$1.sameString)(module, moduleAddress));
        const isEnabled = moduleIndex >= 0;
        if (isEnabled) {
            throw new Error('Module provided is already enabled');
        }
    }
    validateModuleIsEnabled(moduleAddress, modules) {
        const moduleIndex = modules.findIndex((module) => (0, address_1$1.sameString)(module, moduleAddress));
        const isEnabled = moduleIndex >= 0;
        if (!isEnabled) {
            throw new Error('Module provided is not enabled yet');
        }
        return moduleIndex;
    }
    async getModules() {
        if (!__classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        return __classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f").getModules();
    }
    async isModuleEnabled(moduleAddress) {
        if (!__classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        return __classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f").isModuleEnabled(moduleAddress);
    }
    async encodeEnableModuleData(moduleAddress) {
        if (!__classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateModuleAddress(moduleAddress);
        const modules = await this.getModules();
        this.validateModuleIsNotEnabled(moduleAddress, modules);
        return __classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f").encode('enableModule', [moduleAddress]);
    }
    async encodeDisableModuleData(moduleAddress) {
        if (!__classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateModuleAddress(moduleAddress);
        const modules = await this.getModules();
        const moduleIndex = this.validateModuleIsEnabled(moduleAddress, modules);
        const prevModuleAddress = moduleIndex === 0 ? constants_1$c.SENTINEL_ADDRESS : modules[moduleIndex - 1];
        return __classPrivateFieldGet$5(this, _ModuleManager_safeContract, "f").encode('disableModule', [prevModuleAddress, moduleAddress]);
    }
}
_ModuleManager_ethAdapter = new WeakMap(), _ModuleManager_safeContract = new WeakMap();
moduleManager.default = ModuleManager;

var ownerManager = {};

var __classPrivateFieldSet$4 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$4 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OwnerManager_ethAdapter, _OwnerManager_safeContract;
Object.defineProperty(ownerManager, "__esModule", { value: true });
const address_1 = address$1;
const constants_1$b = constants$4;
class OwnerManager {
    constructor(ethAdapter, safeContract) {
        _OwnerManager_ethAdapter.set(this, void 0);
        _OwnerManager_safeContract.set(this, void 0);
        __classPrivateFieldSet$4(this, _OwnerManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet$4(this, _OwnerManager_safeContract, safeContract, "f");
    }
    validateOwnerAddress(ownerAddress, errorMessage) {
        const isValidAddress = __classPrivateFieldGet$4(this, _OwnerManager_ethAdapter, "f").isAddress(ownerAddress);
        if (!isValidAddress || (0, address_1.isRestrictedAddress)(ownerAddress)) {
            throw new Error(errorMessage || 'Invalid owner address provided');
        }
    }
    validateThreshold(threshold, numOwners) {
        if (threshold <= 0) {
            throw new Error('Threshold needs to be greater than 0');
        }
        if (threshold > numOwners) {
            throw new Error('Threshold cannot exceed owner count');
        }
    }
    validateAddressIsNotOwner(ownerAddress, owners, errorMessage) {
        const ownerIndex = owners.findIndex((owner) => (0, address_1.sameString)(owner, ownerAddress));
        const isOwner = ownerIndex >= 0;
        if (isOwner) {
            throw new Error(errorMessage || 'Address provided is already an owner');
        }
    }
    validateAddressIsOwner(ownerAddress, owners, errorMessage) {
        const ownerIndex = owners.findIndex((owner) => (0, address_1.sameString)(owner, ownerAddress));
        const isOwner = ownerIndex >= 0;
        if (!isOwner) {
            throw new Error(errorMessage || 'Address provided is not an owner');
        }
        return ownerIndex;
    }
    async getOwners() {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        const owners = await __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").getOwners();
        return [...owners];
    }
    async getThreshold() {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        return __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").getThreshold();
    }
    async isOwner(ownerAddress) {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        return __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").isOwner(ownerAddress);
    }
    async encodeAddOwnerWithThresholdData(ownerAddress, threshold) {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateOwnerAddress(ownerAddress);
        const owners = await this.getOwners();
        this.validateAddressIsNotOwner(ownerAddress, owners);
        const newThreshold = threshold ?? (await this.getThreshold());
        this.validateThreshold(newThreshold, owners.length + 1);
        return __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").encode('addOwnerWithThreshold', [ownerAddress, newThreshold]);
    }
    async encodeRemoveOwnerData(ownerAddress, threshold) {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateOwnerAddress(ownerAddress);
        const owners = await this.getOwners();
        const ownerIndex = this.validateAddressIsOwner(ownerAddress, owners);
        const newThreshold = threshold ?? (await this.getThreshold()) - 1;
        this.validateThreshold(newThreshold, owners.length - 1);
        const prevOwnerAddress = ownerIndex === 0 ? constants_1$b.SENTINEL_ADDRESS : owners[ownerIndex - 1];
        return __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").encode('removeOwner', [prevOwnerAddress, ownerAddress, newThreshold]);
    }
    async encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress) {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        this.validateOwnerAddress(newOwnerAddress, 'Invalid new owner address provided');
        this.validateOwnerAddress(oldOwnerAddress, 'Invalid old owner address provided');
        const owners = await this.getOwners();
        this.validateAddressIsNotOwner(newOwnerAddress, owners, 'New address provided is already an owner');
        const oldOwnerIndex = this.validateAddressIsOwner(oldOwnerAddress, owners, 'Old address provided is not an owner');
        const prevOwnerAddress = oldOwnerIndex === 0 ? constants_1$b.SENTINEL_ADDRESS : owners[oldOwnerIndex - 1];
        return __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").encode('swapOwner', [
            prevOwnerAddress,
            oldOwnerAddress,
            newOwnerAddress
        ]);
    }
    async encodeChangeThresholdData(threshold) {
        if (!__classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f")) {
            throw new Error('Safe is not deployed');
        }
        const owners = await this.getOwners();
        this.validateThreshold(threshold, owners.length);
        return __classPrivateFieldGet$4(this, _OwnerManager_safeContract, "f").encode('changeThreshold', [threshold]);
    }
}
_OwnerManager_ethAdapter = new WeakMap(), _OwnerManager_safeContract = new WeakMap();
ownerManager.default = OwnerManager;

var __classPrivateFieldSet$3 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$3 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault$N = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Safe_predictedSafe, _Safe_ethAdapter, _Safe_contractManager, _Safe_ownerManager, _Safe_moduleManager, _Safe_guardManager, _Safe_fallbackHandlerManager;
Object.defineProperty(Safe$1, "__esModule", { value: true });
const bignumber_1$5 = require$$0$7;
const safe_core_sdk_types_1 = src$5;
const utils_1$k = utils$g;
const config_1$1 = config$1;
const contractManager_1 = __importDefault$N(contractManager);
const fallbackHandlerManager_1 = __importDefault$N(fallbackHandlerManager);
const guardManager_1 = __importDefault$N(guardManager);
const moduleManager_1 = __importDefault$N(moduleManager);
const ownerManager_1 = __importDefault$N(ownerManager);
const utils_2$1 = requireUtils();
const utils_3 = utils$3;
const SafeTransaction_1 = __importDefault$N(SafeTransaction);
const utils_4 = requireUtils$1();
const types_1 = types$2;
const safeDeploymentContracts_1$1 = safeDeploymentContracts;
class Safe {
    constructor() {
        _Safe_predictedSafe.set(this, void 0);
        _Safe_ethAdapter.set(this, void 0);
        _Safe_contractManager.set(this, void 0);
        _Safe_ownerManager.set(this, void 0);
        _Safe_moduleManager.set(this, void 0);
        _Safe_guardManager.set(this, void 0);
        _Safe_fallbackHandlerManager.set(this, void 0);
    }
    /**
     * Creates an instance of the Safe Core SDK.
     * @param config - Ethers Safe configuration
     * @returns The Safe Core SDK instance
     * @throws "The SDK must be initialized with a safeAddress or a predictedSafe"
     * @throws "SafeProxy contract is not deployed on the current network"
     * @throws "MultiSend contract is not deployed on the current network"
     * @throws "MultiSendCallOnly contract is not deployed on the current network"
     */
    static async create(config) {
        const safeSdk = new Safe();
        await safeSdk.init(config);
        return safeSdk;
    }
    /**
     * Initializes the Safe Core SDK instance.
     * @param config - Safe configuration
     * @throws "Signer must be connected to a provider"
     * @throws "SafeProxy contract is not deployed on the current network"
     * @throws "MultiSend contract is not deployed on the current network"
     * @throws "MultiSendCallOnly contract is not deployed on the current network"
     */
    async init(config) {
        const { ethAdapter, isL1SafeMasterCopy, contractNetworks } = config;
        __classPrivateFieldSet$3(this, _Safe_ethAdapter, ethAdapter, "f");
        if ((0, types_1.isSafeConfigWithPredictedSafe)(config)) {
            __classPrivateFieldSet$3(this, _Safe_predictedSafe, config.predictedSafe, "f");
            __classPrivateFieldSet$3(this, _Safe_contractManager, await contractManager_1.default.create({
                ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
                predictedSafe: __classPrivateFieldGet$3(this, _Safe_predictedSafe, "f"),
                isL1SafeMasterCopy,
                contractNetworks
            }), "f");
        }
        else {
            __classPrivateFieldSet$3(this, _Safe_contractManager, await contractManager_1.default.create({
                ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
                safeAddress: config.safeAddress,
                isL1SafeMasterCopy,
                contractNetworks
            }), "f");
        }
        __classPrivateFieldSet$3(this, _Safe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet$3(this, _Safe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet$3(this, _Safe_guardManager, new guardManager_1.default(__classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet$3(this, _Safe_fallbackHandlerManager, new fallbackHandlerManager_1.default(__classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract), "f");
    }
    /**
     * Returns a new instance of the Safe Core SDK.
     * @param config - Connect Safe configuration
     * @throws "A safeAddress and a predictedSafe cannot be connected at the same time"
     * @throws "SafeProxy contract is not deployed on the current network"
     * @throws "MultiSend contract is not deployed on the current network"
     * @throws "MultiSendCallOnly contract is not deployed on the current network"
     */
    async connect(config) {
        const { ethAdapter, safeAddress, predictedSafe, isL1SafeMasterCopy, contractNetworks } = config;
        const configProps = {
            ethAdapter: ethAdapter || __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
            isL1SafeMasterCopy: isL1SafeMasterCopy || __classPrivateFieldGet$3(this, _Safe_contractManager, "f").isL1SafeMasterCopy,
            contractNetworks: contractNetworks || __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks
        };
        // A new existing Safe is connected to the Signer
        if (safeAddress) {
            return await Safe.create({
                safeAddress,
                ...configProps
            });
        }
        // A new predicted Safe is connected to the Signer
        if (predictedSafe) {
            return await Safe.create({
                predictedSafe,
                ...configProps
            });
        }
        // The previous predicted Safe is connected to a new Signer
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")) {
            return await Safe.create({
                predictedSafe: __classPrivateFieldGet$3(this, _Safe_predictedSafe, "f"),
                ...configProps
            });
        }
        // The previous existing Safe is connected to a new Signer
        return await Safe.create({
            safeAddress: await this.getAddress(),
            ...configProps
        });
    }
    /**
     * Returns the address of the current SafeProxy contract.
     *
     * @returns The address of the SafeProxy contract
     */
    async getAddress() {
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")) {
            const safeVersion = await this.getContractVersion();
            if (!(0, utils_2$1.hasSafeFeature)(utils_2$1.SAFE_FEATURES.ACCOUNT_ABSTRACTION, safeVersion)) {
                throw new Error('Account Abstraction functionality is not available for Safes with version lower than v1.3.0');
            }
            const chainId = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getChainId();
            return (0, utils_1$k.predictSafeAddress)({
                ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
                customContracts: __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks?.[chainId],
                ...__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")
            });
        }
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        return Promise.resolve(__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.getAddress());
    }
    /**
     * Returns the ContractManager
     *
     * @returns The current ContractManager
     * */
    getContractManager() {
        return __classPrivateFieldGet$3(this, _Safe_contractManager, "f");
    }
    /**
     * Returns the current EthAdapter.
     *
     * @returns The current EthAdapter
     */
    getEthAdapter() {
        return __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f");
    }
    /**
     * Returns the address of the MultiSend contract.
     *
     * @returns The address of the MultiSend contract
     */
    getMultiSendAddress() {
        return __classPrivateFieldGet$3(this, _Safe_contractManager, "f").multiSendContract.getAddress();
    }
    /**
     * Returns the address of the MultiSendCallOnly contract.
     *
     * @returns The address of the MultiSendCallOnly contract
     */
    getMultiSendCallOnlyAddress() {
        return __classPrivateFieldGet$3(this, _Safe_contractManager, "f").multiSendCallOnlyContract.getAddress();
    }
    /**
     * Checks if the current Safe is deployed.
     *
     * @returns TRUE if the Safe contract is deployed
     */
    async isSafeDeployed() {
        const safeAddress = await this.getAddress();
        const isSafeDeployed = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").isContractDeployed(safeAddress);
        return isSafeDeployed;
    }
    /**
     * Returns the Safe Master Copy contract version.
     *
     * @returns The Safe Master Copy contract version
     */
    async getContractVersion() {
        if (__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            return __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.getVersion();
        }
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")?.safeDeploymentConfig?.safeVersion) {
            return Promise.resolve(__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f").safeDeploymentConfig.safeVersion);
        }
        return Promise.resolve(config_1$1.DEFAULT_SAFE_VERSION);
    }
    /**
     * Returns the list of Safe owner accounts.
     *
     * @returns The list of owners
     */
    async getOwners() {
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")?.safeAccountConfig.owners) {
            return Promise.resolve(__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f").safeAccountConfig.owners);
        }
        return __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").getOwners();
    }
    /**
     * Returns the Safe nonce.
     *
     * @returns The Safe nonce
     */
    async getNonce() {
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            return Promise.resolve(0);
        }
        return __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.getNonce();
    }
    /**
     * Returns the Safe threshold.
     *
     * @returns The Safe threshold
     */
    async getThreshold() {
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")?.safeAccountConfig.threshold) {
            return Promise.resolve(__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f").safeAccountConfig.threshold);
        }
        return __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").getThreshold();
    }
    /**
     * Returns the chainId of the connected network.
     *
     * @returns The chainId of the connected network
     */
    async getChainId() {
        return __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getChainId();
    }
    /**
     * Returns the ETH balance of the Safe.
     *
     * @returns The ETH balance of the Safe
     */
    async getBalance() {
        return __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getBalance(await this.getAddress());
    }
    /**
     * Returns the address of the FallbackHandler contract.
     *
     * @returns The address of the FallbackHandler contract
     */
    getFallbackHandler() {
        return __classPrivateFieldGet$3(this, _Safe_fallbackHandlerManager, "f").getFallbackHandler();
    }
    /**
     * Returns the enabled Safe guard or 0x address if no guards are enabled.
     *
     * @returns The address of the enabled Safe guard
     * @throws "Current version of the Safe does not support Safe transaction guards functionality"
     */
    async getGuard() {
        return __classPrivateFieldGet$3(this, _Safe_guardManager, "f").getGuard();
    }
    /**
     * Returns the list of addresses of all the enabled Safe modules.
     *
     * @returns The list of addresses of all the enabled Safe modules
     */
    async getModules() {
        return __classPrivateFieldGet$3(this, _Safe_moduleManager, "f").getModules();
    }
    /**
     * Checks if a specific Safe module is enabled for the current Safe.
     *
     * @param moduleAddress - The desired module address
     * @returns TRUE if the module is enabled
     */
    async isModuleEnabled(moduleAddress) {
        return __classPrivateFieldGet$3(this, _Safe_moduleManager, "f").isModuleEnabled(moduleAddress);
    }
    /**
     * Checks if a specific address is an owner of the current Safe.
     *
     * @param ownerAddress - The account address
     * @returns TRUE if the account is an owner
     */
    async isOwner(ownerAddress) {
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")?.safeAccountConfig.owners) {
            return Promise.resolve(__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")?.safeAccountConfig.owners.some((owner) => (0, utils_2$1.sameString)(owner, ownerAddress)));
        }
        return __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").isOwner(ownerAddress);
    }
    /**
     * Returns a Safe transaction ready to be signed by the owners.
     *
     * @param createTransactionProps - The createTransaction props
     * @returns The Safe transaction
     * @throws "Invalid empty array of transactions"
     */
    async createTransaction({ safeTransactionData, onlyCalls = false, options }) {
        const safeVersion = await this.getContractVersion();
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f") && !(0, utils_2$1.hasSafeFeature)(utils_2$1.SAFE_FEATURES.ACCOUNT_ABSTRACTION, safeVersion)) {
            throw new Error('Account Abstraction functionality is not available for Safes with version lower than v1.3.0');
        }
        if ((0, utils_2$1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length === 0) {
            throw new Error('Invalid empty array of transactions');
        }
        let newTransaction;
        if ((0, utils_2$1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length > 1) {
            const multiSendContract = onlyCalls
                ? __classPrivateFieldGet$3(this, _Safe_contractManager, "f").multiSendCallOnlyContract
                : __classPrivateFieldGet$3(this, _Safe_contractManager, "f").multiSendContract;
            const multiSendData = (0, utils_4.encodeMultiSendData)(safeTransactionData.map(utils_4.standardizeMetaTransactionData));
            const multiSendTransaction = {
                ...options,
                to: multiSendContract.getAddress(),
                value: '0',
                data: multiSendContract.encode('multiSend', [multiSendData]),
                operation: safe_core_sdk_types_1.OperationType.DelegateCall
            };
            newTransaction = multiSendTransaction;
        }
        else {
            newTransaction = (0, utils_2$1.isMetaTransactionArray)(safeTransactionData)
                ? { ...options, ...safeTransactionData[0] }
                : safeTransactionData;
        }
        if (__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")) {
            return new SafeTransaction_1.default(await (0, utils_4.standardizeSafeTransactionData)({
                predictedSafe: __classPrivateFieldGet$3(this, _Safe_predictedSafe, "f"),
                ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
                tx: newTransaction,
                contractNetworks: __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks
            }));
        }
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        return new SafeTransaction_1.default(await (0, utils_4.standardizeSafeTransactionData)({
            safeContract: __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract,
            ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
            tx: newTransaction,
            contractNetworks: __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks
        }));
    }
    /**
     * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.
     *
     * @param nonce - The nonce of the transaction/s that are going to be rejected
     * @returns The Safe transaction that invalidates the pending Safe transaction/s
     */
    async createRejectionTransaction(nonce) {
        const safeTransactionData = {
            to: await this.getAddress(),
            nonce,
            value: '0',
            data: '0x',
            safeTxGas: '0'
        };
        return this.createTransaction({ safeTransactionData });
    }
    /**
     * Copies a Safe transaction
     *
     * @param safeTransaction - The Safe transaction
     * @returns The new Safe transaction
     */
    async copyTransaction(safeTransaction) {
        const signedSafeTransaction = await this.createTransaction({
            safeTransactionData: safeTransaction.data
        });
        safeTransaction.signatures.forEach((signature) => {
            signedSafeTransaction.addSignature(signature);
        });
        return signedSafeTransaction;
    }
    /**
     * Returns the transaction hash of a Safe transaction.
     *
     * @param safeTransaction - The Safe transaction
     * @returns The transaction hash of the Safe transaction
     */
    async getTransactionHash(safeTransaction) {
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        const safeTransactionData = safeTransaction.data;
        const txHash = await __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.getTransactionHash(safeTransactionData);
        return txHash;
    }
    /**
     * Signs a hash using the current signer account.
     *
     * @param hash - The hash to sign
     * @returns The Safe signature
     */
    async signTransactionHash(hash) {
        return (0, utils_3.generateSignature)(__classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"), hash);
    }
    /**
     * Signs a transaction according to the EIP-712 using the current signer account.
     *
     * @param safeTransaction - The Safe transaction to be signed
     * @param methodVersion - EIP-712 version. Optional
     * @returns The Safe signature
     */
    async signTypedData(safeTransaction, methodVersion) {
        const safeTransactionEIP712Args = {
            safeAddress: await this.getAddress(),
            safeVersion: await this.getContractVersion(),
            chainId: await this.getEthAdapter().getChainId(),
            safeTransactionData: safeTransaction.data
        };
        return (0, utils_3.generateEIP712Signature)(__classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"), safeTransactionEIP712Args, methodVersion);
    }
    /**
     * Adds the signature of the current signer to the Safe transaction object.
     *
     * @param safeTransaction - The Safe transaction to be signed
     * @param signingMethod - Method followed to sign a transaction. Optional. Default value is "eth_sign"
     * @returns The signed Safe transaction
     * @throws "Transactions can only be signed by Safe owners"
     */
    async signTransaction(safeTransaction, signingMethod = 'eth_signTypedData_v4') {
        const transaction = (0, utils_2$1.isSafeMultisigTransactionResponse)(safeTransaction)
            ? await this.toSafeTransactionType(safeTransaction)
            : safeTransaction;
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        const addressIsOwner = owners.some((owner) => signerAddress && (0, utils_2$1.sameString)(owner, signerAddress));
        if (!addressIsOwner) {
            throw new Error('Transactions can only be signed by Safe owners');
        }
        let signature;
        if (signingMethod === 'eth_signTypedData_v4') {
            signature = await this.signTypedData(transaction, 'v4');
        }
        else if (signingMethod === 'eth_signTypedData_v3') {
            signature = await this.signTypedData(transaction, 'v3');
        }
        else if (signingMethod === 'eth_signTypedData') {
            signature = await this.signTypedData(transaction);
        }
        else {
            const safeVersion = await this.getContractVersion();
            if (!(0, utils_2$1.hasSafeFeature)(utils_2$1.SAFE_FEATURES.ETH_SIGN, safeVersion)) {
                throw new Error('eth_sign is only supported by Safes >= v1.1.0');
            }
            const txHash = await this.getTransactionHash(transaction);
            signature = await this.signTransactionHash(txHash);
        }
        const signedSafeTransaction = await this.createTransaction({
            safeTransactionData: transaction.data
        });
        transaction.signatures.forEach((signature) => {
            signedSafeTransaction.addSignature(signature);
        });
        signedSafeTransaction.addSignature(signature);
        return signedSafeTransaction;
    }
    /**
     * Approves on-chain a hash using the current signer account.
     *
     * @param hash - The hash to approve
     * @param options - The Safe transaction execution options. Optional
     * @returns The Safe transaction response
     * @throws "Transaction hashes can only be approved by Safe owners"
     * @throws "Cannot specify gas and gasLimit together in transaction options"
     */
    async approveTransactionHash(hash, options) {
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        const addressIsOwner = owners.some((owner) => signerAddress && (0, utils_2$1.sameString)(owner, signerAddress));
        if (!addressIsOwner) {
            throw new Error('Transaction hashes can only be approved by Safe owners');
        }
        if (options?.gas && options?.gasLimit) {
            throw new Error('Cannot specify gas and gasLimit together in transaction options');
        }
        return __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.approveHash(hash, {
            from: signerAddress,
            ...options
        });
    }
    /**
     * Returns a list of owners who have approved a specific Safe transaction.
     *
     * @param txHash - The Safe transaction hash
     * @returns The list of owners
     */
    async getOwnersWhoApprovedTx(txHash) {
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        const owners = await this.getOwners();
        const ownersWhoApproved = [];
        for (const owner of owners) {
            const approved = await __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.approvedHashes(owner, txHash);
            if (approved.gt(0)) {
                ownersWhoApproved.push(owner);
            }
        }
        return ownersWhoApproved;
    }
    /**
     * Returns the Safe transaction to enable the fallback handler.
     *
     * @param address - The new fallback handler address
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid fallback handler address provided"
     * @throws "Fallback handler provided is already enabled"
     * @throws "Current version of the Safe does not support the fallback handler functionality"
     */
    async createEnableFallbackHandlerTx(fallbackHandlerAddress, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_fallbackHandlerManager, "f").encodeEnableFallbackHandlerData(fallbackHandlerAddress),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to disable the fallback handler.
     *
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "There is no fallback handler enabled yet"
     * @throws "Current version of the Safe does not support the fallback handler functionality"
     */
    async createDisableFallbackHandlerTx(options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_fallbackHandlerManager, "f").encodeDisableFallbackHandlerData(),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to enable a Safe guard.
     *
     * @param guardAddress - The desired guard address
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid guard address provided"
     * @throws "Guard provided is already enabled"
     * @throws "Current version of the Safe does not support Safe transaction guards functionality"
     */
    async createEnableGuardTx(guardAddress, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_guardManager, "f").encodeEnableGuardData(guardAddress),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to disable a Safe guard.
     *
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "There is no guard enabled yet"
     * @throws "Current version of the Safe does not support Safe transaction guards functionality"
     */
    async createDisableGuardTx(options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_guardManager, "f").encodeDisableGuardData(),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to enable a Safe module.
     *
     * @param moduleAddress - The desired module address
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid module address provided"
     * @throws "Module provided is already enabled"
     */
    async createEnableModuleTx(moduleAddress, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_moduleManager, "f").encodeEnableModuleData(moduleAddress),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to disable a Safe module.
     *
     * @param moduleAddress - The desired module address
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid module address provided"
     * @throws "Module provided is not enabled already"
     */
    async createDisableModuleTx(moduleAddress, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_moduleManager, "f").encodeDisableModuleData(moduleAddress),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to add an owner and optionally change the threshold.
     *
     * @param params - The transaction params
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid owner address provided"
     * @throws "Address provided is already an owner"
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    async createAddOwnerTx({ ownerAddress, threshold }, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").encodeAddOwnerWithThresholdData(ownerAddress, threshold),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to remove an owner and optionally change the threshold.
     *
     * @param params - The transaction params
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid owner address provided"
     * @throws "Address provided is not an owner"
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    async createRemoveOwnerTx({ ownerAddress, threshold }, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").encodeRemoveOwnerData(ownerAddress, threshold),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to replace an owner of the Safe with a new one.
     *
     * @param params - The transaction params
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid new owner address provided"
     * @throws "Invalid old owner address provided"
     * @throws "New address provided is already an owner"
     * @throws "Old address provided is not an owner"
     */
    async createSwapOwnerTx({ oldOwnerAddress, newOwnerAddress }, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to change the threshold.
     *
     * @param threshold - The new threshold
     * @param options - The transaction optional properties
     * @returns The Safe transaction ready to be signed
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    async createChangeThresholdTx(threshold, options) {
        const safeTransactionData = {
            to: await this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet$3(this, _Safe_ownerManager, "f").encodeChangeThresholdData(threshold),
            ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
    }
    /**
     * Converts a transaction from type SafeMultisigTransactionResponse to type SafeTransaction
     *
     * @param serviceTransactionResponse - The transaction to convert
     * @returns The converted transaction with type SafeTransaction
     */
    async toSafeTransactionType(serviceTransactionResponse) {
        const safeTransactionData = {
            to: serviceTransactionResponse.to,
            value: serviceTransactionResponse.value,
            data: serviceTransactionResponse.data || '0x',
            operation: serviceTransactionResponse.operation,
            safeTxGas: serviceTransactionResponse.safeTxGas.toString(),
            baseGas: serviceTransactionResponse.baseGas.toString(),
            gasPrice: serviceTransactionResponse.gasPrice,
            gasToken: serviceTransactionResponse.gasToken,
            refundReceiver: serviceTransactionResponse.refundReceiver,
            nonce: serviceTransactionResponse.nonce
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        serviceTransactionResponse.confirmations?.map((confirmation) => {
            const signature = new utils_2$1.EthSafeSignature(confirmation.owner, confirmation.signature);
            safeTransaction.addSignature(signature);
        });
        return safeTransaction;
    }
    /**
     * Checks if a Safe transaction can be executed successfully with no errors.
     *
     * @param safeTransaction - The Safe transaction to check
     * @param options - The Safe transaction execution options. Optional
     * @returns TRUE if the Safe transaction can be executed successfully with no errors
     */
    async isValidTransaction(safeTransaction, options) {
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        const transaction = (0, utils_2$1.isSafeMultisigTransactionResponse)(safeTransaction)
            ? await this.toSafeTransactionType(safeTransaction)
            : safeTransaction;
        const signedSafeTransaction = await this.copyTransaction(transaction);
        const txHash = await this.getTransactionHash(signedSafeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
            signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(owner));
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        if (owners.includes(signerAddress)) {
            signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(signerAddress));
        }
        const isTxValid = await __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.isValidTransaction(signedSafeTransaction, {
            from: signerAddress,
            ...options
        });
        return isTxValid;
    }
    /**
     * Executes a Safe transaction.
     *
     * @param safeTransaction - The Safe transaction to execute
     * @param options - The Safe transaction execution options. Optional
     * @returns The Safe transaction response
     * @throws "No signer provided"
     * @throws "There are X signatures missing"
     * @throws "Cannot specify gas and gasLimit together in transaction options"
     */
    async executeTransaction(safeTransaction, options) {
        if (!__classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract) {
            throw new Error('Safe is not deployed');
        }
        const transaction = (0, utils_2$1.isSafeMultisigTransactionResponse)(safeTransaction)
            ? await this.toSafeTransactionType(safeTransaction)
            : safeTransaction;
        const signedSafeTransaction = await this.copyTransaction(transaction);
        const txHash = await this.getTransactionHash(signedSafeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
            signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(owner));
        }
        const owners = await this.getOwners();
        const threshold = await this.getThreshold();
        const signerAddress = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (threshold > signedSafeTransaction.signatures.size &&
            signerAddress &&
            owners.includes(signerAddress)) {
            signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(signerAddress));
        }
        if (threshold > signedSafeTransaction.signatures.size) {
            const signaturesMissing = threshold - signedSafeTransaction.signatures.size;
            throw new Error(`There ${signaturesMissing > 1 ? 'are' : 'is'} ${signaturesMissing} signature${signaturesMissing > 1 ? 's' : ''} missing`);
        }
        const value = bignumber_1$5.BigNumber.from(signedSafeTransaction.data.value);
        if (!value.isZero()) {
            const balance = await this.getBalance();
            if (value.gt(bignumber_1$5.BigNumber.from(balance))) {
                throw new Error('Not enough Ether funds');
            }
        }
        if (options?.gas && options?.gasLimit) {
            throw new Error('Cannot specify gas and gasLimit together in transaction options');
        }
        const txResponse = await __classPrivateFieldGet$3(this, _Safe_contractManager, "f").safeContract.execTransaction(signedSafeTransaction, {
            from: signerAddress,
            ...options
        });
        return txResponse;
    }
    /**
     * Returns the Safe Transaction encoded
     *
     * @async
     * @param {SafeTransaction} safeTransaction - The Safe transaction to be encoded.
     * @returns {Promise<string>} The encoded transaction
     *
     */
    async getEncodedTransaction(safeTransaction) {
        const safeVersion = await this.getContractVersion();
        const chainId = await this.getChainId();
        const customContracts = __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks?.[chainId];
        const isL1SafeMasterCopy = __classPrivateFieldGet$3(this, _Safe_contractManager, "f").isL1SafeMasterCopy;
        const safeSingletonContract = await (0, safeDeploymentContracts_1$1.getSafeContract)({
            ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
            safeVersion: safeVersion,
            isL1SafeMasterCopy,
            customContracts
        });
        const encodedTransaction = safeSingletonContract.encode('execTransaction', [
            safeTransaction.data.to,
            safeTransaction.data.value,
            safeTransaction.data.data,
            safeTransaction.data.operation,
            safeTransaction.data.safeTxGas,
            safeTransaction.data.baseGas,
            safeTransaction.data.gasPrice,
            safeTransaction.data.gasToken,
            safeTransaction.data.refundReceiver,
            safeTransaction.encodedSignatures()
        ]);
        return encodedTransaction;
    }
    /**
     * Wraps a Safe transaction into a Safe deployment batch.
     *
     * This function creates a transaction batch of 2 transactions, which includes the
     * deployment of the Safe and the provided Safe transaction.
     *
     * @async
     * @param {SafeTransaction} safeTransaction - The Safe transaction to be wrapped into the deployment batch.
     * @param {TransactionOptions} [transactionOptions] - Optional. Options for the transaction, such as from, gas price, gas limit, etc.
     * @param {string} [customSaltNonce] - Optional. a Custom salt nonce to be used for the deployment of the Safe. If not provided, a default value is used.
     * @returns {Promise<Transaction>} A promise that resolves to a Transaction object representing the prepared batch of transactions.
     * @throws Will throw an error if the safe is already deployed.
     *
     */
    async wrapSafeTransactionIntoDeploymentBatch(safeTransaction, transactionOptions, customSaltNonce) {
        const isSafeDeployed = await this.isSafeDeployed();
        // if the safe is already deployed throws an error
        if (isSafeDeployed) {
            throw new Error('Safe already deployed');
        }
        // we create the deployment transaction
        const safeDeploymentTransaction = await this.createSafeDeploymentTransaction(customSaltNonce);
        // First transaction of the batch: The Safe deployment Transaction
        const safeDeploymentBatchTransaction = {
            to: safeDeploymentTransaction.to,
            value: safeDeploymentTransaction.value,
            data: safeDeploymentTransaction.data,
            operation: safe_core_sdk_types_1.OperationType.Call
        };
        // Second transaction of the batch: The Safe Transaction
        const safeBatchTransaction = {
            to: await this.getAddress(),
            value: '0',
            data: await this.getEncodedTransaction(safeTransaction),
            operation: safe_core_sdk_types_1.OperationType.Call
        };
        // transactions for the batch
        const transactions = [safeDeploymentBatchTransaction, safeBatchTransaction];
        // this is the transaction with the batch
        const safeDeploymentBatch = await this.createTransactionBatch(transactions, transactionOptions);
        return safeDeploymentBatch;
    }
    /**
     * Creates a Safe deployment transaction.
     *
     * This function prepares a transaction for the deployment of a Safe.
     * Both the saltNonce and options parameters are optional, and if not
     * provided, default values will be used.
     *
     * @async
     * @param {string} [customSaltNonce] - Optional. a Custom salt nonce to be used for the deployment of the Safe. If not provided, a default value is used.
     * @param {TransactionOptions} [options] - Optional. Options for the transaction, such as gas price, gas limit, etc.
     * @returns {Promise<Transaction>} A promise that resolves to a Transaction object representing the prepared Safe deployment transaction.
     *
     */
    async createSafeDeploymentTransaction(customSaltNonce, transactionOptions) {
        if (!__classPrivateFieldGet$3(this, _Safe_predictedSafe, "f")) {
            throw new Error('Predict Safe should be present');
        }
        const { safeAccountConfig, safeDeploymentConfig } = __classPrivateFieldGet$3(this, _Safe_predictedSafe, "f");
        const safeVersion = await this.getContractVersion();
        const ethAdapter = __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f");
        const chainId = await ethAdapter.getChainId();
        const isL1SafeMasterCopy = __classPrivateFieldGet$3(this, _Safe_contractManager, "f").isL1SafeMasterCopy;
        const customContracts = __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks?.[chainId];
        const safeSingletonContract = await (0, safeDeploymentContracts_1$1.getSafeContract)({
            ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
            safeVersion,
            isL1SafeMasterCopy,
            customContracts
        });
        // we use the SafeProxyFactory.sol contract, see: https://github.com/safe-global/safe-contracts/blob/main/contracts/proxies/SafeProxyFactory.sol
        const safeProxyFactoryContract = await (0, safeDeploymentContracts_1$1.getProxyFactoryContract)({
            ethAdapter,
            safeVersion,
            customContracts
        });
        // this is the call to the setup method that sets the threshold & owners of the new Safe, see: https://github.com/safe-global/safe-contracts/blob/main/contracts/Safe.sol#L95
        const initializer = await (0, utils_1$k.encodeSetupCallData)({
            ethAdapter,
            safeContract: safeSingletonContract,
            safeAccountConfig: safeAccountConfig,
            customContracts
        });
        const saltNonce = customSaltNonce || safeDeploymentConfig?.saltNonce || utils_1$k.PREDETERMINED_SALT_NONCE;
        const safeDeployTransactionData = {
            ...transactionOptions,
            to: safeProxyFactoryContract.getAddress(),
            value: '0',
            // we use the createProxyWithNonce method to create the Safe in a deterministic address, see: https://github.com/safe-global/safe-contracts/blob/main/contracts/proxies/SafeProxyFactory.sol#L52
            data: safeProxyFactoryContract.encode('createProxyWithNonce', [
                safeSingletonContract.getAddress(),
                initializer,
                saltNonce
            ])
        };
        return safeDeployTransactionData;
    }
    /**
     * This function creates a batch of the provided Safe transactions using the MultiSend contract.
     * It groups the transactions together into a single transaction which can then be executed atomically.
     *
     * @async
     * @function createTransactionBatch
     * @param {MetaTransactionData[]} transactions - An array of MetaTransactionData objects to be batched together.
     * @param {TransactionOption} [transactionOptions] - Optional TransactionOption object to specify additional options for the transaction batch.
     * @returns {Promise<Transaction>} A Promise that resolves with the created transaction batch.
     *
     */
    async createTransactionBatch(transactions, transactionOptions) {
        const chainId = await __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f").getChainId();
        // we use the MultiSend contract to create the batch, see: https://github.com/safe-global/safe-contracts/blob/main/contracts/libraries/MultiSendCallOnly.sol
        const multiSendCallOnlyContract = await (0, safeDeploymentContracts_1$1.getMultiSendCallOnlyContract)({
            ethAdapter: __classPrivateFieldGet$3(this, _Safe_ethAdapter, "f"),
            safeVersion: await this.getContractVersion(),
            customContracts: __classPrivateFieldGet$3(this, _Safe_contractManager, "f").contractNetworks?.[chainId]
        });
        // multiSend method with the transactions encoded
        const batchData = multiSendCallOnlyContract.encode('multiSend', [
            (0, utils_4.encodeMultiSendData)(transactions) // encoded transactions
        ]);
        const transactionBatch = {
            ...transactionOptions,
            to: multiSendCallOnlyContract.getAddress(),
            value: '0',
            data: batchData
        };
        return transactionBatch;
    }
}
_Safe_predictedSafe = new WeakMap(), _Safe_ethAdapter = new WeakMap(), _Safe_contractManager = new WeakMap(), _Safe_ownerManager = new WeakMap(), _Safe_moduleManager = new WeakMap(), _Safe_guardManager = new WeakMap(), _Safe_fallbackHandlerManager = new WeakMap();
Safe$1.default = Safe;

var ethers = {};

var EthersAdapter$1 = {};

var contractInstancesEthers = {};

var Gnosis_safe__factory$7 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Gnosis_safe__factory$7, "__esModule", { value: true });
Gnosis_safe__factory$7.Gnosis_safe__factory = void 0;
const ethers_1$l = require$$0$d;
const _abi$l = [
    {
        constant: false,
        inputs: [
            {
                name: "owner",
                type: "address",
            },
            {
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "DOMAIN_SEPARATOR_TYPEHASH",
        outputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "owner",
                type: "address",
            },
        ],
        name: "isOwner",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "to",
                type: "address",
            },
            {
                name: "value",
                type: "uint256",
            },
            {
                name: "data",
                type: "bytes",
            },
            {
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                name: "success",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        name: "signedMessages",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "module",
                type: "address",
            },
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "",
                type: "address",
            },
            {
                name: "",
                type: "bytes32",
            },
        ],
        name: "approvedHashes",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_masterCopy",
                type: "address",
            },
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "SENTINEL_MODULES",
        outputs: [
            {
                name: "",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "SENTINEL_OWNERS",
        outputs: [
            {
                name: "",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
            {
                name: "",
                type: "address[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
            {
                name: "",
                type: "address[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "SAFE_MSG_TYPEHASH",
        outputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "SAFE_TX_TYPEHASH",
        outputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "prevModule",
                type: "address",
            },
            {
                name: "module",
                type: "address",
            },
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "prevOwner",
                type: "address",
            },
            {
                name: "oldOwner",
                type: "address",
            },
            {
                name: "newOwner",
                type: "address",
            },
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "prevOwner",
                type: "address",
            },
            {
                name: "owner",
                type: "address",
            },
            {
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "txHash",
                type: "bytes32",
            },
        ],
        name: "ExecutionFailed",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "owner",
                type: "address",
            },
        ],
        name: "AddedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "owner",
                type: "address",
            },
        ],
        name: "RemovedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "threshold",
                type: "uint256",
            },
        ],
        name: "ChangedThreshold",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "module",
                type: "address",
            },
        ],
        name: "EnabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "module",
                type: "address",
            },
        ],
        name: "DisabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "newContract",
                type: "address",
            },
        ],
        name: "ContractCreation",
        type: "event",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_owners",
                type: "address[]",
            },
            {
                name: "_threshold",
                type: "uint256",
            },
            {
                name: "to",
                type: "address",
            },
            {
                name: "data",
                type: "bytes",
            },
            {
                name: "paymentToken",
                type: "address",
            },
            {
                name: "payment",
                type: "uint256",
            },
            {
                name: "paymentReceiver",
                type: "address",
            },
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "to",
                type: "address",
            },
            {
                name: "value",
                type: "uint256",
            },
            {
                name: "data",
                type: "bytes",
            },
            {
                name: "operation",
                type: "uint8",
            },
            {
                name: "safeTxGas",
                type: "uint256",
            },
            {
                name: "baseGas",
                type: "uint256",
            },
            {
                name: "gasPrice",
                type: "uint256",
            },
            {
                name: "gasToken",
                type: "address",
            },
            {
                name: "refundReceiver",
                type: "address",
            },
            {
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "execTransaction",
        outputs: [
            {
                name: "success",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "to",
                type: "address",
            },
            {
                name: "value",
                type: "uint256",
            },
            {
                name: "data",
                type: "bytes",
            },
            {
                name: "operation",
                type: "uint8",
            },
        ],
        name: "requiredTxGas",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "hashToApprove",
                type: "bytes32",
            },
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_data",
                type: "bytes",
            },
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_data",
                type: "bytes",
            },
            {
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                name: "",
                type: "bytes4",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "to",
                type: "address",
            },
            {
                name: "value",
                type: "uint256",
            },
            {
                name: "data",
                type: "bytes",
            },
            {
                name: "operation",
                type: "uint8",
            },
            {
                name: "safeTxGas",
                type: "uint256",
            },
            {
                name: "baseGas",
                type: "uint256",
            },
            {
                name: "gasPrice",
                type: "uint256",
            },
            {
                name: "gasToken",
                type: "address",
            },
            {
                name: "refundReceiver",
                type: "address",
            },
            {
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "encodeTransactionData",
        outputs: [
            {
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "to",
                type: "address",
            },
            {
                name: "value",
                type: "uint256",
            },
            {
                name: "data",
                type: "bytes",
            },
            {
                name: "operation",
                type: "uint8",
            },
            {
                name: "safeTxGas",
                type: "uint256",
            },
            {
                name: "baseGas",
                type: "uint256",
            },
            {
                name: "gasPrice",
                type: "uint256",
            },
            {
                name: "gasToken",
                type: "address",
            },
            {
                name: "refundReceiver",
                type: "address",
            },
            {
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "getTransactionHash",
        outputs: [
            {
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
];
class Gnosis_safe__factory$6 {
    static createInterface() {
        return new ethers_1$l.utils.Interface(_abi$l);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$l.Contract(address, _abi$l, signerOrProvider);
    }
}
Gnosis_safe__factory$7.Gnosis_safe__factory = Gnosis_safe__factory$6;
Gnosis_safe__factory$6.abi = _abi$l;

var Proxy_factory__factory$5 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Proxy_factory__factory$5, "__esModule", { value: true });
Proxy_factory__factory$5.Proxy_factory__factory = void 0;
const ethers_1$k = require$$0$d;
const _abi$k = [
    {
        constant: false,
        inputs: [
            {
                name: "_mastercopy",
                type: "address",
            },
            {
                name: "initializer",
                type: "bytes",
            },
            {
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "createProxyWithNonce",
        outputs: [
            {
                name: "proxy",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
            {
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "pure",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "masterCopy",
                type: "address",
            },
            {
                name: "data",
                type: "bytes",
            },
        ],
        name: "createProxy",
        outputs: [
            {
                name: "proxy",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
            {
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "pure",
        type: "function",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "proxy",
                type: "address",
            },
        ],
        name: "ProxyCreation",
        type: "event",
    },
];
class Proxy_factory__factory$4 {
    static createInterface() {
        return new ethers_1$k.utils.Interface(_abi$k);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$k.Contract(address, _abi$k, signerOrProvider);
    }
}
Proxy_factory__factory$5.Proxy_factory__factory = Proxy_factory__factory$4;
Proxy_factory__factory$4.abi = _abi$k;

var Gnosis_safe__factory$5 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Gnosis_safe__factory$5, "__esModule", { value: true });
Gnosis_safe__factory$5.Gnosis_safe__factory = void 0;
const ethers_1$j = require$$0$d;
const _abi$j = [
    {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "AddedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "approvedHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "ApproveHash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "masterCopy",
                type: "address",
            },
        ],
        name: "ChangedMasterCopy",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "threshold",
                type: "uint256",
            },
        ],
        name: "ChangedThreshold",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "DisabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "EnabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "RemovedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "msgHash",
                type: "bytes32",
            },
        ],
        name: "SignMsg",
        type: "event",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "approvedHashes",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "_masterCopy",
                type: "address",
            },
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "contract Module",
                name: "prevModule",
                type: "address",
            },
            {
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "start",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "pageSize",
                type: "uint256",
            },
        ],
        name: "getModulesPaginated",
        outputs: [
            {
                internalType: "address[]",
                name: "array",
                type: "address[]",
            },
            {
                internalType: "address",
                name: "next",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "isOwner",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "handler",
                type: "address",
            },
        ],
        name: "setFallbackHandler",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "signedMessages",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "oldOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "newOwner",
                type: "address",
            },
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address[]",
                name: "_owners",
                type: "address[]",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "address",
                name: "fallbackHandler",
                type: "address",
            },
            {
                internalType: "address",
                name: "paymentToken",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
            {
                internalType: "address payable",
                name: "paymentReceiver",
                type: "address",
            },
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "execTransaction",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "requiredTxGas",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes32",
                name: "hashToApprove",
                type: "bytes32",
            },
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "encodeTransactionData",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "getTransactionHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
];
class Gnosis_safe__factory$4 {
    static createInterface() {
        return new ethers_1$j.utils.Interface(_abi$j);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$j.Contract(address, _abi$j, signerOrProvider);
    }
}
Gnosis_safe__factory$5.Gnosis_safe__factory = Gnosis_safe__factory$4;
Gnosis_safe__factory$4.abi = _abi$j;

var Multi_send__factory$5 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Multi_send__factory$5, "__esModule", { value: true });
Multi_send__factory$5.Multi_send__factory = void 0;
const ethers_1$i = require$$0$d;
const _abi$i = [
    {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes",
                name: "transactions",
                type: "bytes",
            },
        ],
        name: "multiSend",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Multi_send__factory$4 {
    static createInterface() {
        return new ethers_1$i.utils.Interface(_abi$i);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$i.Contract(address, _abi$i, signerOrProvider);
    }
}
Multi_send__factory$5.Multi_send__factory = Multi_send__factory$4;
Multi_send__factory$4.abi = _abi$i;

var Proxy_factory__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Proxy_factory__factory$3, "__esModule", { value: true });
Proxy_factory__factory$3.Proxy_factory__factory = void 0;
const ethers_1$h = require$$0$d;
const _abi$h = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        name: "ProxyCreation",
        type: "event",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "masterCopy",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "createProxy",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "pure",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "pure",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "_mastercopy",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "createProxyWithNonce",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "_mastercopy",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
            {
                internalType: "contract IProxyCreationCallback",
                name: "callback",
                type: "address",
            },
        ],
        name: "createProxyWithCallback",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "_mastercopy",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "calculateCreateProxyWithNonceAddress",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Proxy_factory__factory$2 {
    static createInterface() {
        return new ethers_1$h.utils.Interface(_abi$h);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$h.Contract(address, _abi$h, signerOrProvider);
    }
}
Proxy_factory__factory$3.Proxy_factory__factory = Proxy_factory__factory$2;
Proxy_factory__factory$2.abi = _abi$h;

var Gnosis_safe__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Gnosis_safe__factory$3, "__esModule", { value: true });
Gnosis_safe__factory$3.Gnosis_safe__factory = void 0;
const ethers_1$g = require$$0$d;
const _abi$g = [
    {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "AddedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "approvedHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "ApproveHash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "masterCopy",
                type: "address",
            },
        ],
        name: "ChangedMasterCopy",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "threshold",
                type: "uint256",
            },
        ],
        name: "ChangedThreshold",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "DisabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "EnabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "RemovedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "msgHash",
                type: "bytes32",
            },
        ],
        name: "SignMsg",
        type: "event",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "approvedHashes",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "_masterCopy",
                type: "address",
            },
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "contract Module",
                name: "prevModule",
                type: "address",
            },
            {
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "start",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "pageSize",
                type: "uint256",
            },
        ],
        name: "getModulesPaginated",
        outputs: [
            {
                internalType: "address[]",
                name: "array",
                type: "address[]",
            },
            {
                internalType: "address",
                name: "next",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "contract Module",
                name: "module",
                type: "address",
            },
        ],
        name: "isModuleEnabled",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "isOwner",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "handler",
                type: "address",
            },
        ],
        name: "setFallbackHandler",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "signedMessages",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "oldOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "newOwner",
                type: "address",
            },
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address[]",
                name: "_owners",
                type: "address[]",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "address",
                name: "fallbackHandler",
                type: "address",
            },
            {
                internalType: "address",
                name: "paymentToken",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
            {
                internalType: "address payable",
                name: "paymentReceiver",
                type: "address",
            },
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "execTransaction",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        payable: true,
        stateMutability: "payable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "requiredTxGas",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes32",
                name: "hashToApprove",
                type: "bytes32",
            },
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "encodeTransactionData",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "getTransactionHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
];
class Gnosis_safe__factory$2 {
    static createInterface() {
        return new ethers_1$g.utils.Interface(_abi$g);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$g.Contract(address, _abi$g, signerOrProvider);
    }
}
Gnosis_safe__factory$3.Gnosis_safe__factory = Gnosis_safe__factory$2;
Gnosis_safe__factory$2.abi = _abi$g;

var Compatibility_fallback_handler__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Compatibility_fallback_handler__factory$3, "__esModule", { value: true });
Compatibility_fallback_handler__factory$3.Compatibility_fallback_handler__factory = void 0;
const ethers_1$f = require$$0$d;
const _abi$f = [
    {
        inputs: [],
        name: "NAME",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "contract GnosisSafe",
                name: "safe",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHashForSafe",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getModules",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_dataHash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]",
            },
            {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "onERC1155BatchReceived",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "onERC1155Received",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "onERC721Received",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "targetContract",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "calldataPayload",
                type: "bytes",
            },
        ],
        name: "simulate",
        outputs: [
            {
                internalType: "bytes",
                name: "response",
                type: "bytes",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "interfaceId",
                type: "bytes4",
            },
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function",
    },
];
class Compatibility_fallback_handler__factory$2 {
    static createInterface() {
        return new ethers_1$f.utils.Interface(_abi$f);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$f.Contract(address, _abi$f, signerOrProvider);
    }
}
Compatibility_fallback_handler__factory$3.Compatibility_fallback_handler__factory = Compatibility_fallback_handler__factory$2;
Compatibility_fallback_handler__factory$2.abi = _abi$f;

var Create_call__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Create_call__factory$3, "__esModule", { value: true });
Create_call__factory$3.Create_call__factory = void 0;
const ethers_1$e = require$$0$d;
const _abi$e = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "newContract",
                type: "address",
            },
        ],
        name: "ContractCreation",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "deploymentData",
                type: "bytes",
            },
        ],
        name: "performCreate",
        outputs: [
            {
                internalType: "address",
                name: "newContract",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "deploymentData",
                type: "bytes",
            },
            {
                internalType: "bytes32",
                name: "salt",
                type: "bytes32",
            },
        ],
        name: "performCreate2",
        outputs: [
            {
                internalType: "address",
                name: "newContract",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Create_call__factory$2 {
    static createInterface() {
        return new ethers_1$e.utils.Interface(_abi$e);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$e.Contract(address, _abi$e, signerOrProvider);
    }
}
Create_call__factory$3.Create_call__factory = Create_call__factory$2;
Create_call__factory$2.abi = _abi$e;

var Gnosis_safe__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Gnosis_safe__factory$1, "__esModule", { value: true });
Gnosis_safe__factory$1.Gnosis_safe__factory = void 0;
const ethers_1$d = require$$0$d;
const _abi$d = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "AddedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "approvedHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "ApproveHash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "handler",
                type: "address",
            },
        ],
        name: "ChangedFallbackHandler",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "guard",
                type: "address",
            },
        ],
        name: "ChangedGuard",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "threshold",
                type: "uint256",
            },
        ],
        name: "ChangedThreshold",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "DisabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "EnabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "RemovedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
        ],
        name: "SafeReceived",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "initiator",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address[]",
                name: "owners",
                type: "address[]",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "threshold",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "address",
                name: "initializer",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "fallbackHandler",
                type: "address",
            },
        ],
        name: "SafeSetup",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "msgHash",
                type: "bytes32",
            },
        ],
        name: "SignMsg",
        type: "event",
    },
    {
        stateMutability: "nonpayable",
        type: "fallback",
    },
    {
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "hashToApprove",
                type: "bytes32",
            },
        ],
        name: "approveHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "approvedHashes",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "changeThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "dataHash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "requiredSignatures",
                type: "uint256",
            },
        ],
        name: "checkNSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "dataHash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "checkSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevModule",
                type: "address",
            },
            {
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "domainSeparator",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "encodeTransactionData",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "execTransaction",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "getChainId",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "start",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "pageSize",
                type: "uint256",
            },
        ],
        name: "getModulesPaginated",
        outputs: [
            {
                internalType: "address[]",
                name: "array",
                type: "address[]",
            },
            {
                internalType: "address",
                name: "next",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getOwners",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "offset",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "length",
                type: "uint256",
            },
        ],
        name: "getStorageAt",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getThreshold",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "getTransactionHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "isModuleEnabled",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "isOwner",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "nonce",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "removeOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "requiredTxGas",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "handler",
                type: "address",
            },
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "guard",
                type: "address",
            },
        ],
        name: "setGuard",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_owners",
                type: "address[]",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "address",
                name: "fallbackHandler",
                type: "address",
            },
            {
                internalType: "address",
                name: "paymentToken",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
            {
                internalType: "address payable",
                name: "paymentReceiver",
                type: "address",
            },
        ],
        name: "setup",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "signedMessages",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "targetContract",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "calldataPayload",
                type: "bytes",
            },
        ],
        name: "simulateAndRevert",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "oldOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "newOwner",
                type: "address",
            },
        ],
        name: "swapOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        stateMutability: "payable",
        type: "receive",
    },
];
class Gnosis_safe__factory {
    static createInterface() {
        return new ethers_1$d.utils.Interface(_abi$d);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$d.Contract(address, _abi$d, signerOrProvider);
    }
}
Gnosis_safe__factory$1.Gnosis_safe__factory = Gnosis_safe__factory;
Gnosis_safe__factory.abi = _abi$d;

var Multi_send__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Multi_send__factory$3, "__esModule", { value: true });
Multi_send__factory$3.Multi_send__factory = void 0;
const ethers_1$c = require$$0$d;
const _abi$c = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "transactions",
                type: "bytes",
            },
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function",
    },
];
class Multi_send__factory$2 {
    static createInterface() {
        return new ethers_1$c.utils.Interface(_abi$c);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$c.Contract(address, _abi$c, signerOrProvider);
    }
}
Multi_send__factory$3.Multi_send__factory = Multi_send__factory$2;
Multi_send__factory$2.abi = _abi$c;

var Multi_send_call_only__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Multi_send_call_only__factory$3, "__esModule", { value: true });
Multi_send_call_only__factory$3.Multi_send_call_only__factory = void 0;
const ethers_1$b = require$$0$d;
const _abi$b = [
    {
        inputs: [
            {
                internalType: "bytes",
                name: "transactions",
                type: "bytes",
            },
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function",
    },
];
class Multi_send_call_only__factory$2 {
    static createInterface() {
        return new ethers_1$b.utils.Interface(_abi$b);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$b.Contract(address, _abi$b, signerOrProvider);
    }
}
Multi_send_call_only__factory$3.Multi_send_call_only__factory = Multi_send_call_only__factory$2;
Multi_send_call_only__factory$2.abi = _abi$b;

var Proxy_factory__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Proxy_factory__factory$1, "__esModule", { value: true });
Proxy_factory__factory$1.Proxy_factory__factory = void 0;
const ethers_1$a = require$$0$d;
const _abi$a = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "singleton",
                type: "address",
            },
        ],
        name: "ProxyCreation",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "calculateCreateProxyWithNonceAddress",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "createProxy",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
            {
                internalType: "contract IProxyCreationCallback",
                name: "callback",
                type: "address",
            },
        ],
        name: "createProxyWithCallback",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "createProxyWithNonce",
        outputs: [
            {
                internalType: "contract GnosisSafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
];
class Proxy_factory__factory {
    static createInterface() {
        return new ethers_1$a.utils.Interface(_abi$a);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$a.Contract(address, _abi$a, signerOrProvider);
    }
}
Proxy_factory__factory$1.Proxy_factory__factory = Proxy_factory__factory;
Proxy_factory__factory.abi = _abi$a;

var Sign_message_lib__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Sign_message_lib__factory$3, "__esModule", { value: true });
Sign_message_lib__factory$3.Sign_message_lib__factory = void 0;
const ethers_1$9 = require$$0$d;
const _abi$9 = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "msgHash",
                type: "bytes32",
            },
        ],
        name: "SignMsg",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
        ],
        name: "signMessage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Sign_message_lib__factory$2 {
    static createInterface() {
        return new ethers_1$9.utils.Interface(_abi$9);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$9.Contract(address, _abi$9, signerOrProvider);
    }
}
Sign_message_lib__factory$3.Sign_message_lib__factory = Sign_message_lib__factory$2;
Sign_message_lib__factory$2.abi = _abi$9;

var Simulate_tx_accessor__factory$3 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Simulate_tx_accessor__factory$3, "__esModule", { value: true });
Simulate_tx_accessor__factory$3.Simulate_tx_accessor__factory = void 0;
const ethers_1$8 = require$$0$d;
const _abi$8 = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "simulate",
        outputs: [
            {
                internalType: "uint256",
                name: "estimate",
                type: "uint256",
            },
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Simulate_tx_accessor__factory$2 {
    static createInterface() {
        return new ethers_1$8.utils.Interface(_abi$8);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$8.Contract(address, _abi$8, signerOrProvider);
    }
}
Simulate_tx_accessor__factory$3.Simulate_tx_accessor__factory = Simulate_tx_accessor__factory$2;
Simulate_tx_accessor__factory$2.abi = _abi$8;

var Compatibility_fallback_handler__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Compatibility_fallback_handler__factory$1, "__esModule", { value: true });
Compatibility_fallback_handler__factory$1.Compatibility_fallback_handler__factory = void 0;
const ethers_1$7 = require$$0$d;
const _abi$7 = [
    {
        inputs: [
            {
                internalType: "contract Safe",
                name: "safe",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "encodeMessageDataForSafe",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "contract Safe",
                name: "safe",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHashForSafe",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getModules",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_dataHash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]",
            },
            {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "onERC1155BatchReceived",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "onERC1155Received",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "onERC721Received",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "targetContract",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "calldataPayload",
                type: "bytes",
            },
        ],
        name: "simulate",
        outputs: [
            {
                internalType: "bytes",
                name: "response",
                type: "bytes",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "interfaceId",
                type: "bytes4",
            },
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function",
    },
];
class Compatibility_fallback_handler__factory {
    static createInterface() {
        return new ethers_1$7.utils.Interface(_abi$7);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$7.Contract(address, _abi$7, signerOrProvider);
    }
}
Compatibility_fallback_handler__factory$1.Compatibility_fallback_handler__factory = Compatibility_fallback_handler__factory;
Compatibility_fallback_handler__factory.abi = _abi$7;

var Create_call__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Create_call__factory$1, "__esModule", { value: true });
Create_call__factory$1.Create_call__factory = void 0;
const ethers_1$6 = require$$0$d;
const _abi$6 = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "newContract",
                type: "address",
            },
        ],
        name: "ContractCreation",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "deploymentData",
                type: "bytes",
            },
        ],
        name: "performCreate",
        outputs: [
            {
                internalType: "address",
                name: "newContract",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "deploymentData",
                type: "bytes",
            },
            {
                internalType: "bytes32",
                name: "salt",
                type: "bytes32",
            },
        ],
        name: "performCreate2",
        outputs: [
            {
                internalType: "address",
                name: "newContract",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Create_call__factory {
    static createInterface() {
        return new ethers_1$6.utils.Interface(_abi$6);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$6.Contract(address, _abi$6, signerOrProvider);
    }
}
Create_call__factory$1.Create_call__factory = Create_call__factory;
Create_call__factory.abi = _abi$6;

var Multi_send__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Multi_send__factory$1, "__esModule", { value: true });
Multi_send__factory$1.Multi_send__factory = void 0;
const ethers_1$5 = require$$0$d;
const _abi$5 = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "transactions",
                type: "bytes",
            },
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function",
    },
];
class Multi_send__factory {
    static createInterface() {
        return new ethers_1$5.utils.Interface(_abi$5);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$5.Contract(address, _abi$5, signerOrProvider);
    }
}
Multi_send__factory$1.Multi_send__factory = Multi_send__factory;
Multi_send__factory.abi = _abi$5;

var Multi_send_call_only__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Multi_send_call_only__factory$1, "__esModule", { value: true });
Multi_send_call_only__factory$1.Multi_send_call_only__factory = void 0;
const ethers_1$4 = require$$0$d;
const _abi$4 = [
    {
        inputs: [
            {
                internalType: "bytes",
                name: "transactions",
                type: "bytes",
            },
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function",
    },
];
class Multi_send_call_only__factory {
    static createInterface() {
        return new ethers_1$4.utils.Interface(_abi$4);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$4.Contract(address, _abi$4, signerOrProvider);
    }
}
Multi_send_call_only__factory$1.Multi_send_call_only__factory = Multi_send_call_only__factory;
Multi_send_call_only__factory.abi = _abi$4;

var Safe__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Safe__factory$1, "__esModule", { value: true });
Safe__factory$1.Safe__factory = void 0;
const ethers_1$3 = require$$0$d;
const _abi$3 = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "AddedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "approvedHash",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "ApproveHash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "handler",
                type: "address",
            },
        ],
        name: "ChangedFallbackHandler",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "guard",
                type: "address",
            },
        ],
        name: "ChangedGuard",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "threshold",
                type: "uint256",
            },
        ],
        name: "ChangedThreshold",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "DisabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "EnabledModule",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleFailure",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
        ],
        name: "ExecutionSuccess",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "RemovedOwner",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
        ],
        name: "SafeReceived",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "initiator",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address[]",
                name: "owners",
                type: "address[]",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "threshold",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "address",
                name: "initializer",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "fallbackHandler",
                type: "address",
            },
        ],
        name: "SafeSetup",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "msgHash",
                type: "bytes32",
            },
        ],
        name: "SignMsg",
        type: "event",
    },
    {
        stateMutability: "nonpayable",
        type: "fallback",
    },
    {
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "hashToApprove",
                type: "bytes32",
            },
        ],
        name: "approveHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "approvedHashes",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "changeThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "dataHash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "requiredSignatures",
                type: "uint256",
            },
        ],
        name: "checkNSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "dataHash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "checkSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevModule",
                type: "address",
            },
            {
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "domainSeparator",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "encodeTransactionData",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "signatures",
                type: "bytes",
            },
        ],
        name: "execTransaction",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "getChainId",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "start",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "pageSize",
                type: "uint256",
            },
        ],
        name: "getModulesPaginated",
        outputs: [
            {
                internalType: "address[]",
                name: "array",
                type: "address[]",
            },
            {
                internalType: "address",
                name: "next",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getOwners",
        outputs: [
            {
                internalType: "address[]",
                name: "",
                type: "address[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "offset",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "length",
                type: "uint256",
            },
        ],
        name: "getStorageAt",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "getThreshold",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "safeTxGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "gasToken",
                type: "address",
            },
            {
                internalType: "address",
                name: "refundReceiver",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256",
            },
        ],
        name: "getTransactionHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address",
            },
        ],
        name: "isModuleEnabled",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
        ],
        name: "isOwner",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "nonce",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
        ],
        name: "removeOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "handler",
                type: "address",
            },
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "guard",
                type: "address",
            },
        ],
        name: "setGuard",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_owners",
                type: "address[]",
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256",
            },
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "address",
                name: "fallbackHandler",
                type: "address",
            },
            {
                internalType: "address",
                name: "paymentToken",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "payment",
                type: "uint256",
            },
            {
                internalType: "address payable",
                name: "paymentReceiver",
                type: "address",
            },
        ],
        name: "setup",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "signedMessages",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "targetContract",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "calldataPayload",
                type: "bytes",
            },
        ],
        name: "simulateAndRevert",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "oldOwner",
                type: "address",
            },
            {
                internalType: "address",
                name: "newOwner",
                type: "address",
            },
        ],
        name: "swapOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        stateMutability: "payable",
        type: "receive",
    },
];
class Safe__factory {
    static createInterface() {
        return new ethers_1$3.utils.Interface(_abi$3);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$3.Contract(address, _abi$3, signerOrProvider);
    }
}
Safe__factory$1.Safe__factory = Safe__factory;
Safe__factory.abi = _abi$3;

var Safe_proxy_factory__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Safe_proxy_factory__factory$1, "__esModule", { value: true });
Safe_proxy_factory__factory$1.Safe_proxy_factory__factory = void 0;
const ethers_1$2 = require$$0$d;
const _abi$2 = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "contract SafeProxy",
                name: "proxy",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "singleton",
                type: "address",
            },
        ],
        name: "ProxyCreation",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "createChainSpecificProxyWithNonce",
        outputs: [
            {
                internalType: "contract SafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
            {
                internalType: "contract IProxyCreationCallback",
                name: "callback",
                type: "address",
            },
        ],
        name: "createProxyWithCallback",
        outputs: [
            {
                internalType: "contract SafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_singleton",
                type: "address",
            },
            {
                internalType: "bytes",
                name: "initializer",
                type: "bytes",
            },
            {
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "createProxyWithNonce",
        outputs: [
            {
                internalType: "contract SafeProxy",
                name: "proxy",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "getChainId",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
];
class Safe_proxy_factory__factory {
    static createInterface() {
        return new ethers_1$2.utils.Interface(_abi$2);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$2.Contract(address, _abi$2, signerOrProvider);
    }
}
Safe_proxy_factory__factory$1.Safe_proxy_factory__factory = Safe_proxy_factory__factory;
Safe_proxy_factory__factory.abi = _abi$2;

var Sign_message_lib__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Sign_message_lib__factory$1, "__esModule", { value: true });
Sign_message_lib__factory$1.Sign_message_lib__factory = void 0;
const ethers_1$1 = require$$0$d;
const _abi$1 = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "msgHash",
                type: "bytes32",
            },
        ],
        name: "SignMsg",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "message",
                type: "bytes",
            },
        ],
        name: "getMessageHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes",
            },
        ],
        name: "signMessage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Sign_message_lib__factory {
    static createInterface() {
        return new ethers_1$1.utils.Interface(_abi$1);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1$1.Contract(address, _abi$1, signerOrProvider);
    }
}
Sign_message_lib__factory$1.Sign_message_lib__factory = Sign_message_lib__factory;
Sign_message_lib__factory.abi = _abi$1;

var Simulate_tx_accessor__factory$1 = {};

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
Object.defineProperty(Simulate_tx_accessor__factory$1, "__esModule", { value: true });
Simulate_tx_accessor__factory$1.Simulate_tx_accessor__factory = void 0;
const ethers_1 = require$$0$d;
const _abi = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8",
            },
        ],
        name: "simulate",
        outputs: [
            {
                internalType: "uint256",
                name: "estimate",
                type: "uint256",
            },
            {
                internalType: "bool",
                name: "success",
                type: "bool",
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];
class Simulate_tx_accessor__factory {
    static createInterface() {
        return new ethers_1.utils.Interface(_abi);
    }
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
Simulate_tx_accessor__factory$1.Simulate_tx_accessor__factory = Simulate_tx_accessor__factory;
Simulate_tx_accessor__factory.abi = _abi;

var CompatibilityFallbackHandler_V1_3_0_Ethers$1 = {};

var CompatibilityFallbackHandlerEthersContract$1 = {};

Object.defineProperty(CompatibilityFallbackHandlerEthersContract$1, "__esModule", { value: true });
class CompatibilityFallbackHandlerEthersContract {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    getAddress() {
        return this.contract.address;
    }
}
CompatibilityFallbackHandlerEthersContract$1.default = CompatibilityFallbackHandlerEthersContract;

var __importDefault$M = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CompatibilityFallbackHandler_V1_3_0_Ethers$1, "__esModule", { value: true });
const CompatibilityFallbackHandlerEthersContract_1$1 = __importDefault$M(CompatibilityFallbackHandlerEthersContract$1);
class CompatibilityFallbackHandler_V1_3_0_Ethers extends CompatibilityFallbackHandlerEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CompatibilityFallbackHandler_V1_3_0_Ethers$1.default = CompatibilityFallbackHandler_V1_3_0_Ethers;

var CompatibilityFallbackHandler_V1_4_1_Ethers$1 = {};

var __importDefault$L = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CompatibilityFallbackHandler_V1_4_1_Ethers$1, "__esModule", { value: true });
const CompatibilityFallbackHandlerEthersContract_1 = __importDefault$L(CompatibilityFallbackHandlerEthersContract$1);
class CompatibilityFallbackHandler_V1_4_1_Ethers extends CompatibilityFallbackHandlerEthersContract_1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CompatibilityFallbackHandler_V1_4_1_Ethers$1.default = CompatibilityFallbackHandler_V1_4_1_Ethers;

var CreateCallEthersContract_V1_3_0_Ethers = {};

var CreateCallEthersContract$1 = {};

var utils$1 = {};

Object.defineProperty(utils$1, "__esModule", { value: true });
utils$1.isSignerCompatible = utils$1.isTypedDataSigner = utils$1.toTxResult = utils$1.sameString = void 0;
const abstract_signer_1 = require$$0$6;
function sameString$1(str1, str2) {
    return str1.toLowerCase() === str2.toLowerCase();
}
utils$1.sameString = sameString$1;
function toTxResult$1(transactionResponse, options) {
    return {
        hash: transactionResponse.hash,
        options,
        transactionResponse
    };
}
utils$1.toTxResult = toTxResult$1;
function isTypedDataSigner(signer) {
    return signer._signTypedData !== undefined;
}
utils$1.isTypedDataSigner = isTypedDataSigner;
/**
 * Check if the signerOrProvider is compatible with `Signer`
 * @param signerOrProvider - Signer or provider
 * @returns true if the parameter is compatible with `Signer`
 */
function isSignerCompatible(signerOrProvider) {
    const candidate = signerOrProvider;
    return ((typeof candidate.signMessage === 'function' &&
        typeof candidate.signTransaction === 'function' &&
        candidate._isSigner) ||
        candidate instanceof abstract_signer_1.Signer);
}
utils$1.isSignerCompatible = isSignerCompatible;

Object.defineProperty(CreateCallEthersContract$1, "__esModule", { value: true });
const utils_1$j = utils$1;
class CreateCallEthersContract {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    getAddress() {
        return this.contract.address;
    }
    async performCreate2(value, deploymentData, salt, options) {
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('performCreate2', [value, deploymentData, salt], {
                ...options
            });
        }
        const txResponse = await this.contract.performCreate2(value, deploymentData, salt, options);
        return (0, utils_1$j.toTxResult)(txResponse, options);
    }
    async performCreate(value, deploymentData, options) {
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('performCreate', [value, deploymentData], {
                ...options
            });
        }
        const txResponse = await this.contract.performCreate(value, deploymentData, options);
        return (0, utils_1$j.toTxResult)(txResponse, options);
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toString();
    }
}
CreateCallEthersContract$1.default = CreateCallEthersContract;

var __importDefault$K = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CreateCallEthersContract_V1_3_0_Ethers, "__esModule", { value: true });
const CreateCallEthersContract_1$2 = __importDefault$K(CreateCallEthersContract$1);
class CreateCallContract_V1_3_0_Ethers extends CreateCallEthersContract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CreateCallEthersContract_V1_3_0_Ethers.default = CreateCallContract_V1_3_0_Ethers;

var CreateCallEthersContract_V1_4_1_Ethers = {};

var __importDefault$J = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CreateCallEthersContract_V1_4_1_Ethers, "__esModule", { value: true });
const CreateCallEthersContract_1$1 = __importDefault$J(CreateCallEthersContract$1);
class CreateCallContract_V1_4_1_Ethers extends CreateCallEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CreateCallEthersContract_V1_4_1_Ethers.default = CreateCallContract_V1_4_1_Ethers;

var MultiSendContract_V1_1_1_Ethers$1 = {};

var MultiSendEthersContract$1 = {};

Object.defineProperty(MultiSendEthersContract$1, "__esModule", { value: true });
class MultiSendEthersContract {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    getAddress() {
        return this.contract.address;
    }
}
MultiSendEthersContract$1.default = MultiSendEthersContract;

var __importDefault$I = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendContract_V1_1_1_Ethers$1, "__esModule", { value: true });
const MultiSendEthersContract_1$3 = __importDefault$I(MultiSendEthersContract$1);
class MultiSendContract_V1_1_1_Ethers extends MultiSendEthersContract_1$3.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendContract_V1_1_1_Ethers$1.default = MultiSendContract_V1_1_1_Ethers;

var MultiSendContract_V1_3_0_Ethers$1 = {};

var __importDefault$H = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendContract_V1_3_0_Ethers$1, "__esModule", { value: true });
const MultiSendEthersContract_1$2 = __importDefault$H(MultiSendEthersContract$1);
class MultiSendContract_V1_3_0_Ethers extends MultiSendEthersContract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendContract_V1_3_0_Ethers$1.default = MultiSendContract_V1_3_0_Ethers;

var MultiSendContract_V1_4_1_Ethers$1 = {};

var __importDefault$G = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendContract_V1_4_1_Ethers$1, "__esModule", { value: true });
const MultiSendEthersContract_1$1 = __importDefault$G(MultiSendEthersContract$1);
class MultiSendContract_V1_4_1_Ethers extends MultiSendEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendContract_V1_4_1_Ethers$1.default = MultiSendContract_V1_4_1_Ethers;

var MultiSendCallOnlyContract_V1_3_0_Ethers$1 = {};

var MultiSendCallOnlyEthersContract$1 = {};

Object.defineProperty(MultiSendCallOnlyEthersContract$1, "__esModule", { value: true });
class MultiSendCallOnlyEthersContract {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    getAddress() {
        return this.contract.address;
    }
}
MultiSendCallOnlyEthersContract$1.default = MultiSendCallOnlyEthersContract;

var __importDefault$F = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendCallOnlyContract_V1_3_0_Ethers$1, "__esModule", { value: true });
const MultiSendCallOnlyEthersContract_1$2 = __importDefault$F(MultiSendCallOnlyEthersContract$1);
class MultiSendCallOnlyContract_V1_3_0_Ethers extends MultiSendCallOnlyEthersContract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendCallOnlyContract_V1_3_0_Ethers$1.default = MultiSendCallOnlyContract_V1_3_0_Ethers;

var MultiSendCallOnlyContract_V1_4_1_Ethers$1 = {};

var __importDefault$E = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendCallOnlyContract_V1_4_1_Ethers$1, "__esModule", { value: true });
const MultiSendCallOnlyEthersContract_1$1 = __importDefault$E(MultiSendCallOnlyEthersContract$1);
class MultiSendCallOnlyContract_V1_4_1_Ethers extends MultiSendCallOnlyEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendCallOnlyContract_V1_4_1_Ethers$1.default = MultiSendCallOnlyContract_V1_4_1_Ethers;

var SafeContract_V1_0_0_Ethers$1 = {};

var constants$1 = {};

Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.SENTINEL_ADDRESS = constants$1.EMPTY_DATA = constants$1.ZERO_ADDRESS = void 0;
constants$1.ZERO_ADDRESS = `0x${'0'.repeat(40)}`;
constants$1.EMPTY_DATA = '0x';
constants$1.SENTINEL_ADDRESS = '0x0000000000000000000000000000000000000001';

var SafeContractEthers$1 = {};

Object.defineProperty(SafeContractEthers$1, "__esModule", { value: true });
const utils_1$i = utils$1;
class SafeContractEthers {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    async getVersion() {
        return (await this.contract.VERSION());
    }
    getAddress() {
        return this.contract.address;
    }
    async getNonce() {
        return (await this.contract.nonce()).toNumber();
    }
    async getThreshold() {
        return (await this.contract.getThreshold()).toNumber();
    }
    async getOwners() {
        return this.contract.getOwners();
    }
    async isOwner(address) {
        return this.contract.isOwner(address);
    }
    async getTransactionHash(safeTransactionData) {
        return this.contract.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce);
    }
    async approvedHashes(ownerAddress, hash) {
        return this.contract.approvedHashes(ownerAddress, hash);
    }
    async approveHash(hash, options) {
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('approveHash', [hash], { ...options });
        }
        const txResponse = await this.contract.approveHash(hash, options);
        return (0, utils_1$i.toTxResult)(txResponse, options);
    }
    async isValidTransaction(safeTransaction, options) {
        let isTxValid = false;
        try {
            if (options && !options.gasLimit) {
                options.gasLimit = await this.estimateGas('execTransaction', [
                    safeTransaction.data.to,
                    safeTransaction.data.value,
                    safeTransaction.data.data,
                    safeTransaction.data.operation,
                    safeTransaction.data.safeTxGas,
                    safeTransaction.data.baseGas,
                    safeTransaction.data.gasPrice,
                    safeTransaction.data.gasToken,
                    safeTransaction.data.refundReceiver,
                    safeTransaction.encodedSignatures()
                ], {
                    ...options
                });
            }
            isTxValid = await this.contract.callStatic.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        }
        catch { }
        return isTxValid;
    }
    async execTransaction(safeTransaction, options) {
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('execTransaction', [
                safeTransaction.data.to,
                safeTransaction.data.value,
                safeTransaction.data.data,
                safeTransaction.data.operation,
                safeTransaction.data.safeTxGas,
                safeTransaction.data.baseGas,
                safeTransaction.data.gasPrice,
                safeTransaction.data.gasToken,
                safeTransaction.data.refundReceiver,
                safeTransaction.encodedSignatures()
            ], {
                ...options
            });
        }
        const txResponse = await this.contract.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        return (0, utils_1$i.toTxResult)(txResponse, options);
    }
    async estimateGas(methodName, params, options) {
        const a = (await this.contract.estimateGas[methodName](...params, options)).toString();
        return a;
    }
}
SafeContractEthers$1.default = SafeContractEthers;

var __importDefault$D = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_0_0_Ethers$1, "__esModule", { value: true });
const utils_1$h = utils$1;
const constants_1$a = constants$1;
const SafeContractEthers_1$5 = __importDefault$D(SafeContractEthers$1);
class SafeContract_V1_0_0_Ethers extends SafeContractEthers_1$5.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$a.ZERO_ADDRESS, data = constants_1$a.EMPTY_DATA, paymentToken = constants_1$a.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$a.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('setup', [owners, threshold, to, data, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1$h.toTxResult)(txResponse, options);
    }
    async getModules() {
        return this.contract.getModules();
    }
    async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1$h.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
    }
}
SafeContract_V1_0_0_Ethers$1.default = SafeContract_V1_0_0_Ethers;

var SafeContract_V1_1_1_Ethers$1 = {};

var __importDefault$C = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_1_1_Ethers$1, "__esModule", { value: true });
const utils_1$g = utils$1;
const constants_1$9 = constants$1;
const SafeContractEthers_1$4 = __importDefault$C(SafeContractEthers$1);
class SafeContract_V1_1_1_Ethers extends SafeContractEthers_1$4.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$9.ZERO_ADDRESS, data = constants_1$9.EMPTY_DATA, fallbackHandler = constants_1$9.ZERO_ADDRESS, paymentToken = constants_1$9.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$9.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1$g.toTxResult)(txResponse, options);
    }
    async getModules() {
        return this.contract.getModules();
    }
    async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1$g.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
    }
}
SafeContract_V1_1_1_Ethers$1.default = SafeContract_V1_1_1_Ethers;

var SafeContract_V1_2_0_Ethers$1 = {};

var __importDefault$B = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_2_0_Ethers$1, "__esModule", { value: true });
const utils_1$f = utils$1;
const constants_1$8 = constants$1;
const SafeContractEthers_1$3 = __importDefault$B(SafeContractEthers$1);
class SafeContract_V1_2_0_Ethers extends SafeContractEthers_1$3.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$8.ZERO_ADDRESS, data = constants_1$8.EMPTY_DATA, fallbackHandler = constants_1$8.ZERO_ADDRESS, paymentToken = constants_1$8.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$8.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1$f.toTxResult)(txResponse, options);
    }
    async getModules() {
        return this.contract.getModules();
    }
    async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
    }
}
SafeContract_V1_2_0_Ethers$1.default = SafeContract_V1_2_0_Ethers;

var SafeContract_V1_3_0_Ethers$1 = {};

var __importDefault$A = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_3_0_Ethers$1, "__esModule", { value: true });
const utils_1$e = utils$1;
const constants_1$7 = constants$1;
const SafeContractEthers_1$2 = __importDefault$A(SafeContractEthers$1);
class SafeContract_V1_3_0_Ethers extends SafeContractEthers_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$7.ZERO_ADDRESS, data = constants_1$7.EMPTY_DATA, fallbackHandler = constants_1$7.ZERO_ADDRESS, paymentToken = constants_1$7.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$7.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1$e.toTxResult)(txResponse, options);
    }
    async getModules() {
        const { array } = await this.contract.getModulesPaginated(constants_1$7.SENTINEL_ADDRESS, 10);
        return array;
    }
    async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
    }
}
SafeContract_V1_3_0_Ethers$1.default = SafeContract_V1_3_0_Ethers;

var SafeContract_V1_4_1_Ethers$1 = {};

var __importDefault$z = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_4_1_Ethers$1, "__esModule", { value: true });
const utils_1$d = utils$1;
const constants_1$6 = constants$1;
const SafeContractEthers_1$1 = __importDefault$z(SafeContractEthers$1);
class SafeContract_V1_4_1_Ethers extends SafeContractEthers_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$6.ZERO_ADDRESS, data = constants_1$6.EMPTY_DATA, fallbackHandler = constants_1$6.ZERO_ADDRESS, paymentToken = constants_1$6.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$6.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1$d.toTxResult)(txResponse, options);
    }
    async getModules() {
        const { array } = await this.contract.getModulesPaginated(constants_1$6.SENTINEL_ADDRESS, 10);
        return array;
    }
    async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
    }
}
SafeContract_V1_4_1_Ethers$1.default = SafeContract_V1_4_1_Ethers;

var SafeProxyFactoryContract_V1_0_0_Ethers$1 = {};

var SafeProxyFactoryEthersContract$1 = {};

Object.defineProperty(SafeProxyFactoryEthersContract$1, "__esModule", { value: true });
const bignumber_1$4 = require$$0$7;
class SafeProxyFactoryEthersContract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.address;
    }
    async proxyCreationCode() {
        return this.contract.proxyCreationCode();
    }
    async createProxy({ safeMasterCopyAddress, initializer, saltNonce, options, callback }) {
        if (bignumber_1$4.BigNumber.from(saltNonce).lt(0))
            throw new Error('saltNonce must be greater than or equal to 0');
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('createProxyWithNonce', [safeMasterCopyAddress, initializer, saltNonce], {
                ...options
            });
        }
        const proxyAddress = this.contract
            .createProxyWithNonce(safeMasterCopyAddress, initializer, saltNonce, options)
            .then(async (txResponse) => {
            if (callback) {
                callback(txResponse.hash);
            }
            const txReceipt = await txResponse.wait();
            const proxyCreationEvent = txReceipt?.events?.find(({ event }) => event === 'ProxyCreation');
            if (!proxyCreationEvent || !proxyCreationEvent.args) {
                throw new Error('SafeProxy was not deployed correctly');
            }
            const proxyAddress = proxyCreationEvent.args[0];
            return proxyAddress;
        });
        return proxyAddress;
    }
    encode(methodName, params) {
        return this.contract.interface.encodeFunctionData(methodName, params);
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toString();
    }
}
SafeProxyFactoryEthersContract$1.default = SafeProxyFactoryEthersContract;

var __importDefault$y = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_0_0_Ethers$1, "__esModule", { value: true });
const SafeProxyFactoryEthersContract_1$4 = __importDefault$y(SafeProxyFactoryEthersContract$1);
class SafeProxyFactoryContract_V1_0_0_Ethers extends SafeProxyFactoryEthersContract_1$4.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_0_0_Ethers$1.default = SafeProxyFactoryContract_V1_0_0_Ethers;

var SafeProxyFactoryContract_V1_1_1_Ethers$1 = {};

var __importDefault$x = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_1_1_Ethers$1, "__esModule", { value: true });
const SafeProxyFactoryEthersContract_1$3 = __importDefault$x(SafeProxyFactoryEthersContract$1);
class SafeProxyFactoryContract_V1_1_1_Ethers extends SafeProxyFactoryEthersContract_1$3.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_1_1_Ethers$1.default = SafeProxyFactoryContract_V1_1_1_Ethers;

var SafeProxyFactoryContract_V1_3_0_Ethers$1 = {};

var __importDefault$w = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_3_0_Ethers$1, "__esModule", { value: true });
const SafeProxyFactoryEthersContract_1$2 = __importDefault$w(SafeProxyFactoryEthersContract$1);
class SafeProxyFactoryContract_V1_3_0_Ethers extends SafeProxyFactoryEthersContract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_3_0_Ethers$1.default = SafeProxyFactoryContract_V1_3_0_Ethers;

var SafeProxyFactoryContract_V1_4_1_Ethers$1 = {};

var __importDefault$v = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_4_1_Ethers$1, "__esModule", { value: true });
const SafeProxyFactoryEthersContract_1$1 = __importDefault$v(SafeProxyFactoryEthersContract$1);
class SafeProxyFactoryContract_V1_4_1_Ethers extends SafeProxyFactoryEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_4_1_Ethers$1.default = SafeProxyFactoryContract_V1_4_1_Ethers;

var SignMessageLibContract_V1_3_0_Ethers$1 = {};

var SignMessageLibEthersContract$1 = {};

Object.defineProperty(SignMessageLibEthersContract$1, "__esModule", { value: true });
const utils_1$c = utils$1;
class SignMessageLibEthersContract {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    getAddress() {
        return this.contract.address;
    }
    async signMessage(data, options) {
        if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas('signMessage', [data], { ...options });
        }
        const txResponse = await this.contract.signMessage(data, options);
        return (0, utils_1$c.toTxResult)(txResponse, options);
    }
    async getMessageHash(message) {
        return this.contract.getMessageHash(message);
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toString();
    }
}
SignMessageLibEthersContract$1.default = SignMessageLibEthersContract;

var __importDefault$u = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SignMessageLibContract_V1_3_0_Ethers$1, "__esModule", { value: true });
const SignMessageLibEthersContract_1$2 = __importDefault$u(SignMessageLibEthersContract$1);
class SignMessageLibContract_V1_3_0_Ethers extends SignMessageLibEthersContract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SignMessageLibContract_V1_3_0_Ethers$1.default = SignMessageLibContract_V1_3_0_Ethers;

var SignMessageLibContract_V1_4_1_Ethers$1 = {};

var __importDefault$t = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SignMessageLibContract_V1_4_1_Ethers$1, "__esModule", { value: true });
const SignMessageLibEthersContract_1$1 = __importDefault$t(SignMessageLibEthersContract$1);
class SignMessageLibContract_V1_4_1_Ethers extends SignMessageLibEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SignMessageLibContract_V1_4_1_Ethers$1.default = SignMessageLibContract_V1_4_1_Ethers;

var SimulateTxAccessorContract_V1_3_0_Ethers$1 = {};

var SimulateTxAccessorEthersContract$1 = {};

Object.defineProperty(SimulateTxAccessorEthersContract$1, "__esModule", { value: true });
class SimulateTxAccessorEthersContract {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    getAddress() {
        return this.contract.address;
    }
}
SimulateTxAccessorEthersContract$1.default = SimulateTxAccessorEthersContract;

var __importDefault$s = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SimulateTxAccessorContract_V1_3_0_Ethers$1, "__esModule", { value: true });
const SimulateTxAccessorEthersContract_1$1 = __importDefault$s(SimulateTxAccessorEthersContract$1);
class SimulateTxAccessorContract_V1_3_0_Ethers extends SimulateTxAccessorEthersContract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SimulateTxAccessorContract_V1_3_0_Ethers$1.default = SimulateTxAccessorContract_V1_3_0_Ethers;

var SimulateTxAccessorContract_V1_4_1_Ethers$1 = {};

var __importDefault$r = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SimulateTxAccessorContract_V1_4_1_Ethers$1, "__esModule", { value: true });
const SimulateTxAccessorEthersContract_1 = __importDefault$r(SimulateTxAccessorEthersContract$1);
class SimulateTxAccessorContract_V1_4_1_Ethers extends SimulateTxAccessorEthersContract_1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SimulateTxAccessorContract_V1_4_1_Ethers$1.default = SimulateTxAccessorContract_V1_4_1_Ethers;

var __importDefault$q = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(contractInstancesEthers, "__esModule", { value: true });
contractInstancesEthers.getSimulateTxAccessorContractInstance = contractInstancesEthers.getCreateCallContractInstance = contractInstancesEthers.getSignMessageLibContractInstance = contractInstancesEthers.getSafeProxyFactoryContractInstance = contractInstancesEthers.getMultiSendCallOnlyContractInstance = contractInstancesEthers.getMultiSendContractInstance = contractInstancesEthers.getCompatibilityFallbackHandlerContractInstance = contractInstancesEthers.getSafeContractInstance = void 0;
const Gnosis_safe__factory_1 = Gnosis_safe__factory$7;
const Proxy_factory__factory_1 = Proxy_factory__factory$5;
const Gnosis_safe__factory_2 = Gnosis_safe__factory$5;
const Multi_send__factory_1 = Multi_send__factory$5;
const Proxy_factory__factory_2 = Proxy_factory__factory$3;
const Gnosis_safe__factory_3 = Gnosis_safe__factory$3;
const Compatibility_fallback_handler__factory_1 = Compatibility_fallback_handler__factory$3;
const Create_call__factory_1 = Create_call__factory$3;
const Gnosis_safe__factory_4 = Gnosis_safe__factory$1;
const Multi_send__factory_2 = Multi_send__factory$3;
const Multi_send_call_only__factory_1 = Multi_send_call_only__factory$3;
const Proxy_factory__factory_3 = Proxy_factory__factory$1;
const Sign_message_lib__factory_1 = Sign_message_lib__factory$3;
const Simulate_tx_accessor__factory_1 = Simulate_tx_accessor__factory$3;
const Compatibility_fallback_handler__factory_2 = Compatibility_fallback_handler__factory$1;
const Create_call__factory_2 = Create_call__factory$1;
const Multi_send__factory_3 = Multi_send__factory$1;
const Multi_send_call_only__factory_2 = Multi_send_call_only__factory$1;
const Safe__factory_1 = Safe__factory$1;
const Safe_proxy_factory__factory_1 = Safe_proxy_factory__factory$1;
const Sign_message_lib__factory_2 = Sign_message_lib__factory$1;
const Simulate_tx_accessor__factory_2 = Simulate_tx_accessor__factory$1;
const CompatibilityFallbackHandler_V1_3_0_Ethers_1 = __importDefault$q(CompatibilityFallbackHandler_V1_3_0_Ethers$1);
const CompatibilityFallbackHandler_V1_4_1_Ethers_1 = __importDefault$q(CompatibilityFallbackHandler_V1_4_1_Ethers$1);
const CreateCallEthersContract_V1_3_0_Ethers_1 = __importDefault$q(CreateCallEthersContract_V1_3_0_Ethers);
const CreateCallEthersContract_V1_4_1_Ethers_1 = __importDefault$q(CreateCallEthersContract_V1_4_1_Ethers);
const MultiSendContract_V1_1_1_Ethers_1 = __importDefault$q(MultiSendContract_V1_1_1_Ethers$1);
const MultiSendContract_V1_3_0_Ethers_1 = __importDefault$q(MultiSendContract_V1_3_0_Ethers$1);
const MultiSendContract_V1_4_1_Ethers_1 = __importDefault$q(MultiSendContract_V1_4_1_Ethers$1);
const MultiSendCallOnlyContract_V1_3_0_Ethers_1 = __importDefault$q(MultiSendCallOnlyContract_V1_3_0_Ethers$1);
const MultiSendCallOnlyContract_V1_4_1_Ethers_1 = __importDefault$q(MultiSendCallOnlyContract_V1_4_1_Ethers$1);
const SafeContract_V1_0_0_Ethers_1 = __importDefault$q(SafeContract_V1_0_0_Ethers$1);
const SafeContract_V1_1_1_Ethers_1 = __importDefault$q(SafeContract_V1_1_1_Ethers$1);
const SafeContract_V1_2_0_Ethers_1 = __importDefault$q(SafeContract_V1_2_0_Ethers$1);
const SafeContract_V1_3_0_Ethers_1 = __importDefault$q(SafeContract_V1_3_0_Ethers$1);
const SafeContract_V1_4_1_Ethers_1 = __importDefault$q(SafeContract_V1_4_1_Ethers$1);
const SafeProxyFactoryContract_V1_0_0_Ethers_1 = __importDefault$q(SafeProxyFactoryContract_V1_0_0_Ethers$1);
const SafeProxyFactoryContract_V1_1_1_Ethers_1 = __importDefault$q(SafeProxyFactoryContract_V1_1_1_Ethers$1);
const SafeProxyFactoryContract_V1_3_0_Ethers_1 = __importDefault$q(SafeProxyFactoryContract_V1_3_0_Ethers$1);
const SafeProxyFactoryContract_V1_4_1_Ethers_1 = __importDefault$q(SafeProxyFactoryContract_V1_4_1_Ethers$1);
const SignMessageLibContract_V1_3_0_Ethers_1 = __importDefault$q(SignMessageLibContract_V1_3_0_Ethers$1);
const SignMessageLibContract_V1_4_1_Ethers_1 = __importDefault$q(SignMessageLibContract_V1_4_1_Ethers$1);
const SimulateTxAccessorContract_V1_3_0_Ethers_1 = __importDefault$q(SimulateTxAccessorContract_V1_3_0_Ethers$1);
const SimulateTxAccessorContract_V1_4_1_Ethers_1 = __importDefault$q(SimulateTxAccessorContract_V1_4_1_Ethers$1);
function getSafeContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let safeContract;
    switch (safeVersion) {
        case '1.4.1':
            safeContract = Safe__factory_1.Safe__factory.connect(contractAddress, signerOrProvider);
            return new SafeContract_V1_4_1_Ethers_1.default(safeContract);
        case '1.3.0':
            safeContract = Gnosis_safe__factory_4.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
            return new SafeContract_V1_3_0_Ethers_1.default(safeContract);
        case '1.2.0':
            safeContract = Gnosis_safe__factory_3.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
            return new SafeContract_V1_2_0_Ethers_1.default(safeContract);
        case '1.1.1':
            safeContract = Gnosis_safe__factory_2.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
            return new SafeContract_V1_1_1_Ethers_1.default(safeContract);
        case '1.0.0':
            safeContract = Gnosis_safe__factory_1.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
            return new SafeContract_V1_0_0_Ethers_1.default(safeContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getSafeContractInstance = getSafeContractInstance$1;
function getCompatibilityFallbackHandlerContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let compatibilityFallbackHandlerContract;
    switch (safeVersion) {
        case '1.4.1':
            compatibilityFallbackHandlerContract = Compatibility_fallback_handler__factory_2.Compatibility_fallback_handler__factory.connect(contractAddress, signerOrProvider);
            return new CompatibilityFallbackHandler_V1_4_1_Ethers_1.default(compatibilityFallbackHandlerContract);
        case '1.3.0':
        case '1.2.0':
        case '1.1.1':
            compatibilityFallbackHandlerContract = Compatibility_fallback_handler__factory_1.Compatibility_fallback_handler__factory.connect(contractAddress, signerOrProvider);
            return new CompatibilityFallbackHandler_V1_3_0_Ethers_1.default(compatibilityFallbackHandlerContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getCompatibilityFallbackHandlerContractInstance = getCompatibilityFallbackHandlerContractInstance$1;
function getMultiSendContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let multiSendContract;
    switch (safeVersion) {
        case '1.4.1':
            multiSendContract = Multi_send__factory_3.Multi_send__factory.connect(contractAddress, signerOrProvider);
            return new MultiSendContract_V1_4_1_Ethers_1.default(multiSendContract);
        case '1.3.0':
            multiSendContract = Multi_send__factory_2.Multi_send__factory.connect(contractAddress, signerOrProvider);
            return new MultiSendContract_V1_3_0_Ethers_1.default(multiSendContract);
        case '1.2.0':
        case '1.1.1':
        case '1.0.0':
            multiSendContract = Multi_send__factory_1.Multi_send__factory.connect(contractAddress, signerOrProvider);
            return new MultiSendContract_V1_1_1_Ethers_1.default(multiSendContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getMultiSendContractInstance = getMultiSendContractInstance$1;
function getMultiSendCallOnlyContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let multiSendCallOnlyContract;
    switch (safeVersion) {
        case '1.4.1':
            multiSendCallOnlyContract = Multi_send_call_only__factory_2.Multi_send_call_only__factory.connect(contractAddress, signerOrProvider);
            return new MultiSendCallOnlyContract_V1_4_1_Ethers_1.default(multiSendCallOnlyContract);
        case '1.3.0':
        case '1.2.0':
        case '1.1.1':
        case '1.0.0':
            multiSendCallOnlyContract = Multi_send_call_only__factory_1.Multi_send_call_only__factory.connect(contractAddress, signerOrProvider);
            return new MultiSendCallOnlyContract_V1_3_0_Ethers_1.default(multiSendCallOnlyContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getMultiSendCallOnlyContractInstance = getMultiSendCallOnlyContractInstance$1;
function getSafeProxyFactoryContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let safeProxyFactoryContract;
    switch (safeVersion) {
        case '1.4.1':
            safeProxyFactoryContract = Safe_proxy_factory__factory_1.Safe_proxy_factory__factory.connect(contractAddress, signerOrProvider);
            return new SafeProxyFactoryContract_V1_4_1_Ethers_1.default(safeProxyFactoryContract);
        case '1.3.0':
            safeProxyFactoryContract = Proxy_factory__factory_3.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
            return new SafeProxyFactoryContract_V1_3_0_Ethers_1.default(safeProxyFactoryContract);
        case '1.2.0':
        case '1.1.1':
            safeProxyFactoryContract = Proxy_factory__factory_2.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
            return new SafeProxyFactoryContract_V1_1_1_Ethers_1.default(safeProxyFactoryContract);
        case '1.0.0':
            safeProxyFactoryContract = Proxy_factory__factory_1.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
            return new SafeProxyFactoryContract_V1_0_0_Ethers_1.default(safeProxyFactoryContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getSafeProxyFactoryContractInstance = getSafeProxyFactoryContractInstance$1;
function getSignMessageLibContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let signMessageLibContract;
    switch (safeVersion) {
        case '1.4.1':
            signMessageLibContract = Sign_message_lib__factory_2.Sign_message_lib__factory.connect(contractAddress, signerOrProvider);
            return new SignMessageLibContract_V1_4_1_Ethers_1.default(signMessageLibContract);
        case '1.3.0':
            signMessageLibContract = Sign_message_lib__factory_1.Sign_message_lib__factory.connect(contractAddress, signerOrProvider);
            return new SignMessageLibContract_V1_3_0_Ethers_1.default(signMessageLibContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getSignMessageLibContractInstance = getSignMessageLibContractInstance$1;
function getCreateCallContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let createCallContract;
    switch (safeVersion) {
        case '1.4.1':
            createCallContract = Create_call__factory_2.Create_call__factory.connect(contractAddress, signerOrProvider);
            return new CreateCallEthersContract_V1_4_1_Ethers_1.default(createCallContract);
        case '1.3.0':
        case '1.2.0':
        case '1.1.1':
        case '1.0.0':
            createCallContract = Create_call__factory_1.Create_call__factory.connect(contractAddress, signerOrProvider);
            return new CreateCallEthersContract_V1_3_0_Ethers_1.default(createCallContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getCreateCallContractInstance = getCreateCallContractInstance$1;
function getSimulateTxAccessorContractInstance$1(safeVersion, contractAddress, signerOrProvider) {
    let simulateTxAccessorContract;
    switch (safeVersion) {
        case '1.4.1':
            simulateTxAccessorContract = Simulate_tx_accessor__factory_2.Simulate_tx_accessor__factory.connect(contractAddress, signerOrProvider);
            return new SimulateTxAccessorContract_V1_4_1_Ethers_1.default(simulateTxAccessorContract);
        case '1.3.0':
            simulateTxAccessorContract = Simulate_tx_accessor__factory_1.Simulate_tx_accessor__factory.connect(contractAddress, signerOrProvider);
            return new SimulateTxAccessorContract_V1_3_0_Ethers_1.default(simulateTxAccessorContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesEthers.getSimulateTxAccessorContractInstance = getSimulateTxAccessorContractInstance$1;

var __classPrivateFieldSet$2 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$2 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EthersAdapter_ethers, _EthersAdapter_signer, _EthersAdapter_provider;
Object.defineProperty(EthersAdapter$1, "__esModule", { value: true });
const bignumber_1$3 = require$$0$7;
const utils_1$b = requireUtils();
const contractInstancesEthers_1 = contractInstancesEthers;
const utils_2 = utils$1;
class EthersAdapter {
    constructor({ ethers, signerOrProvider }) {
        _EthersAdapter_ethers.set(this, void 0);
        _EthersAdapter_signer.set(this, void 0);
        _EthersAdapter_provider.set(this, void 0);
        if (!ethers) {
            throw new Error('ethers property missing from options');
        }
        __classPrivateFieldSet$2(this, _EthersAdapter_ethers, ethers, "f");
        const isSigner = (0, utils_2.isSignerCompatible)(signerOrProvider);
        if (isSigner) {
            const signer = signerOrProvider;
            if (!signer.provider) {
                throw new Error('Signer must be connected to a provider');
            }
            __classPrivateFieldSet$2(this, _EthersAdapter_provider, signer.provider, "f");
            __classPrivateFieldSet$2(this, _EthersAdapter_signer, signer, "f");
        }
        else {
            __classPrivateFieldSet$2(this, _EthersAdapter_provider, signerOrProvider, "f");
        }
    }
    getProvider() {
        return __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
    }
    getSigner() {
        return __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f");
    }
    isAddress(address) {
        return __classPrivateFieldGet$2(this, _EthersAdapter_ethers, "f").utils.isAddress(address);
    }
    async getEip3770Address(fullAddress) {
        const chainId = await this.getChainId();
        return (0, utils_1$b.validateEip3770Address)(fullAddress, chainId);
    }
    async getBalance(address, blockTag) {
        return bignumber_1$3.BigNumber.from(await __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getBalance(address, blockTag));
    }
    async getNonce(address, blockTag) {
        return __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getTransactionCount(address, blockTag);
    }
    async getChainId() {
        return (await __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getNetwork()).chainId;
    }
    getChecksummedAddress(address) {
        return __classPrivateFieldGet$2(this, _EthersAdapter_ethers, "f").utils.getAddress(address);
    }
    async getSafeContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SafeProxy contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSafeContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getSafeProxyFactoryContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SafeProxyFactory contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSafeProxyFactoryContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getMultiSendContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid MultiSend contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getMultiSendContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getMultiSendCallOnlyContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid MultiSendCallOnly contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getMultiSendCallOnlyContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getCompatibilityFallbackHandlerContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid CompatibilityFallbackHandler contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getCompatibilityFallbackHandlerContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getSignMessageLibContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SignMessageLib contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSignMessageLibContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getCreateCallContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid CreateCall contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getCreateCallContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getSimulateTxAccessorContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SimulateTxAccessor contract address');
        }
        const signerOrProvider = __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSimulateTxAccessorContractInstance)(safeVersion, contractAddress, signerOrProvider);
    }
    async getContractCode(address, blockTag) {
        return __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getCode(address, blockTag);
    }
    async isContractDeployed(address, blockTag) {
        const contractCode = await __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getCode(address, blockTag);
        return contractCode !== '0x';
    }
    async getStorageAt(address, position) {
        const content = await __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getStorageAt(address, position);
        const decodedContent = this.decodeParameters(['address'], content);
        return decodedContent[0];
    }
    async getTransaction(transactionHash) {
        return __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").getTransaction(transactionHash);
    }
    async getSignerAddress() {
        return __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f")?.getAddress();
    }
    signMessage(message) {
        if (!__classPrivateFieldGet$2(this, _EthersAdapter_signer, "f")) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        const messageArray = __classPrivateFieldGet$2(this, _EthersAdapter_ethers, "f").utils.arrayify(message);
        return __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f").signMessage(messageArray);
    }
    async signTypedData(safeTransactionEIP712Args) {
        if (!__classPrivateFieldGet$2(this, _EthersAdapter_signer, "f")) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        if ((0, utils_2.isTypedDataSigner)(__classPrivateFieldGet$2(this, _EthersAdapter_signer, "f"))) {
            const typedData = (0, utils_1$b.generateTypedData)(safeTransactionEIP712Args);
            const signature = await __classPrivateFieldGet$2(this, _EthersAdapter_signer, "f")._signTypedData(typedData.domain, { SafeTx: typedData.types.SafeTx }, typedData.message);
            return signature;
        }
        throw new Error('The current signer does not implement EIP-712 to sign typed data');
    }
    async estimateGas(transaction) {
        return (await __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").estimateGas(transaction)).toString();
    }
    call(transaction, blockTag) {
        return __classPrivateFieldGet$2(this, _EthersAdapter_provider, "f").call(transaction, blockTag);
    }
    encodeParameters(types, values) {
        return new (__classPrivateFieldGet$2(this, _EthersAdapter_ethers, "f").utils.AbiCoder)().encode(types, values);
    }
    decodeParameters(types, values) {
        return new (__classPrivateFieldGet$2(this, _EthersAdapter_ethers, "f").utils.AbiCoder)().decode(types, values);
    }
}
_EthersAdapter_ethers = new WeakMap(), _EthersAdapter_signer = new WeakMap(), _EthersAdapter_provider = new WeakMap();
EthersAdapter$1.default = EthersAdapter;

var __importDefault$p = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(ethers, "__esModule", { value: true });
ethers.SignMessageLibEthersContract = ethers.SafeProxyFactoryEthersContract = ethers.SafeContractEthers = ethers.MultiSendEthersContract = ethers.MultiSendCallOnlyEthersContract = ethers.EthersAdapter = ethers.CreateCallEthersContract = void 0;
const EthersAdapter_1 = __importDefault$p(EthersAdapter$1);
ethers.EthersAdapter = EthersAdapter_1.default;
const CreateCallEthersContract_1 = __importDefault$p(CreateCallEthersContract$1);
ethers.CreateCallEthersContract = CreateCallEthersContract_1.default;
const MultiSendEthersContract_1 = __importDefault$p(MultiSendEthersContract$1);
ethers.MultiSendEthersContract = MultiSendEthersContract_1.default;
const MultiSendCallOnlyEthersContract_1 = __importDefault$p(MultiSendCallOnlyEthersContract$1);
ethers.MultiSendCallOnlyEthersContract = MultiSendCallOnlyEthersContract_1.default;
const SafeContractEthers_1 = __importDefault$p(SafeContractEthers$1);
ethers.SafeContractEthers = SafeContractEthers_1.default;
const SafeProxyFactoryEthersContract_1 = __importDefault$p(SafeProxyFactoryEthersContract$1);
ethers.SafeProxyFactoryEthersContract = SafeProxyFactoryEthersContract_1.default;
const SignMessageLibEthersContract_1 = __importDefault$p(SignMessageLibEthersContract$1);
ethers.SignMessageLibEthersContract = SignMessageLibEthersContract_1.default;

var web3 = {};

var Web3Adapter$1 = {};

var contractInstancesWeb3 = {};

var CompatibilityFallbackHandler_V1_3_0_Web3$1 = {};

var CompatibilityFallbackHandlerWeb3Contract$1 = {};

Object.defineProperty(CompatibilityFallbackHandlerWeb3Contract$1, "__esModule", { value: true });
class CompatibilityFallbackHandlerWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
}
CompatibilityFallbackHandlerWeb3Contract$1.default = CompatibilityFallbackHandlerWeb3Contract;

var __importDefault$o = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CompatibilityFallbackHandler_V1_3_0_Web3$1, "__esModule", { value: true });
const CompatibilityFallbackHandlerWeb3Contract_1$1 = __importDefault$o(CompatibilityFallbackHandlerWeb3Contract$1);
class CompatibilityFallbackHandler_V1_3_0_Web3 extends CompatibilityFallbackHandlerWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CompatibilityFallbackHandler_V1_3_0_Web3$1.default = CompatibilityFallbackHandler_V1_3_0_Web3;

var CompatibilityFallbackHandler_V1_4_1_Web3$1 = {};

var __importDefault$n = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CompatibilityFallbackHandler_V1_4_1_Web3$1, "__esModule", { value: true });
const CompatibilityFallbackHandlerWeb3Contract_1 = __importDefault$n(CompatibilityFallbackHandlerWeb3Contract$1);
class CompatibilityFallbackHandler_V1_4_1_Web3 extends CompatibilityFallbackHandlerWeb3Contract_1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CompatibilityFallbackHandler_V1_4_1_Web3$1.default = CompatibilityFallbackHandler_V1_4_1_Web3;

var CreateCallEthersContract_V1_3_0_Web3 = {};

var CreateCallWeb3Contract$1 = {};

var utils = {};

Object.defineProperty(utils, "__esModule", { value: true });
utils.toTxResult = utils.sameString = void 0;
function sameString(str1, str2) {
    return str1.toLowerCase() === str2.toLowerCase();
}
utils.sameString = sameString;
async function toTxResult(promiEvent, options) {
    return new Promise((resolve, reject) => promiEvent
        .once('transactionHash', (hash) => resolve({ hash, promiEvent, options }))
        .catch(reject));
}
utils.toTxResult = toTxResult;

Object.defineProperty(CreateCallWeb3Contract$1, "__esModule", { value: true });
const utils_1$a = utils;
class CreateCallWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    async performCreate2(value, deploymentData, salt, options) {
        if (options && !options.gas) {
            options.gas = await this.estimateGas('performCreate2', [value, deploymentData, salt], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .performCreate2(value, deploymentData, salt)
            .send(options);
        return (0, utils_1$a.toTxResult)(txResponse, options);
    }
    async performCreate(value, deploymentData, options) {
        if (options && !options.gas) {
            options.gas = await this.estimateGas('performCreate', [value, deploymentData], { ...options });
        }
        const txResponse = this.contract.methods.performCreate(value, deploymentData).send(options);
        return (0, utils_1$a.toTxResult)(txResponse, options);
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
    }
}
CreateCallWeb3Contract$1.default = CreateCallWeb3Contract;

var __importDefault$m = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CreateCallEthersContract_V1_3_0_Web3, "__esModule", { value: true });
const CreateCallWeb3Contract_1$2 = __importDefault$m(CreateCallWeb3Contract$1);
class CreateCallContract_V1_3_0_Web3 extends CreateCallWeb3Contract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CreateCallEthersContract_V1_3_0_Web3.default = CreateCallContract_V1_3_0_Web3;

var CreateCallEthersContract_V1_4_1_Web3 = {};

var __importDefault$l = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(CreateCallEthersContract_V1_4_1_Web3, "__esModule", { value: true });
const CreateCallWeb3Contract_1$1 = __importDefault$l(CreateCallWeb3Contract$1);
class CreateCallContract_V1_4_1_Web3 extends CreateCallWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
CreateCallEthersContract_V1_4_1_Web3.default = CreateCallContract_V1_4_1_Web3;

var MultiSendContract_V1_1_1_Web3$1 = {};

var MultiSendWeb3Contract$1 = {};

Object.defineProperty(MultiSendWeb3Contract$1, "__esModule", { value: true });
class MultiSendWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
}
MultiSendWeb3Contract$1.default = MultiSendWeb3Contract;

var __importDefault$k = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendContract_V1_1_1_Web3$1, "__esModule", { value: true });
const MultiSendWeb3Contract_1$3 = __importDefault$k(MultiSendWeb3Contract$1);
class MultiSendContract_V1_1_1_Web3 extends MultiSendWeb3Contract_1$3.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendContract_V1_1_1_Web3$1.default = MultiSendContract_V1_1_1_Web3;

var MultiSendContract_V1_3_0_Web3$1 = {};

var __importDefault$j = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendContract_V1_3_0_Web3$1, "__esModule", { value: true });
const MultiSendWeb3Contract_1$2 = __importDefault$j(MultiSendWeb3Contract$1);
class MultiSendContract_V1_3_0_Web3 extends MultiSendWeb3Contract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendContract_V1_3_0_Web3$1.default = MultiSendContract_V1_3_0_Web3;

var MultiSendContract_V1_4_1_Web3$1 = {};

var __importDefault$i = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendContract_V1_4_1_Web3$1, "__esModule", { value: true });
const MultiSendWeb3Contract_1$1 = __importDefault$i(MultiSendWeb3Contract$1);
class MultiSendContract_V1_4_1_Web3 extends MultiSendWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendContract_V1_4_1_Web3$1.default = MultiSendContract_V1_4_1_Web3;

var MultiSendCallOnlyContract_V1_3_0_Web3$1 = {};

var MultiSendCallOnlyWeb3Contract$1 = {};

Object.defineProperty(MultiSendCallOnlyWeb3Contract$1, "__esModule", { value: true });
class MultiSendCallOnlyWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
}
MultiSendCallOnlyWeb3Contract$1.default = MultiSendCallOnlyWeb3Contract;

var __importDefault$h = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendCallOnlyContract_V1_3_0_Web3$1, "__esModule", { value: true });
const MultiSendCallOnlyWeb3Contract_1$2 = __importDefault$h(MultiSendCallOnlyWeb3Contract$1);
class MultiSendCallOnlyContract_V1_3_0_Web3 extends MultiSendCallOnlyWeb3Contract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendCallOnlyContract_V1_3_0_Web3$1.default = MultiSendCallOnlyContract_V1_3_0_Web3;

var MultiSendCallOnlyContract_V1_4_1_Web3$1 = {};

var __importDefault$g = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(MultiSendCallOnlyContract_V1_4_1_Web3$1, "__esModule", { value: true });
const MultiSendCallOnlyWeb3Contract_1$1 = __importDefault$g(MultiSendCallOnlyWeb3Contract$1);
class MultiSendCallOnlyContract_V1_4_1_Web3 extends MultiSendCallOnlyWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
MultiSendCallOnlyContract_V1_4_1_Web3$1.default = MultiSendCallOnlyContract_V1_4_1_Web3;

var SafeContract_V1_0_0_Web3$1 = {};

var constants = {};

Object.defineProperty(constants, "__esModule", { value: true });
constants.SENTINEL_ADDRESS = constants.EMPTY_DATA = constants.ZERO_ADDRESS = void 0;
constants.ZERO_ADDRESS = `0x${'0'.repeat(40)}`;
constants.EMPTY_DATA = '0x';
constants.SENTINEL_ADDRESS = '0x0000000000000000000000000000000000000001';

var SafeContractWeb3$1 = {};

Object.defineProperty(SafeContractWeb3$1, "__esModule", { value: true });
const bignumber_1$2 = require$$0$7;
const utils_1$9 = utils;
class SafeContractWeb3 {
    constructor(contract) {
        this.contract = contract;
    }
    async getVersion() {
        return (await this.contract.methods.VERSION().call());
    }
    getAddress() {
        return this.contract.options.address;
    }
    async getNonce() {
        return Number(await this.contract.methods.nonce().call());
    }
    async getThreshold() {
        return Number(await this.contract.methods.getThreshold().call());
    }
    async getOwners() {
        return this.contract.methods.getOwners().call();
    }
    async isOwner(address) {
        return this.contract.methods.isOwner(address).call();
    }
    async getTransactionHash(safeTransactionData) {
        return this.contract.methods
            .getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce)
            .call();
    }
    async approvedHashes(ownerAddress, hash) {
        return bignumber_1$2.BigNumber.from(await this.contract.methods.approvedHashes(ownerAddress, hash).call());
    }
    async approveHash(hash, options) {
        if (options && !options.gas) {
            options.gas = await this.estimateGas('approveHash', [hash], { ...options });
        }
        const txResponse = this.contract.methods.approveHash(hash).send(options);
        return (0, utils_1$9.toTxResult)(txResponse, options);
    }
    async isValidTransaction(safeTransaction, options) {
        let isTxValid = false;
        try {
            if (options && !options.gas) {
                options.gas = await this.estimateGas('execTransaction', [
                    safeTransaction.data.to,
                    safeTransaction.data.value,
                    safeTransaction.data.data,
                    safeTransaction.data.operation,
                    safeTransaction.data.safeTxGas,
                    safeTransaction.data.baseGas,
                    safeTransaction.data.gasPrice,
                    safeTransaction.data.gasToken,
                    safeTransaction.data.refundReceiver,
                    safeTransaction.encodedSignatures()
                ], {
                    ...options
                });
            }
            isTxValid = await this.contract.methods
                .execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures())
                .call(options);
        }
        catch { }
        return isTxValid;
    }
    async execTransaction(safeTransaction, options) {
        if (options && !options.gas) {
            options.gas = await this.estimateGas('execTransaction', [
                safeTransaction.data.to,
                safeTransaction.data.value,
                safeTransaction.data.data,
                safeTransaction.data.operation,
                safeTransaction.data.safeTxGas,
                safeTransaction.data.baseGas,
                safeTransaction.data.gasPrice,
                safeTransaction.data.gasToken,
                safeTransaction.data.refundReceiver,
                safeTransaction.encodedSignatures()
            ], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures())
            .send(options);
        return (0, utils_1$9.toTxResult)(txResponse, options);
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
    }
}
SafeContractWeb3$1.default = SafeContractWeb3;

var __importDefault$f = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_0_0_Web3$1, "__esModule", { value: true });
const utils_1$8 = utils;
const constants_1$5 = constants;
const SafeContractWeb3_1$5 = __importDefault$f(SafeContractWeb3$1);
class SafeContract_V1_0_0_Web3 extends SafeContractWeb3_1$5.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$5.ZERO_ADDRESS, data = constants_1$5.EMPTY_DATA, paymentToken = constants_1$5.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$5.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
            options.gas = await this.estimateGas('setup', [owners, threshold, to, data, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .setup(owners, threshold, to, data, paymentToken, payment, paymentReceiver)
            .send(options);
        return (0, utils_1$8.toTxResult)(txResponse, options);
    }
    async getModules() {
        return this.contract.methods.getModules().call();
    }
    async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1$8.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
    }
}
SafeContract_V1_0_0_Web3$1.default = SafeContract_V1_0_0_Web3;

var SafeContract_V1_1_1_Web3$1 = {};

var __importDefault$e = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_1_1_Web3$1, "__esModule", { value: true });
const utils_1$7 = utils;
const constants_1$4 = constants;
const SafeContractWeb3_1$4 = __importDefault$e(SafeContractWeb3$1);
class SafeContract_V1_1_1_Web3 extends SafeContractWeb3_1$4.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$4.ZERO_ADDRESS, data = constants_1$4.EMPTY_DATA, fallbackHandler = constants_1$4.ZERO_ADDRESS, paymentToken = constants_1$4.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$4.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
            options.gas = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
            .send(options);
        return (0, utils_1$7.toTxResult)(txResponse, options);
    }
    async getModules() {
        return this.contract.methods.getModules().call();
    }
    async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1$7.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
    }
}
SafeContract_V1_1_1_Web3$1.default = SafeContract_V1_1_1_Web3;

var SafeContract_V1_2_0_Web3$1 = {};

var __importDefault$d = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_2_0_Web3$1, "__esModule", { value: true });
const utils_1$6 = utils;
const constants_1$3 = constants;
const SafeContractWeb3_1$3 = __importDefault$d(SafeContractWeb3$1);
class SafeContract_V1_2_0_Web3 extends SafeContractWeb3_1$3.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$3.ZERO_ADDRESS, data = constants_1$3.EMPTY_DATA, fallbackHandler = constants_1$3.ZERO_ADDRESS, paymentToken = constants_1$3.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$3.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
            options.gas = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
            .send(options);
        return (0, utils_1$6.toTxResult)(txResponse, options);
    }
    async getModules() {
        return this.contract.methods.getModules().call();
    }
    async isModuleEnabled(moduleAddress) {
        return this.contract.methods.isModuleEnabled(moduleAddress).call();
    }
}
SafeContract_V1_2_0_Web3$1.default = SafeContract_V1_2_0_Web3;

var SafeContract_V1_3_0_Web3$1 = {};

var __importDefault$c = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_3_0_Web3$1, "__esModule", { value: true });
const utils_1$5 = utils;
const constants_1$2 = constants;
const SafeContractWeb3_1$2 = __importDefault$c(SafeContractWeb3$1);
class SafeContract_V1_3_0_Web3 extends SafeContractWeb3_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$2.ZERO_ADDRESS, data = constants_1$2.EMPTY_DATA, fallbackHandler = constants_1$2.ZERO_ADDRESS, paymentToken = constants_1$2.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$2.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
            options.gas = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
            .send(options);
        return (0, utils_1$5.toTxResult)(txResponse, options);
    }
    async getModules() {
        const { array } = await this.contract.methods.getModulesPaginated(constants_1$2.SENTINEL_ADDRESS, 10).call();
        return array;
    }
    async isModuleEnabled(moduleAddress) {
        return this.contract.methods.isModuleEnabled(moduleAddress).call();
    }
}
SafeContract_V1_3_0_Web3$1.default = SafeContract_V1_3_0_Web3;

var SafeContract_V1_4_1_Web3$1 = {};

var __importDefault$b = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeContract_V1_4_1_Web3$1, "__esModule", { value: true });
const utils_1$4 = utils;
const constants_1$1 = constants;
const SafeContractWeb3_1$1 = __importDefault$b(SafeContractWeb3$1);
class SafeContract_V1_4_1_Web3 extends SafeContractWeb3_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1$1.ZERO_ADDRESS, data = constants_1$1.EMPTY_DATA, fallbackHandler = constants_1$1.ZERO_ADDRESS, paymentToken = constants_1$1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1$1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
            options.gas = await this.estimateGas('setup', [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
            .send(options);
        return (0, utils_1$4.toTxResult)(txResponse, options);
    }
    async getModules() {
        const { array } = await this.contract.methods.getModulesPaginated(constants_1$1.SENTINEL_ADDRESS, 10).call();
        return array;
    }
    async isModuleEnabled(moduleAddress) {
        return this.contract.methods.isModuleEnabled(moduleAddress).call();
    }
}
SafeContract_V1_4_1_Web3$1.default = SafeContract_V1_4_1_Web3;

var SafeProxyFactoryContract_V1_0_0_Web3$1 = {};

var SafeProxyFactoryWeb3Contract$1 = {};

Object.defineProperty(SafeProxyFactoryWeb3Contract$1, "__esModule", { value: true });
const bignumber_1$1 = require$$0$7;
const utils_1$3 = utils;
class SafeProxyFactoryWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    async proxyCreationCode() {
        return this.contract.methods.proxyCreationCode().call();
    }
    async createProxy({ safeMasterCopyAddress, initializer, saltNonce, options, callback }) {
        if (bignumber_1$1.BigNumber.from(saltNonce).lt(0))
            throw new Error('saltNonce must be greater than or equal to 0');
        if (options && !options.gas) {
            options.gas = await this.estimateGas('createProxyWithNonce', [safeMasterCopyAddress, initializer, saltNonce], {
                ...options
            });
        }
        const txResponse = this.contract.methods
            .createProxyWithNonce(safeMasterCopyAddress, initializer, saltNonce)
            .send(options);
        if (callback) {
            const txResult = await (0, utils_1$3.toTxResult)(txResponse);
            callback(txResult.hash);
        }
        const txResult = await new Promise((resolve, reject) => txResponse.once('receipt', (receipt) => resolve(receipt)).catch(reject));
        const proxyAddress = txResult.events?.ProxyCreation?.returnValues?.proxy;
        if (!proxyAddress) {
            throw new Error('SafeProxy was not deployed correctly');
        }
        return proxyAddress;
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
    }
}
SafeProxyFactoryWeb3Contract$1.default = SafeProxyFactoryWeb3Contract;

var __importDefault$a = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_0_0_Web3$1, "__esModule", { value: true });
const SafeProxyFactoryWeb3Contract_1$4 = __importDefault$a(SafeProxyFactoryWeb3Contract$1);
class SafeProxyFactoryContract_V1_0_0_Web3 extends SafeProxyFactoryWeb3Contract_1$4.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_0_0_Web3$1.default = SafeProxyFactoryContract_V1_0_0_Web3;

var SafeProxyFactoryContract_V1_1_1_Web3$1 = {};

var __importDefault$9 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_1_1_Web3$1, "__esModule", { value: true });
const SafeProxyFactoryWeb3Contract_1$3 = __importDefault$9(SafeProxyFactoryWeb3Contract$1);
class SafeProxyFactoryContract_V1_1_1_Web3 extends SafeProxyFactoryWeb3Contract_1$3.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_1_1_Web3$1.default = SafeProxyFactoryContract_V1_1_1_Web3;

var SafeProxyFactoryContract_V1_3_0_Web3$1 = {};

var __importDefault$8 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_3_0_Web3$1, "__esModule", { value: true });
const SafeProxyFactoryWeb3Contract_1$2 = __importDefault$8(SafeProxyFactoryWeb3Contract$1);
class SafeProxyFactoryContract_V1_3_0_Web3 extends SafeProxyFactoryWeb3Contract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_3_0_Web3$1.default = SafeProxyFactoryContract_V1_3_0_Web3;

var SafeProxyFactoryContract_V1_4_1_Web3$1 = {};

var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SafeProxyFactoryContract_V1_4_1_Web3$1, "__esModule", { value: true });
const SafeProxyFactoryWeb3Contract_1$1 = __importDefault$7(SafeProxyFactoryWeb3Contract$1);
class SafeProxyFactoryContract_V1_4_1_Web3 extends SafeProxyFactoryWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SafeProxyFactoryContract_V1_4_1_Web3$1.default = SafeProxyFactoryContract_V1_4_1_Web3;

var SignMessageLibContract_V1_3_0_Web3$1 = {};

var SignMessageLibWeb3Contract$1 = {};

Object.defineProperty(SignMessageLibWeb3Contract$1, "__esModule", { value: true });
const utils_1$2 = utils;
class SignMessageLibWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    async signMessage(data, options) {
        if (options && !options.gas) {
            options.gas = await this.estimateGas('signMessage', [data], { ...options });
        }
        const txResponse = this.contract.methods.signMessage(data).send(options);
        return (0, utils_1$2.toTxResult)(txResponse, options);
    }
    async getMessageHash(message) {
        return this.contract.methods.getMessageHash(message).call();
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
    }
}
SignMessageLibWeb3Contract$1.default = SignMessageLibWeb3Contract;

var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SignMessageLibContract_V1_3_0_Web3$1, "__esModule", { value: true });
const SignMessageLibWeb3Contract_1$2 = __importDefault$6(SignMessageLibWeb3Contract$1);
class SignMessageLibContract_V1_3_0_Web3 extends SignMessageLibWeb3Contract_1$2.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SignMessageLibContract_V1_3_0_Web3$1.default = SignMessageLibContract_V1_3_0_Web3;

var SignMessageLibContract_V1_4_1_Web3$1 = {};

var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SignMessageLibContract_V1_4_1_Web3$1, "__esModule", { value: true });
const SignMessageLibWeb3Contract_1$1 = __importDefault$5(SignMessageLibWeb3Contract$1);
class SignMessageLibContract_V1_4_1_Web3 extends SignMessageLibWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SignMessageLibContract_V1_4_1_Web3$1.default = SignMessageLibContract_V1_4_1_Web3;

var SimulateTxAccessorContract_V1_3_0_Web3 = {};

var SimulateTxAccessorWeb3Contract$1 = {};

Object.defineProperty(SimulateTxAccessorWeb3Contract$1, "__esModule", { value: true });
class SimulateTxAccessorWeb3Contract {
    constructor(contract) {
        this.contract = contract;
    }
    getAddress() {
        return this.contract.options.address;
    }
    encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
    }
}
SimulateTxAccessorWeb3Contract$1.default = SimulateTxAccessorWeb3Contract;

var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SimulateTxAccessorContract_V1_3_0_Web3, "__esModule", { value: true });
const SimulateTxAccessorWeb3Contract_1$1 = __importDefault$4(SimulateTxAccessorWeb3Contract$1);
class SimulateTxAccessor_V1_3_0_Web3 extends SimulateTxAccessorWeb3Contract_1$1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SimulateTxAccessorContract_V1_3_0_Web3.default = SimulateTxAccessor_V1_3_0_Web3;

var SimulateTxAccessorContract_V1_4_1_Web3 = {};

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(SimulateTxAccessorContract_V1_4_1_Web3, "__esModule", { value: true });
const SimulateTxAccessorWeb3Contract_1 = __importDefault$3(SimulateTxAccessorWeb3Contract$1);
class SimulateTxAccessor_V1_4_1_Web3 extends SimulateTxAccessorWeb3Contract_1.default {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
}
SimulateTxAccessorContract_V1_4_1_Web3.default = SimulateTxAccessor_V1_4_1_Web3;

var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(contractInstancesWeb3, "__esModule", { value: true });
contractInstancesWeb3.getSimulateTxAccessorContractInstance = contractInstancesWeb3.getCreateCallContractInstance = contractInstancesWeb3.getSignMessageLibContractInstance = contractInstancesWeb3.getSafeProxyFactoryContractInstance = contractInstancesWeb3.getMultiSendCallOnlyContractInstance = contractInstancesWeb3.getMultiSendContractInstance = contractInstancesWeb3.getCompatibilityFallbackHandlerContractInstance = contractInstancesWeb3.getSafeContractInstance = void 0;
const CompatibilityFallbackHandler_V1_3_0_Web3_1 = __importDefault$2(CompatibilityFallbackHandler_V1_3_0_Web3$1);
const CompatibilityFallbackHandler_V1_4_1_Web3_1 = __importDefault$2(CompatibilityFallbackHandler_V1_4_1_Web3$1);
const CreateCallEthersContract_V1_3_0_Web3_1 = __importDefault$2(CreateCallEthersContract_V1_3_0_Web3);
const CreateCallEthersContract_V1_4_1_Web3_1 = __importDefault$2(CreateCallEthersContract_V1_4_1_Web3);
const MultiSendContract_V1_1_1_Web3_1 = __importDefault$2(MultiSendContract_V1_1_1_Web3$1);
const MultiSendContract_V1_3_0_Web3_1 = __importDefault$2(MultiSendContract_V1_3_0_Web3$1);
const MultiSendContract_V1_4_1_Web3_1 = __importDefault$2(MultiSendContract_V1_4_1_Web3$1);
const MultiSendCallOnlyContract_V1_3_0_Web3_1 = __importDefault$2(MultiSendCallOnlyContract_V1_3_0_Web3$1);
const MultiSendCallOnlyContract_V1_4_1_Web3_1 = __importDefault$2(MultiSendCallOnlyContract_V1_4_1_Web3$1);
const SafeContract_V1_0_0_Web3_1 = __importDefault$2(SafeContract_V1_0_0_Web3$1);
const SafeContract_V1_1_1_Web3_1 = __importDefault$2(SafeContract_V1_1_1_Web3$1);
const SafeContract_V1_2_0_Web3_1 = __importDefault$2(SafeContract_V1_2_0_Web3$1);
const SafeContract_V1_3_0_Web3_1 = __importDefault$2(SafeContract_V1_3_0_Web3$1);
const SafeContract_V1_4_1_Web3_1 = __importDefault$2(SafeContract_V1_4_1_Web3$1);
const SafeProxyFactoryContract_V1_0_0_Web3_1 = __importDefault$2(SafeProxyFactoryContract_V1_0_0_Web3$1);
const SafeProxyFactoryContract_V1_1_1_Web3_1 = __importDefault$2(SafeProxyFactoryContract_V1_1_1_Web3$1);
const SafeProxyFactoryContract_V1_3_0_Web3_1 = __importDefault$2(SafeProxyFactoryContract_V1_3_0_Web3$1);
const SafeProxyFactoryContract_V1_4_1_Web3_1 = __importDefault$2(SafeProxyFactoryContract_V1_4_1_Web3$1);
const SignMessageLibContract_V1_3_0_Web3_1 = __importDefault$2(SignMessageLibContract_V1_3_0_Web3$1);
const SignMessageLibContract_V1_4_1_Web3_1 = __importDefault$2(SignMessageLibContract_V1_4_1_Web3$1);
const SimulateTxAccessorContract_V1_3_0_Web3_1 = __importDefault$2(SimulateTxAccessorContract_V1_3_0_Web3);
const SimulateTxAccessorContract_V1_4_1_Web3_1 = __importDefault$2(SimulateTxAccessorContract_V1_4_1_Web3);
function getSafeContractInstance(safeVersion, safeContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new SafeContract_V1_4_1_Web3_1.default(safeContract);
        case '1.3.0':
            return new SafeContract_V1_3_0_Web3_1.default(safeContract);
        case '1.2.0':
            return new SafeContract_V1_2_0_Web3_1.default(safeContract);
        case '1.1.1':
            return new SafeContract_V1_1_1_Web3_1.default(safeContract);
        case '1.0.0':
            return new SafeContract_V1_0_0_Web3_1.default(safeContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getSafeContractInstance = getSafeContractInstance;
function getCompatibilityFallbackHandlerContractInstance(safeVersion, compatibilityFallbackhandlerContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new CompatibilityFallbackHandler_V1_4_1_Web3_1.default(compatibilityFallbackhandlerContract);
        case '1.3.0':
        case '1.2.0':
        case '1.1.1':
            return new CompatibilityFallbackHandler_V1_3_0_Web3_1.default(compatibilityFallbackhandlerContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getCompatibilityFallbackHandlerContractInstance = getCompatibilityFallbackHandlerContractInstance;
function getMultiSendContractInstance(safeVersion, multiSendContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new MultiSendContract_V1_4_1_Web3_1.default(multiSendContract);
        case '1.3.0':
            return new MultiSendContract_V1_3_0_Web3_1.default(multiSendContract);
        case '1.2.0':
        case '1.1.1':
        case '1.0.0':
            return new MultiSendContract_V1_1_1_Web3_1.default(multiSendContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getMultiSendContractInstance = getMultiSendContractInstance;
function getMultiSendCallOnlyContractInstance(safeVersion, multiSendCallOnlyContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new MultiSendCallOnlyContract_V1_4_1_Web3_1.default(multiSendCallOnlyContract);
        case '1.3.0':
        case '1.2.0':
        case '1.1.1':
        case '1.0.0':
            return new MultiSendCallOnlyContract_V1_3_0_Web3_1.default(multiSendCallOnlyContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getMultiSendCallOnlyContractInstance = getMultiSendCallOnlyContractInstance;
function getSafeProxyFactoryContractInstance(safeVersion, safeProxyFactoryContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new SafeProxyFactoryContract_V1_4_1_Web3_1.default(safeProxyFactoryContract);
        case '1.3.0':
            return new SafeProxyFactoryContract_V1_3_0_Web3_1.default(safeProxyFactoryContract);
        case '1.2.0':
        case '1.1.1':
            return new SafeProxyFactoryContract_V1_1_1_Web3_1.default(safeProxyFactoryContract);
        case '1.0.0':
            return new SafeProxyFactoryContract_V1_0_0_Web3_1.default(safeProxyFactoryContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getSafeProxyFactoryContractInstance = getSafeProxyFactoryContractInstance;
function getSignMessageLibContractInstance(safeVersion, signMessageLibContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new SignMessageLibContract_V1_4_1_Web3_1.default(signMessageLibContract);
        case '1.3.0':
            return new SignMessageLibContract_V1_3_0_Web3_1.default(signMessageLibContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getSignMessageLibContractInstance = getSignMessageLibContractInstance;
function getCreateCallContractInstance(safeVersion, createCallContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new CreateCallEthersContract_V1_4_1_Web3_1.default(createCallContract);
        case '1.3.0':
        case '1.2.0':
        case '1.1.1':
        case '1.0.0':
            return new CreateCallEthersContract_V1_3_0_Web3_1.default(createCallContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getCreateCallContractInstance = getCreateCallContractInstance;
function getSimulateTxAccessorContractInstance(safeVersion, simulateTxAccessorContract) {
    switch (safeVersion) {
        case '1.4.1':
            return new SimulateTxAccessorContract_V1_4_1_Web3_1.default(simulateTxAccessorContract);
        case '1.3.0':
            return new SimulateTxAccessorContract_V1_3_0_Web3_1.default(simulateTxAccessorContract);
        default:
            throw new Error('Invalid Safe version');
    }
}
contractInstancesWeb3.getSimulateTxAccessorContractInstance = getSimulateTxAccessorContractInstance;

var __classPrivateFieldSet$1 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$1 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Web3Adapter_web3, _Web3Adapter_signerAddress;
Object.defineProperty(Web3Adapter$1, "__esModule", { value: true });
const bignumber_1 = require$$0$7;
const utils_1$1 = requireUtils();
const contractInstancesWeb3_1 = contractInstancesWeb3;
class Web3Adapter {
    constructor({ web3, signerAddress }) {
        _Web3Adapter_web3.set(this, void 0);
        _Web3Adapter_signerAddress.set(this, void 0);
        if (!web3) {
            throw new Error('web3 property missing from options');
        }
        __classPrivateFieldSet$1(this, _Web3Adapter_web3, web3, "f");
        __classPrivateFieldSet$1(this, _Web3Adapter_signerAddress, signerAddress, "f");
    }
    isAddress(address) {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").utils.isAddress(address);
    }
    async getEip3770Address(fullAddress) {
        const chainId = await this.getChainId();
        return (0, utils_1$1.validateEip3770Address)(fullAddress, chainId);
    }
    async getBalance(address, defaultBlock) {
        const balance = defaultBlock
            ? await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getBalance(address, defaultBlock)
            : await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getBalance(address);
        // FIXME Web3 Adapter is forced to return an Ethers type
        return bignumber_1.BigNumber.from(balance);
    }
    async getNonce(address, defaultBlock) {
        const nonce = defaultBlock
            ? await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getTransactionCount(address, defaultBlock)
            : await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getTransactionCount(address);
        return nonce;
    }
    async getChainId() {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getChainId();
    }
    getChecksummedAddress(address) {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").utils.toChecksumAddress(address);
    }
    async getSafeContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SafeProxy contract address');
        }
        const safeContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getSafeContractInstance)(safeVersion, safeContract);
    }
    async getSafeProxyFactoryContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SafeProxyFactory contract address');
        }
        const proxyFactoryContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getSafeProxyFactoryContractInstance)(safeVersion, proxyFactoryContract);
    }
    async getMultiSendContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid MultiSend contract address');
        }
        const multiSendContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getMultiSendContractInstance)(safeVersion, multiSendContract);
    }
    async getMultiSendCallOnlyContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid MultiSendCallOnly contract address');
        }
        const multiSendContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getMultiSendCallOnlyContractInstance)(safeVersion, multiSendContract);
    }
    async getCompatibilityFallbackHandlerContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid Compatibility Fallback Handler contract address');
        }
        const multiSendContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getCompatibilityFallbackHandlerContractInstance)(safeVersion, multiSendContract);
    }
    async getSignMessageLibContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SignMessageLib contract address');
        }
        const signMessageLibContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getSignMessageLibContractInstance)(safeVersion, signMessageLibContract);
    }
    async getCreateCallContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid CreateCall contract address');
        }
        const createCallContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getCreateCallContractInstance)(safeVersion, createCallContract);
    }
    async getSimulateTxAccessorContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? singletonDeployment?.networkAddresses[chainId];
        if (!contractAddress) {
            throw new Error('Invalid SimulateTxAccessor contract address');
        }
        const simulateTxAccessorContract = this.getContract(contractAddress, customContractAbi ?? singletonDeployment?.abi);
        return (0, contractInstancesWeb3_1.getSimulateTxAccessorContractInstance)(safeVersion, simulateTxAccessorContract);
    }
    getContract(address, abi, options) {
        return new (__classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.Contract)(abi, address, options);
    }
    async getContractCode(address, defaultBlock) {
        const code = defaultBlock
            ? await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getCode(address, defaultBlock)
            : await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getCode(address);
        return code;
    }
    async isContractDeployed(address, defaultBlock) {
        const contractCode = await this.getContractCode(address, defaultBlock);
        return contractCode !== '0x';
    }
    async getStorageAt(address, position) {
        const content = await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getStorageAt(address, position);
        const decodedContent = this.decodeParameters(['address'], content);
        return decodedContent[0];
    }
    async getTransaction(transactionHash) {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.getTransaction(transactionHash);
    }
    async getSignerAddress() {
        return __classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f");
    }
    signMessage(message) {
        if (!__classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f")) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.sign(message, __classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f"));
    }
    async signTypedData(safeTransactionEIP712Args, methodVersion) {
        if (!__classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f")) {
            throw new Error('This method requires a signer');
        }
        const typedData = (0, utils_1$1.generateTypedData)(safeTransactionEIP712Args);
        let method = 'eth_signTypedData_v3';
        if (methodVersion === 'v4') {
            method = 'eth_signTypedData_v4';
        }
        else if (!methodVersion) {
            method = 'eth_signTypedData';
        }
        const jsonTypedData = JSON.stringify(typedData);
        const signedTypedData = {
            jsonrpc: '2.0',
            method,
            params: methodVersion === 'v3' || methodVersion === 'v4'
                ? [__classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f"), jsonTypedData]
                : [jsonTypedData, __classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f")],
            from: __classPrivateFieldGet$1(this, _Web3Adapter_signerAddress, "f"),
            id: new Date().getTime()
        };
        return new Promise((resolve, reject) => {
            const provider = __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").currentProvider;
            function callback(err, val) {
                if (err) {
                    reject(err);
                    return;
                }
                if (val?.result == null) {
                    reject(new Error("EIP-712 is not supported by user's wallet"));
                    return;
                }
                resolve(val.result);
            }
            provider.send(signedTypedData, callback);
        });
    }
    async estimateGas(transaction, callback) {
        return (await __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.estimateGas(transaction, callback)).toString();
    }
    call(transaction, defaultBlock) {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.call(transaction, defaultBlock);
    }
    encodeParameters(types, values) {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.abi.encodeParameters(types, values);
    }
    decodeParameters(types, values) {
        return __classPrivateFieldGet$1(this, _Web3Adapter_web3, "f").eth.abi.decodeParameters(types, values);
    }
}
_Web3Adapter_web3 = new WeakMap(), _Web3Adapter_signerAddress = new WeakMap();
Web3Adapter$1.default = Web3Adapter;

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(web3, "__esModule", { value: true });
web3.Web3Adapter = web3.SignMessageLibWeb3Contract = web3.SafeProxyFactoryWeb3Contract = web3.SafeContractWeb3 = web3.MultiSendWeb3Contract = web3.MultiSendCallOnlyWeb3Contract = web3.CreateCallWeb3Contract = void 0;
const Web3Adapter_1 = __importDefault$1(Web3Adapter$1);
web3.Web3Adapter = Web3Adapter_1.default;
const CreateCallWeb3Contract_1 = __importDefault$1(CreateCallWeb3Contract$1);
web3.CreateCallWeb3Contract = CreateCallWeb3Contract_1.default;
const MultiSendWeb3Contract_1 = __importDefault$1(MultiSendWeb3Contract$1);
web3.MultiSendWeb3Contract = MultiSendWeb3Contract_1.default;
const MultiSendCallOnlyWeb3Contract_1 = __importDefault$1(MultiSendCallOnlyWeb3Contract$1);
web3.MultiSendCallOnlyWeb3Contract = MultiSendCallOnlyWeb3Contract_1.default;
const SafeContractWeb3_1 = __importDefault$1(SafeContractWeb3$1);
web3.SafeContractWeb3 = SafeContractWeb3_1.default;
const SafeProxyFactoryWeb3Contract_1 = __importDefault$1(SafeProxyFactoryWeb3Contract$1);
web3.SafeProxyFactoryWeb3Contract = SafeProxyFactoryWeb3Contract_1.default;
const SignMessageLibWeb3Contract_1 = __importDefault$1(SignMessageLibWeb3Contract$1);
web3.SignMessageLibWeb3Contract = SignMessageLibWeb3Contract_1.default;

var safeFactory = {};

var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SafeFactory_contractNetworks, _SafeFactory_isL1SafeMasterCopy, _SafeFactory_safeVersion, _SafeFactory_ethAdapter, _SafeFactory_safeProxyFactoryContract, _SafeFactory_safeContract;
Object.defineProperty(safeFactory, "__esModule", { value: true });
const Safe_1 = __importDefault(Safe$1);
const config_1 = config$1;
const safeDeploymentContracts_1 = safeDeploymentContracts;
const utils_1 = utils$g;
class SafeFactory {
    constructor() {
        _SafeFactory_contractNetworks.set(this, void 0);
        _SafeFactory_isL1SafeMasterCopy.set(this, void 0);
        _SafeFactory_safeVersion.set(this, void 0);
        _SafeFactory_ethAdapter.set(this, void 0);
        _SafeFactory_safeProxyFactoryContract.set(this, void 0);
        _SafeFactory_safeContract.set(this, void 0);
    }
    static async create({ ethAdapter, safeVersion = config_1.DEFAULT_SAFE_VERSION, isL1SafeMasterCopy = false, contractNetworks }) {
        const safeFactorySdk = new SafeFactory();
        await safeFactorySdk.init({ ethAdapter, safeVersion, isL1SafeMasterCopy, contractNetworks });
        return safeFactorySdk;
    }
    async init({ ethAdapter, safeVersion, isL1SafeMasterCopy, contractNetworks }) {
        __classPrivateFieldSet(this, _SafeFactory_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _SafeFactory_safeVersion, safeVersion, "f");
        __classPrivateFieldSet(this, _SafeFactory_isL1SafeMasterCopy, isL1SafeMasterCopy, "f");
        __classPrivateFieldSet(this, _SafeFactory_contractNetworks, contractNetworks, "f");
        const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
        const customContracts = contractNetworks?.[chainId];
        __classPrivateFieldSet(this, _SafeFactory_safeProxyFactoryContract, await (0, safeDeploymentContracts_1.getProxyFactoryContract)({
            ethAdapter,
            safeVersion,
            customContracts
        }), "f");
        __classPrivateFieldSet(this, _SafeFactory_safeContract, await (0, safeDeploymentContracts_1.getSafeContract)({
            ethAdapter,
            safeVersion,
            isL1SafeMasterCopy,
            customContracts
        }), "f");
    }
    getEthAdapter() {
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f");
    }
    getSafeVersion() {
        return __classPrivateFieldGet(this, _SafeFactory_safeVersion, "f");
    }
    getAddress() {
        return __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").getAddress();
    }
    async getChainId() {
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
    }
    async predictSafeAddress(safeAccountConfig, saltNonce = utils_1.PREDETERMINED_SALT_NONCE) {
        const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
        const customContracts = __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")?.[chainId];
        const safeVersion = __classPrivateFieldGet(this, _SafeFactory_safeVersion, "f");
        const safeDeploymentConfig = { saltNonce, safeVersion };
        return (0, utils_1.predictSafeAddress)({
            ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
            safeAccountConfig,
            safeDeploymentConfig,
            isL1SafeMasterCopy: __classPrivateFieldGet(this, _SafeFactory_isL1SafeMasterCopy, "f"),
            customContracts
        });
    }
    async deploySafe({ safeAccountConfig, saltNonce = utils_1.PREDETERMINED_SALT_NONCE, options, callback }) {
        (0, utils_1.validateSafeAccountConfig)(safeAccountConfig);
        (0, utils_1.validateSafeDeploymentConfig)({ saltNonce });
        const signerAddress = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
            throw new Error('EthAdapter must be initialized with a signer to use this method');
        }
        const chainId = await this.getChainId();
        const customContracts = __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")?.[chainId];
        const initializer = await (0, utils_1.encodeSetupCallData)({
            ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
            safeAccountConfig,
            safeContract: __classPrivateFieldGet(this, _SafeFactory_safeContract, "f"),
            customContracts
        });
        if (options?.gas && options?.gasLimit) {
            throw new Error('Cannot specify gas and gasLimit together in transaction options');
        }
        const safeAddress = await __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").createProxy({
            safeMasterCopyAddress: __classPrivateFieldGet(this, _SafeFactory_safeContract, "f").getAddress(),
            initializer,
            saltNonce,
            options: {
                from: signerAddress,
                ...options
            },
            callback
        });
        const isContractDeployed = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").isContractDeployed(safeAddress);
        if (!isContractDeployed) {
            throw new Error('SafeProxy contract is not deployed on the current network');
        }
        const safe = await Safe_1.default.create({
            ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
            safeAddress,
            isL1SafeMasterCopy: __classPrivateFieldGet(this, _SafeFactory_isL1SafeMasterCopy, "f"),
            contractNetworks: __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")
        });
        return safe;
    }
}
_SafeFactory_contractNetworks = new WeakMap(), _SafeFactory_isL1SafeMasterCopy = new WeakMap(), _SafeFactory_safeVersion = new WeakMap(), _SafeFactory_ethAdapter = new WeakMap(), _SafeFactory_safeProxyFactoryContract = new WeakMap(), _SafeFactory_safeContract = new WeakMap();
safeFactory.default = SafeFactory;

var erc20 = {};

Object.defineProperty(erc20, "__esModule", { value: true });
erc20.createERC20TokenTransferTransaction = erc20.isGasTokenCompatibleWithHandlePayment = erc20.getERC20Decimals = void 0;
const abi_1 = require$$0$9;
const constants_1 = constants$4;
const ERC20_ABI = [
    'function transfer(address recipient, uint256 amount) returns (bool)',
    'function decimals() view returns (uint8)'
];
/**
 * Returns the number of decimals of a given ERC-20 token.
 *
 * @async
 * @param {string} tokenAddress - The address of the ERC-20 token.
 * @param {Safe} safe - The Safe object.
 * @returns {Promise<number>} The number of decimals that the token uses.
 * @throws "Invalid ERC-20 decimals"
 */
async function getERC20Decimals(tokenAddress, safe) {
    const ethAdapter = safe.getEthAdapter();
    const erc20Interface = new abi_1.Interface(ERC20_ABI);
    const getTokenDecimalsTransaction = {
        to: tokenAddress,
        from: tokenAddress,
        value: '0',
        data: erc20Interface.encodeFunctionData('decimals')
    };
    const response = await ethAdapter.call(getTokenDecimalsTransaction);
    const decimals = Number(response);
    if (Number.isNaN(decimals)) {
        throw new Error('Invalid ERC-20 decimals');
    }
    return decimals;
}
erc20.getERC20Decimals = getERC20Decimals;
const STANDARD_ERC20_DECIMALS = 18;
/**
 * Checks if the given gas token is compatible with the handlePayment function present in the Safe smart contract.
 * A token is considered compatible if it is a native token or a standard ERC-20 token with 18 decimals.
 *
 * @async
 * @export
 * @param {string} gasToken - The address of the gas token.
 * @param {Safe} safe - The Safe object.
 * @returns {Promise<boolean>} Returns true if the gas token is compatible, otherwise false.
 */
async function isGasTokenCompatibleWithHandlePayment(gasToken, safe) {
    const isNativeToken = gasToken === constants_1.ZERO_ADDRESS;
    if (isNativeToken) {
        return true;
    }
    // Only ERC20 tokens with the standard 18 decimals are compatible
    const gasTokenDecimals = await getERC20Decimals(gasToken, safe);
    const hasTokenStandardERC20Decimals = gasTokenDecimals === STANDARD_ERC20_DECIMALS;
    return hasTokenStandardERC20Decimals;
}
erc20.isGasTokenCompatibleWithHandlePayment = isGasTokenCompatibleWithHandlePayment;
/**
 * Creates a transaction object to perform a transfer of a specified amount of ERC-20 tokens to a given address.
 *
 * @export
 * @param {string} tokenAddress - The address of the ERC-20 token.
 * @param {string} toAddress - The address to which the tokens should be transferred.
 * @param {string} amount - The amount of tokens to transfer.
 * @returns {Transaction} Returns a transaction object that represents the transfer.
 */
function createERC20TokenTransferTransaction(tokenAddress, toAddress, amount) {
    const erc20Interface = new abi_1.Interface(ERC20_ABI);
    const transferTransaction = {
        to: tokenAddress,
        value: '0',
        data: erc20Interface.encodeFunctionData('transfer', [toAddress, amount])
    };
    return transferTransaction;
}
erc20.createERC20TokenTransferTransaction = createERC20TokenTransferTransaction;

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.standardizeSafeTransactionData = exports.predictSafeAddress = exports.isGasTokenCompatibleWithHandlePayment = exports.getSignMessageLibContract = exports.getSafeContract = exports.getProxyFactoryContract = exports.getMultiSendContract = exports.getMultiSendCallOnlyContract = exports.getERC20Decimals = exports.getCreateCallContract = exports.getCompatibilityFallbackHandlerContract = exports.encodeSetupCallData = exports.encodeMultiSendData = exports.encodeCreateProxyWithNonce = exports.Web3Adapter = exports.SignMessageLibWeb3Contract = exports.SignMessageLibEthersContract = exports.SafeProxyFactoryWeb3Contract = exports.SafeProxyFactoryEthersContract = exports.SafeFactory = exports.SafeContractWeb3 = exports.SafeContractEthers = exports.PREDETERMINED_SALT_NONCE = exports.MultiSendWeb3Contract = exports.MultiSendEthersContract = exports.MultiSendCallOnlyWeb3Contract = exports.MultiSendCallOnlyEthersContract = exports.EthersAdapter = exports.EthSafeSignature = exports.DEFAULT_SAFE_VERSION = exports.createERC20TokenTransferTransaction = exports.CreateCallWeb3Contract = exports.CreateCallEthersContract = exports.ContractManager = exports.estimateSafeDeploymentGas = exports.estimateSafeTxGas = exports.estimateTxGas = exports.estimateTxBaseGas = void 0;
	const Safe_1 = __importDefault(Safe$1);
	const ethers_1 = ethers;
	Object.defineProperty(exports, "CreateCallEthersContract", { enumerable: true, get: function () { return ethers_1.CreateCallEthersContract; } });
	Object.defineProperty(exports, "EthersAdapter", { enumerable: true, get: function () { return ethers_1.EthersAdapter; } });
	Object.defineProperty(exports, "MultiSendCallOnlyEthersContract", { enumerable: true, get: function () { return ethers_1.MultiSendCallOnlyEthersContract; } });
	Object.defineProperty(exports, "MultiSendEthersContract", { enumerable: true, get: function () { return ethers_1.MultiSendEthersContract; } });
	Object.defineProperty(exports, "SafeContractEthers", { enumerable: true, get: function () { return ethers_1.SafeContractEthers; } });
	Object.defineProperty(exports, "SafeProxyFactoryEthersContract", { enumerable: true, get: function () { return ethers_1.SafeProxyFactoryEthersContract; } });
	Object.defineProperty(exports, "SignMessageLibEthersContract", { enumerable: true, get: function () { return ethers_1.SignMessageLibEthersContract; } });
	const web3_1 = web3;
	Object.defineProperty(exports, "CreateCallWeb3Contract", { enumerable: true, get: function () { return web3_1.CreateCallWeb3Contract; } });
	Object.defineProperty(exports, "MultiSendCallOnlyWeb3Contract", { enumerable: true, get: function () { return web3_1.MultiSendCallOnlyWeb3Contract; } });
	Object.defineProperty(exports, "MultiSendWeb3Contract", { enumerable: true, get: function () { return web3_1.MultiSendWeb3Contract; } });
	Object.defineProperty(exports, "SafeContractWeb3", { enumerable: true, get: function () { return web3_1.SafeContractWeb3; } });
	Object.defineProperty(exports, "SafeProxyFactoryWeb3Contract", { enumerable: true, get: function () { return web3_1.SafeProxyFactoryWeb3Contract; } });
	Object.defineProperty(exports, "SignMessageLibWeb3Contract", { enumerable: true, get: function () { return web3_1.SignMessageLibWeb3Contract; } });
	Object.defineProperty(exports, "Web3Adapter", { enumerable: true, get: function () { return web3_1.Web3Adapter; } });
	const config_1 = config$1;
	Object.defineProperty(exports, "DEFAULT_SAFE_VERSION", { enumerable: true, get: function () { return config_1.DEFAULT_SAFE_VERSION; } });
	const safeDeploymentContracts_1 = safeDeploymentContracts;
	Object.defineProperty(exports, "getCompatibilityFallbackHandlerContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getCompatibilityFallbackHandlerContract; } });
	Object.defineProperty(exports, "getCreateCallContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getCreateCallContract; } });
	Object.defineProperty(exports, "getMultiSendCallOnlyContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getMultiSendCallOnlyContract; } });
	Object.defineProperty(exports, "getMultiSendContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getMultiSendContract; } });
	Object.defineProperty(exports, "getProxyFactoryContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getProxyFactoryContract; } });
	Object.defineProperty(exports, "getSafeContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getSafeContract; } });
	Object.defineProperty(exports, "getSignMessageLibContract", { enumerable: true, get: function () { return safeDeploymentContracts_1.getSignMessageLibContract; } });
	const utils_1 = utils$g;
	Object.defineProperty(exports, "PREDETERMINED_SALT_NONCE", { enumerable: true, get: function () { return utils_1.PREDETERMINED_SALT_NONCE; } });
	Object.defineProperty(exports, "encodeCreateProxyWithNonce", { enumerable: true, get: function () { return utils_1.encodeCreateProxyWithNonce; } });
	Object.defineProperty(exports, "encodeSetupCallData", { enumerable: true, get: function () { return utils_1.encodeSetupCallData; } });
	Object.defineProperty(exports, "predictSafeAddress", { enumerable: true, get: function () { return utils_1.predictSafeAddress; } });
	const contractManager_1 = __importDefault(contractManager);
	exports.ContractManager = contractManager_1.default;
	const safeFactory_1 = __importDefault(safeFactory);
	exports.SafeFactory = safeFactory_1.default;
	const utils_2 = requireUtils();
	Object.defineProperty(exports, "EthSafeSignature", { enumerable: true, get: function () { return utils_2.EthSafeSignature; } });
	Object.defineProperty(exports, "estimateTxBaseGas", { enumerable: true, get: function () { return utils_2.estimateTxBaseGas; } });
	Object.defineProperty(exports, "estimateTxGas", { enumerable: true, get: function () { return utils_2.estimateTxGas; } });
	Object.defineProperty(exports, "estimateSafeTxGas", { enumerable: true, get: function () { return utils_2.estimateSafeTxGas; } });
	Object.defineProperty(exports, "estimateSafeDeploymentGas", { enumerable: true, get: function () { return utils_2.estimateSafeDeploymentGas; } });
	const utils_3 = requireUtils$1();
	Object.defineProperty(exports, "encodeMultiSendData", { enumerable: true, get: function () { return utils_3.encodeMultiSendData; } });
	Object.defineProperty(exports, "standardizeSafeTransactionData", { enumerable: true, get: function () { return utils_3.standardizeSafeTransactionData; } });
	const erc_20_1 = erc20;
	Object.defineProperty(exports, "getERC20Decimals", { enumerable: true, get: function () { return erc_20_1.getERC20Decimals; } });
	Object.defineProperty(exports, "isGasTokenCompatibleWithHandlePayment", { enumerable: true, get: function () { return erc_20_1.isGasTokenCompatibleWithHandlePayment; } });
	Object.defineProperty(exports, "createERC20TokenTransferTransaction", { enumerable: true, get: function () { return erc_20_1.createERC20TokenTransferTransaction; } });
	exports.default = Safe_1.default;
	
} (src$4));

var safeCoreSdk = /*@__PURE__*/getDefaultExportFromCjs(src$4);

// excerpt from https://docs.safe.global/api-supported-networks#safe-transaction-service
const CHAIN_ID_TO_GNOSIS_SERVER_URL = {
  // mainnet
  1: "https://safe-transaction-mainnet.safe.global",
  // Sepolia
  11155111: "https://safe-transaction-sepolia.safe.global",
  // optimism
  10: "https://safe-transaction-optimism.safe.global",
  // bsc
  56: "https://safe-transaction-bsc.safe.global",
  // gnosis
  100: "https://safe-transaction-gnosis-chain.safe.global",
  // polygon
  137: "https://safe-transaction-polygon.safe.global",
  // avalanche
  43114: "https://safe-transaction-avalanche.safe.global",
  // arbitrum
  42161: "https://safe-transaction-arbitrum.safe.global",
  // celo
  42220: "https://safe-transaction-celo.safe.global",
  // Base mainnet
  8453: "https://safe-transaction-base.safe.global",
  // aurora
  1313161554: "https://safe-transaction-aurora.safe.global",
  //  Polygon zkEVM
  1101: "https://safe-transaction-zkevm.safe.global",
  //  ZkSync Mainnet
  324: "https://safe-transaction-zksync.safe.global"
};

const CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS = {
  // mainnet
  1: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // polygon
  137: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // bsc
  56: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // arbitrum
  42161: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // aurora
  1313161554: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // avalanche
  43114: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // optimism
  10: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // celo
  42220: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // gnosis chain - https://docs.safe.global/smart-account-supported-networks/v1.3.0#gnosis
  100: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // Sepolia - https://docs.safe.global/smart-account-supported-networks/v1.3.0#sepolia
  11155111: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // base mainnet - https://docs.safe.global/smart-account-supported-networks/v1.3.0#base
  8453: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // Polygon zkEVM - https://docs.safe.global/smart-account-supported-networks/v1.3.0#polygon-zkevm
  1101: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // ZkSync Mainnet - https://docs.safe.global/smart-account-supported-networks/v1.3.0#zksync-mainnet
  324: "0x357147caf9C0cCa67DfA0CF5369318d8193c8407"
};
const SIGN_MESSAGE_LIB_ABI = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "bytes32",
    name: "msgHash",
    type: "bytes32"
  }],
  name: "SignMsg",
  type: "event"
}, {
  inputs: [{
    internalType: "bytes",
    name: "message",
    type: "bytes"
  }],
  name: "getMessageHash",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "signMessage",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
const __IS_SERVER__ = typeof window === "undefined";
class SafeConnector extends Connector {
  // config

  // private options: SafeOptions;

  constructor() {
    super();
    _defineProperty(this, "supportedChains", SafeConnector.supportedChains);
    _defineProperty(this, "id", "safe-wallet");
    _defineProperty(this, "ready", !__IS_SERVER__);
    _defineProperty(this, "name", "Safe Wallet");
    if (!__IS_SERVER__) {
      this.ready = true;
    }
  }
  async connect(args) {
    if (!(args.chain.chainId in CHAIN_ID_TO_GNOSIS_SERVER_URL)) {
      throw new Error("Chain not supported by Safe");
    }
    this.safeSigner = await this.createSafeSigner(args);
    return await this.getAddress();
  }
  async createSafeSigner(params) {
    this.personalWallet = params.personalWallet;
    const signer = await params.personalWallet.getSigner();
    const safeAddress = params.safeAddress;
    const safeChainId = params.chain.chainId;
    if (!signer) {
      throw new Error("cannot create Gnosis Safe signer without a personal signer");
    }
    const signerChainId = await signer.getChainId();
    if (signerChainId !== safeChainId) {
      throw new Error("chainId of personal signer has to match safe chainId");
    }
    if (!safeAddress) {
      throw new Error("safeAddress is required");
    }
    if (!safeChainId) {
      throw new Error("safeChainId is required");
    }
    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];
    const signMessageLibAddress = CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS[safeChainId];
    if (!serverUrl || !signMessageLibAddress) {
      throw new Error("Chain not supported");
    }
    const ethAdapter = new src$4.EthersAdapter({
      ethers: ethers$1,
      signerOrProvider: signer
    });
    const safe = await safeCoreSdk.create({
      ethAdapter: ethAdapter,
      safeAddress
    });
    const service = new src$6.SafeService(serverUrl);
    const safeSigner = new src$6.SafeEthersSigner(safe, service, signer.provider);
    safeSigner.signMessage = async message => {
      // Encode the request to the signMessage function of the SafeMessageLib
      const contract = new BaseContract(signMessageLibAddress, SIGN_MESSAGE_LIB_ABI);
      const data = contract.interface.encodeFunctionData("signMessage", [hashMessage(message)]);
      const to = signMessageLibAddress;
      const value = "0";
      const operation = 1; // 1 indicates a delegatecall
      const safeTxGas = 50000;
      const baseGas = 50000;
      const gasPrice = 0;
      const gasToken = AddressZero;
      const refundReceiver = AddressZero;

      // Create the safe transaction to approve the signature
      const safeTx = await safe.createTransaction({
        safeTransactionData: {
          to,
          value,
          operation,
          data,
          baseGas,
          safeTxGas,
          gasPrice,
          gasToken,
          refundReceiver
        }
      });

      // Sign and propose the safe transaction
      const safeTxHash = await safe.getTransactionHash(safeTx);
      const safeSignature = await safe.signTransactionHash(safeTxHash);
      await service.proposeTx(await safe.getAddress(), safeTxHash, safeTx, safeSignature);

      // Poll while we wait for the safe transaction to reach minimum confirmations
      while (true) {
        try {
          const txDetails = await service.getSafeTxDetails(safeTxHash);
          if (txDetails.transactionHash) {
            await signer.provider?.waitForTransaction(txDetails.transactionHash);
            break;
          }
        } catch (e) {}
        await new Promise(resolve => setTimeout(resolve, 5000));
      }

      // For on-chain signatures, safe expects just "0x" as the signature
      return "0x";
    };

    // set the personal signer as "previous connector" so that we can re-connect to it later when disconnecting
    this.previousConnector = params.personalWallet;
    return safeSigner;
  }
  async disconnect() {
    this.safeSigner = undefined;
    this.previousConnector = undefined;
    return undefined;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return await signer.getAddress();
  }
  async getChainId() {
    return (await this.getSigner()).getChainId();
  }
  async getProvider() {
    const provider = (await this.getSigner()).provider;
    if (!provider) {
      throw new Error("No provider available");
    }
    return provider;
  }
  async getSigner() {
    if (!this.safeSigner) {
      throw new Error("not connected - please call connect() first");
    }
    return this.safeSigner;
  }
  async isConnected() {
    try {
      const account = await this.getAddress();
      return !!account;
    } catch (e) {
      return false;
    }
  }
  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      if (accounts[0]) {
        this.emit("change", {
          account: getAddress(accounts[0])
        });
      }
    }
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  switchChain() {
    throw new Error("Safe connector does not support switching chains");
  }
  updateChains() {}
  async setupListeners() {}
}
_defineProperty(SafeConnector, "supportedChains", /* @__PURE__ */(() => Object.keys(CHAIN_ID_TO_GNOSIS_SERVER_URL))());

export { SafeConnector };
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-safe.esm-f8002ac2.js.map
