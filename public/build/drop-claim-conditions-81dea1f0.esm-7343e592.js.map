{"version":3,"file":"drop-claim-conditions-81dea1f0.esm-7343e592.js","sources":["../../node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-81dea1f0.esm.js"],"sourcesContent":["import { utils, BigNumber, constants } from 'ethers';\nimport deepEqual from 'fast-deep-equal';\nimport { aP as resolveAddress, cz as AmountSchema, B as includesErrorMessage, d8 as isNode, cu as ContractWrapper } from './index-4902f18c.esm.js';\nimport { y as transformResultToClaimCondition, z as legacyContractModelToAbstract, A as newContractModelToAbstract, C as ClaimEligibility, D as convertQuantityToBigNumber, f as fetchSnapshotEntryForAddress, E as prepareClaim, F as SnapshotFormatVersion, H as processClaimConditionInputs, I as abstractContractModelToLegacy, J as abstractContractModelToNew, K as updateExistingClaimConditions } from './signature-20263122.esm.js';\nimport { i as isNativeToken, C as ContractEncoder } from './fetchCurrencyValue-f402c164.esm.js';\nimport { d as detectContractFeature, h as hasFunction } from './contract-appuri-c2530b2f.esm.js';\nimport { b as buildTransactionFunction, T as Transaction } from './transactions-bf210f84.esm.js';\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @erc721\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns The claim condition metadata\n   */\n  async getActive(options) {\n    const [cc, metadata, tokenDecimals] = await Promise.all([this.get(), this.metadata.get(), this.getTokenDecimals()]);\n    return await transformResultToClaimCondition(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns The claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\n      const startId = currentStartId.toNumber();\n      const count = countBn.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(this.get(i));\n      }\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const [resolvedAddress, decimals] = await Promise.all([resolveAddress(addressToCheck), this.getTokenDecimals()]);\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\n      }\n      const now = BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n        return reasons;\n      }\n    }\n\n    // if not within a browser context, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const [metadata, resolvedAddress] = await Promise.all([this.metadata.get(), resolveAddress(claimerAddress)]);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress - the wallet address to check\n   * @returns The total supply claimed\n   */\n  async getSupplyClaimedByWallet(walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let claimConditionsProcessed = claimConditionInputs;\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditionInputs.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditionInputs.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\n      const merkleInfo = {};\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      const metadata = await _this.metadata.get();\n      const encoded = [];\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      const cw = _this.contractWrapper;\n      const baseContractEncoder = new ContractEncoder(cw);\n      if (_this.isLegacySinglePhaseDrop(cw)) {\n        const contractEncoderLegacy = new ContractEncoder(cw);\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isNewMultiphaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(newConditionInputs);\n  });\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.read(\"decimals\", []);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns  `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const [addressToClaim, activeClaimConditions] = await Promise.all([address ? address : this.contractWrapper.getSignerAddress(), this.getActive()]);\n    return prepareClaim(addressToClaim, quantity, activeClaimConditions, async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - The address to claim to\n   * @param quantity - The quantity to claim\n   * @param options - Options to override the claim transaction\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\nexport { DropClaimConditions as D };\n"],"names":["utils.parseUnits","utils.stripZeros","constants.MaxUint256","constants.AddressZero","utils.hexZeroPad","utils.toUtf8Bytes"],"mappings":";;;;AAQA;AACA;AACA;AACA;AACA;AACA,MAAM,mBAAmB,CAAC;AAC1B,EAAE,WAAW,CAAC,eAAe,EAAE,QAAQ,EAAE,OAAO,EAAE;AAClD,IAAI,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AAC3B,IAAI,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;AAC3C,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC7B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,SAAS,CAAC,OAAO,EAAE;AAC3B,IAAI,MAAM,CAAC,EAAE,EAAE,QAAQ,EAAE,aAAa,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;AACxH,IAAI,OAAO,MAAM,+BAA+B,CAAC,EAAE,EAAE,aAAa,EAAE,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,EAAE,QAAQ,CAAC,MAAM,IAAI,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,aAAa,IAAI,KAAK,CAAC,CAAC;AAC9K,GAAG;AACH,EAAE,MAAM,GAAG,CAAC,WAAW,EAAE;AACzB,IAAI,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAC5D,MAAM,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;AAClF,MAAM,OAAO,6BAA6B,CAAC,aAAa,CAAC,CAAC;AAC1D,KAAK,MAAM,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAClE,MAAM,MAAM,EAAE,GAAG,WAAW,KAAK,SAAS,GAAG,WAAW,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;AAC5H,MAAM,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3F,MAAM,OAAO,6BAA6B,CAAC,aAAa,CAAC,CAAC;AAC1D,KAAK,MAAM,IAAI,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAChE,MAAM,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;AAClF,MAAM,OAAO,0BAA0B,CAAC,aAAa,CAAC,CAAC;AACvD,KAAK,MAAM,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAC/D,MAAM,MAAM,EAAE,GAAG,WAAW,KAAK,SAAS,GAAG,WAAW,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;AAC5H,MAAM,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3F,MAAM,OAAO,0BAA0B,CAAC,aAAa,CAAC,CAAC;AACvD,KAAK,MAAM;AACX,MAAM,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;AACpE,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,MAAM,CAAC,OAAO,EAAE;AACxB,IAAI,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAC7G,MAAM,MAAM,CAAC,cAAc,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;AAC9F,MAAM,MAAM,OAAO,GAAG,cAAc,CAAC,QAAQ,EAAE,CAAC;AAChD,MAAM,MAAM,KAAK,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAC;AACvC,MAAM,MAAM,UAAU,GAAG,EAAE,CAAC;AAC5B,MAAM,KAAK,IAAI,CAAC,GAAG,OAAO,EAAE,CAAC,GAAG,OAAO,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AACtD,QAAQ,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,OAAO;AACP,MAAM,MAAM,CAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,iBAAiB,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,gBAAgB,EAAE,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC;AAC1I,MAAM,OAAO,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,IAAI,+BAA+B,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,EAAE,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,aAAa,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AACvM,KAAK,MAAM;AACX,MAAM,OAAO,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;AAC7C,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,QAAQ,CAAC,QAAQ,EAAE,cAAc,EAAE;AAC3C;AACA,IAAI,IAAI,cAAc,EAAE;AACxB,MAAM,cAAc,GAAG,MAAM,cAAc,CAAC,cAAc,CAAC,CAAC;AAC5D,KAAK;AACL,IAAI,OAAO,CAAC,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,EAAE,cAAc,CAAC,EAAE,MAAM,KAAK,CAAC,CAAC;AAC5F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,4BAA4B,CAAC,QAAQ,EAAE,cAAc,EAAE;AAC/D,IAAI,MAAM,OAAO,GAAG,EAAE,CAAC;AACvB,IAAI,IAAI,oBAAoB,CAAC;AAC7B,IAAI,IAAI,cAAc,CAAC;AACvB,IAAI,IAAI,cAAc,KAAK,SAAS,EAAE;AACtC,MAAM,IAAI;AACV,QAAQ,cAAc,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,CAAC;AACvE,OAAO,CAAC,OAAO,GAAG,EAAE;AACpB,QAAQ,OAAO,CAAC,IAAI,CAAC,8BAA8B,EAAE,GAAG,CAAC,CAAC;AAC1D,OAAO;AACP,KAAK;AACL;AACA;AACA,IAAI,IAAI,CAAC,cAAc,EAAE;AACzB,MAAM,OAAO,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;AACzC,KAAK;AACL,IAAI,MAAM,CAAC,eAAe,EAAE,QAAQ,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,cAAc,CAAC,cAAc,CAAC,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;AACrH,IAAI,MAAM,oBAAoB,GAAGA,UAAgB,CAAC,YAAY,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;AAC1F,IAAI,IAAI;AACR,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;AAC9C,KAAK,CAAC,OAAO,GAAG,EAAE;AAClB,MAAM,IAAI,oBAAoB,CAAC,GAAG,EAAE,YAAY,CAAC,IAAI,oBAAoB,CAAC,GAAG,EAAE,0BAA0B,CAAC,EAAE;AAC5G,QAAQ,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;AAC3D,QAAQ,OAAO,OAAO,CAAC;AACvB,OAAO;AACP,MAAM,OAAO,CAAC,IAAI,CAAC,sCAAsC,EAAE,GAAG,CAAC,CAAC;AAChE,MAAM,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;AAC7C,MAAM,OAAO,OAAO,CAAC;AACrB,KAAK;AACL,IAAI,IAAI,cAAc,CAAC,eAAe,KAAK,WAAW,EAAE;AACxD,MAAM,MAAM,kBAAkB,GAAGA,UAAgB,CAAC,cAAc,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;AAC5F,MAAM,IAAI,kBAAkB,CAAC,EAAE,CAAC,oBAAoB,CAAC,EAAE;AACvD,QAAQ,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;AACvD,QAAQ,OAAO,OAAO,CAAC;AACvB,OAAO;AACP,KAAK;AACL;AACA;AACA,IAAI,MAAM,eAAe,GAAGC,UAAgB,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;AAC5E,IAAI,MAAM,YAAY,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;AACpD,IAAI,IAAI,cAAc,GAAG,IAAI,CAAC;AAC9B,IAAI,IAAI,YAAY,EAAE;AACtB,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;AACpE,MAAM,IAAI,CAAC,cAAc,KAAK,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE;AACxI;AACA,QAAQ,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;AACzD,QAAQ,OAAO,OAAO,CAAC;AACvB,OAAO;AACP,MAAM,IAAI,cAAc,EAAE;AAC1B,QAAQ,IAAI;AACZ,UAAU,MAAM,iBAAiB,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,eAAe,CAAC,CAAC;AACxG,UAAU,IAAI,gBAAgB,CAAC;AAC/B,UAAU,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACjE,YAAY,oBAAoB,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;AACpG;AACA,YAAY,CAAC,gBAAgB,CAAC,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,wBAAwB,EAAE,CAAC,oBAAoB,EAAE,eAAe,EAAE,QAAQ,EAAE,iBAAiB,CAAC,MAAM,EAAE,iBAAiB,CAAC,YAAY,CAAC,CAAC,CAAC;AACxM,YAAY,IAAI,CAAC,gBAAgB,EAAE;AACnC,cAAc,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;AAC/D,cAAc,OAAO,OAAO,CAAC;AAC7B,aAAa;AACb,WAAW,MAAM,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACzE,YAAY,CAAC,gBAAgB,CAAC,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,wBAAwB,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE;AACvH,cAAc,KAAK,EAAE,iBAAiB,CAAC,MAAM;AAC7C,cAAc,sBAAsB,EAAE,iBAAiB,CAAC,YAAY;AACpE,aAAa,CAAC,CAAC,CAAC;AAChB,YAAY,IAAI,CAAC,gBAAgB,EAAE;AACnC,cAAc,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;AAC/D,cAAc,OAAO,OAAO,CAAC;AAC7B,aAAa;AACb,WAAW,MAAM,IAAI,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACtE,YAAY,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,iBAAiB,CAAC,eAAe,EAAE,iBAAiB,CAAC,KAAK,EAAE;AACnJ,cAAc,KAAK,EAAE,iBAAiB,CAAC,MAAM;AAC7C,cAAc,sBAAsB,EAAE,iBAAiB,CAAC,YAAY;AACpE,cAAc,QAAQ,EAAE,iBAAiB,CAAC,sBAAsB;AAChE,cAAc,aAAa,EAAE,iBAAiB,CAAC,YAAY;AAC3D,aAAa,CAAC,CAAC,CAAC;AAChB,WAAW,MAAM,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACrE,YAAY,oBAAoB,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;AACpG,YAAY,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,oBAAoB,EAAE,eAAe,EAAE,QAAQ,EAAE,iBAAiB,CAAC,eAAe,EAAE,iBAAiB,CAAC,KAAK,EAAE;AACzK,cAAc,KAAK,EAAE,iBAAiB,CAAC,MAAM;AAC7C,cAAc,sBAAsB,EAAE,iBAAiB,CAAC,YAAY;AACpE,cAAc,QAAQ,EAAE,iBAAiB,CAAC,sBAAsB;AAChE,cAAc,aAAa,EAAE,iBAAiB,CAAC,YAAY;AAC3D,aAAa,CAAC,CAAC,CAAC;AAChB,WAAW;AACX,SAAS,CAAC,OAAO,CAAC,EAAE;AACpB,UAAU,OAAO,CAAC,IAAI,CAAC,mCAAmC,EAAE,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC1F,UAAU,MAAM,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AAClC,UAAU,QAAQ,MAAM;AACxB,YAAY,KAAK,MAAM;AACvB,cAAc,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,yBAAyB,CAAC,CAAC;AACvE,cAAc,MAAM;AACpB,YAAY,KAAK,kBAAkB;AACnC,cAAc,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;AAClE,cAAc,MAAM;AACpB,YAAY,KAAK,YAAY;AAC7B,cAAc,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;AAC7D,cAAc,MAAM;AACpB,YAAY,KAAK,gBAAgB;AACjC,cAAc,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;AAClE,cAAc,MAAM;AACpB,YAAY;AACZ,cAAc;AACd,gBAAgB,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;AACjE,gBAAgB,MAAM;AACtB,eAAe;AACf,WAAW;AACX,UAAU,OAAO,OAAO,CAAC;AACzB,SAAS;AACT,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAC3G,MAAM,IAAI,aAAa,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC5C,MAAM,IAAI,YAAY,GAAG,0BAA0B,CAAC,cAAc,CAAC,qBAAqB,EAAE,QAAQ,CAAC,CAAC;AACpG,MAAM,IAAI;AACV,QAAQ,aAAa,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,eAAe,CAAC,CAAC;AAC7E,OAAO,CAAC,OAAO,CAAC,EAAE;AAClB;AACA,OAAO;AACP,MAAM,IAAI,cAAc,EAAE;AAC1B,QAAQ,YAAY,GAAG,0BAA0B,CAAC,cAAc,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;AACzF,OAAO;AACP,MAAM,IAAI,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,EAAE;AAC1F,QAAQ,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,yBAAyB,CAAC,CAAC;AACjE,QAAQ,OAAO,OAAO,CAAC;AACvB,OAAO;AACP;AACA;AACA;AACA,MAAM,IAAI,CAAC,YAAY,IAAI,YAAY,IAAI,CAAC,cAAc,EAAE;AAC5D,QAAQ,IAAI,YAAY,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACnE,UAAU,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;AAC3D,UAAU,OAAO,OAAO,CAAC;AACzB,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,IAAI,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACjH,MAAM,IAAI,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACjG,MAAM,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAC7D,QAAQ,oBAAoB,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;AAChG,QAAQ,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,oBAAoB,EAAE,eAAe,CAAC,CAAC,CAAC;AACtJ,OAAO,MAAM,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACrE;AACA,QAAQ,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;AAChI,OAAO;AACP,MAAM,MAAM,GAAG,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvD,MAAM,IAAI,oBAAoB,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,qBAAqB,CAAC,EAAE;AACvE;AACA,QAAQ,IAAI,qBAAqB,CAAC,EAAE,CAACC,UAAoB,CAAC,EAAE;AAC5D,UAAU,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;AACxD,SAAS,MAAM;AACf,UAAU,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,8BAA8B,CAAC,CAAC;AACxE,SAAS;AACT,QAAQ,OAAO,OAAO,CAAC;AACvB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,IAAI,IAAI,cAAc,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,MAAM,EAAE,EAAE;AAChD,MAAM,MAAM,UAAU,GAAG,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;AAC5E,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,CAAC;AAC1D,MAAM,IAAI,aAAa,CAAC,cAAc,CAAC,eAAe,CAAC,EAAE;AACzD,QAAQ,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;AACnE,QAAQ,IAAI,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE;AACpC,UAAU,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;AACzD,SAAS;AACT,OAAO,MAAM;AACb,QAAQ,MAAM,QAAQ,GAAG,CAAC,MAAM,OAAO,mBAAkD,qCAAC,EAAE,OAAO,CAAC;AACpG,QAAQ,MAAM,KAAK,GAAG,IAAI,eAAe,CAAC,QAAQ,EAAE,cAAc,CAAC,eAAe,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;AAChH,QAAQ,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;AACzE,QAAQ,IAAI,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE;AACpC,UAAU,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;AACzD,SAAS;AACT,OAAO;AACP,KAAK;AACL,IAAI,OAAO,OAAO,CAAC;AACnB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,gBAAgB,CAAC,cAAc,EAAE,gBAAgB,EAAE;AAC3D,IAAI,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;AAC5D,IAAI,MAAM,UAAU,GAAG,cAAc,CAAC,UAAU,CAAC;AACjD,IAAI,MAAM,eAAe,GAAGD,UAAgB,CAAC,UAAU,CAAC,CAAC;AACzD,IAAI,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;AACpC,MAAM,MAAM,CAAC,QAAQ,EAAE,eAAe,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,cAAc,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;AACnH,MAAM,OAAO,MAAM,4BAA4B,CAAC,eAAe,EAAE,UAAU,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,wBAAwB,EAAE,CAAC,CAAC;AAC5L,KAAK,MAAM;AACX,MAAM,OAAO,IAAI,CAAC;AAClB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,wBAAwB,CAAC,aAAa,EAAE;AAChD,IAAI,MAAM,eAAe,GAAG,MAAM,cAAc,CAAC,aAAa,CAAC,CAAC;AAChE,IAAI,IAAI,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACzD,MAAM,OAAO,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,0BAA0B,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;AAC5F,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACxD,MAAM,MAAM,sBAAsB,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;AACtG,MAAM,OAAO,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,0BAA0B,EAAE,CAAC,sBAAsB,EAAE,eAAe,CAAC,CAAC,CAAC;AACpH,KAAK;AACL,IAAI,MAAM,IAAI,KAAK,CAAC,sEAAsE,CAAC,CAAC;AAC5F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,kBAAkB,wBAAwB,CAAC,CAAC,MAAM;AACvD,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC;AACrB,IAAI,OAAO,gBAAgB,oBAAoB,EAAE;AACjD,MAAM,IAAI,2BAA2B,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;AAClH,MAAM,IAAI,wBAAwB,GAAG,oBAAoB,CAAC;AAC1D,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,KAAK,CAAC,oBAAoB,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE;AACrH,QAAQ,2BAA2B,GAAG,IAAI,CAAC;AAC3C,QAAQ,IAAI,oBAAoB,CAAC,MAAM,KAAK,CAAC,EAAE;AAC/C,UAAU,wBAAwB,GAAG,CAAC;AACtC,YAAY,SAAS,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;AAClC,YAAY,eAAe,EAAEE,WAAqB;AAClD,YAAY,KAAK,EAAE,CAAC;AACpB,YAAY,kBAAkB,EAAE,CAAC;AACjC,YAAY,qBAAqB,EAAE,CAAC;AACpC,YAAY,aAAa,EAAE,CAAC;AAC5B,YAAY,cAAc,EAAEC,UAAgB,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;AACrD,YAAY,QAAQ,EAAE,EAAE;AACxB,WAAW,CAAC,CAAC;AACb,SAAS,MAAM,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;AACpD,UAAU,MAAM,IAAI,KAAK,CAAC,uFAAuF,CAAC,CAAC;AACnH,SAAS;AACT,OAAO;AACP;AACA;AACA,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,KAAK,CAAC,mBAAmB,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE;AACjH,QAAQ,wBAAwB,CAAC,OAAO,CAAC,EAAE,IAAI;AAC/C,UAAU,IAAI,EAAE,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,KAAK,EAAE,CAAC,qBAAqB,KAAK,SAAS,IAAI,EAAE,CAAC,qBAAqB,KAAK,WAAW,CAAC,EAAE;AAC7I,YAAY,MAAM,IAAI,KAAK,CAAC,mFAAmF,GAAG,iHAAiH,GAAG,iHAAiH,CAAC,CAAC;AACzV,WAAW;AACX,UAAU,IAAI,EAAE,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,GAAG,IAAI,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI;AAC5H,YAAY,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;AACvC,cAAc,OAAO,CAAC,CAAC;AACvB,aAAa,MAAM;AACnB,cAAc,OAAO,MAAM,CAAC,CAAC,CAAC,YAAY,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;AAC7D,aAAa;AACb,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,OAAO,KAAK;AACtC,YAAY,OAAO,GAAG,GAAG,OAAO,CAAC;AACjC,WAAW,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE;AACvB,YAAY,MAAM,IAAI,KAAK,CAAC,+HAA+H,CAAC,CAAC;AAC7J,WAAW;AACX,SAAS,CAAC,CAAC;AACX,OAAO;AACP;AACA;AACA,MAAM,MAAM;AACZ,QAAQ,aAAa;AACrB,QAAQ,gBAAgB;AACxB,OAAO,GAAG,MAAM,2BAA2B,CAAC,wBAAwB,EAAE,MAAM,KAAK,CAAC,gBAAgB,EAAE,EAAE,KAAK,CAAC,eAAe,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,wBAAwB,EAAE,CAAC,CAAC;AAC5L,MAAM,MAAM,UAAU,GAAG,EAAE,CAAC;AAC5B,MAAM,aAAa,CAAC,OAAO,CAAC,CAAC,IAAI;AACjC,QAAQ,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC;AACjD,OAAO,CAAC,CAAC;AACT,MAAM,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;AAClD,MAAM,MAAM,OAAO,GAAG,EAAE,CAAC;AACzB;AACA;AACA,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE;AACnD,QAAQ,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,kBAAkB,CAAC;AACvE,UAAU,GAAG,QAAQ;AACrB,UAAU,MAAM,EAAE,UAAU;AAC5B,SAAS,CAAC,CAAC;AACX;AACA,QAAQ,MAAM,WAAW,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,uBAAuB,CAAC,cAAc,CAAC,CAAC;AACzF;AACA;AACA;AACA,QAAQ,IAAI,WAAW,CAAC,gBAAgB,EAAE,KAAK,CAAC,eAAe,CAAC,EAAE;AAClE,UAAU,MAAM,eAAe,GAAG,IAAI,eAAe,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AAC7E,UAAU,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,gBAAgB,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAChF,SAAS,MAAM;AACf,UAAU,MAAM,IAAI,KAAK,CAAC,iHAAiH,CAAC,CAAC;AAC7I,SAAS;AACT,OAAO;AACP,MAAM,MAAM,EAAE,GAAG,KAAK,CAAC,eAAe,CAAC;AACvC,MAAM,MAAM,mBAAmB,GAAG,IAAI,eAAe,CAAC,EAAE,CAAC,CAAC;AAC1D,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,EAAE,CAAC,EAAE;AAC7C,QAAQ,MAAM,qBAAqB,GAAG,IAAI,eAAe,CAAC,EAAE,CAAC,CAAC;AAC9D,QAAQ,OAAO,CAAC,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,oBAAoB,EAAE,CAAC,6BAA6B,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,EAAE,2BAA2B,CAAC,CAAC,CAAC,CAAC;AAC5J,OAAO,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,EAAE,CAAC,EAAE;AACnD,QAAQ,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,oBAAoB,EAAE,CAAC,gBAAgB,CAAC,GAAG,CAAC,6BAA6B,CAAC,EAAE,2BAA2B,CAAC,CAAC,CAAC,CAAC;AAC3J,OAAO,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,EAAE,CAAC,EAAE;AACjD,QAAQ,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,oBAAoB,EAAE,CAAC,0BAA0B,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,EAAE,2BAA2B,CAAC,CAAC,CAAC,CAAC;AACvJ,OAAO,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,EAAE,CAAC,EAAE;AAChD,QAAQ,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,oBAAoB,EAAE,CAAC,gBAAgB,CAAC,GAAG,CAAC,0BAA0B,CAAC,EAAE,2BAA2B,CAAC,CAAC,CAAC,CAAC;AACxJ,OAAO,MAAM;AACb,QAAQ,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;AACtE,OAAO;AACP,MAAM,IAAI,WAAW,CAAC,WAAW,EAAE,KAAK,CAAC,eAAe,CAAC,EAAE;AAC3D,QAAQ,OAAO,WAAW,CAAC,mBAAmB,CAAC;AAC/C,UAAU,eAAe,EAAE,KAAK,CAAC,eAAe;AAChD,UAAU,MAAM,EAAE,WAAW;AAC7B,UAAU,IAAI,EAAE,CAAC,OAAO,CAAC;AACzB,SAAS,CAAC,CAAC;AACX,OAAO;AACP,MAAM,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;AAC7D,KAAK,CAAC;AACN,GAAG,GAAG,CAAC,CAAC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,kBAAkB,wBAAwB,CAAC,OAAO,KAAK,EAAE,mBAAmB,KAAK;AACzF,IAAI,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC;AACnD,IAAI,MAAM,kBAAkB,GAAG,MAAM,6BAA6B,CAAC,KAAK,EAAE,mBAAmB,EAAE,kBAAkB,CAAC,CAAC;AACnH,IAAI,OAAO,MAAM,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;AACtD,GAAG,CAAC,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,gBAAgB,GAAG;AAC3B,IAAI,IAAI,qBAAqB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,EAAE;AAC9D,MAAM,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;AACvD,KAAK,MAAM;AACX,MAAM,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAChC,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,YAAY,CAAC,QAAQ,EAAE,mBAAmB,EAAE;AACpD,IAAI,IAAI,QAAQ,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AACzF,IAAI,IAAI,OAAO,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;AAClE,IAAI,MAAM,CAAC,cAAc,EAAE,qBAAqB,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,GAAG,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AACvJ,IAAI,OAAO,YAAY,CAAC,cAAc,EAAE,QAAQ,EAAE,qBAAqB,EAAE,YAAY,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,EAAE,mBAAmB,EAAE,IAAI,CAAC,wBAAwB,EAAE,CAAC,CAAC;AAC7N,GAAG;AACH,EAAE,MAAM,iBAAiB,CAAC,kBAAkB,EAAE,QAAQ,EAAE,iBAAiB,EAAE;AAC3E,IAAI,MAAM,eAAe,GAAG,MAAM,cAAc,CAAC,kBAAkB,CAAC,CAAC;AACrE,IAAI,IAAI,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AAC3D,MAAM,OAAO,CAAC,eAAe,EAAE,QAAQ,EAAE,iBAAiB,CAAC,eAAe,EAAE,iBAAiB,CAAC,KAAK,EAAE,iBAAiB,CAAC,MAAM,EAAE,iBAAiB,CAAC,YAAY,CAAC,CAAC;AAC/J,KAAK,MAAM,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACnE,MAAM,OAAO,CAAC,eAAe,EAAE,QAAQ,EAAE,iBAAiB,CAAC,eAAe,EAAE,iBAAiB,CAAC,KAAK,EAAE;AACrG,QAAQ,KAAK,EAAE,iBAAiB,CAAC,MAAM;AACvC,QAAQ,sBAAsB,EAAE,iBAAiB,CAAC,YAAY;AAC9D,OAAO,EAAEC,WAAiB,CAAC,EAAE,CAAC,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,CAAC,eAAe,EAAE,QAAQ,EAAE,iBAAiB,CAAC,eAAe,EAAE,iBAAiB,CAAC,KAAK,EAAE;AACnG,MAAM,KAAK,EAAE,iBAAiB,CAAC,MAAM;AACrC,MAAM,sBAAsB,EAAE,iBAAiB,CAAC,YAAY;AAC5D,MAAM,aAAa,EAAE,iBAAiB,CAAC,YAAY;AACnD,MAAM,QAAQ,EAAE,iBAAiB,CAAC,sBAAsB;AACxD,KAAK,EAAEA,WAAiB,CAAC,EAAE,CAAC,CAAC,CAAC;AAC9B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,mBAAmB,CAAC,kBAAkB,EAAE,QAAQ,EAAE,OAAO,EAAE;AACnE;AACA,IAAI,IAAI,OAAO,EAAE,aAAa,EAAE;AAChC,MAAM,MAAM,IAAI,KAAK,CAAC,mGAAmG,CAAC,CAAC;AAC3H,KAAK;AACL,IAAI,MAAM,iBAAiB,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,OAAO,EAAE,mBAAmB,KAAK,SAAS,GAAG,IAAI,GAAG,OAAO,CAAC,mBAAmB,EAAE,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC;AAChL,IAAI,OAAO,WAAW,CAAC,mBAAmB,CAAC;AAC3C,MAAM,eAAe,EAAE,IAAI,CAAC,eAAe;AAC3C,MAAM,MAAM,EAAE,OAAO;AACrB,MAAM,IAAI,EAAE,MAAM,IAAI,CAAC,iBAAiB,CAAC,kBAAkB,EAAE,QAAQ,EAAE,iBAAiB,CAAC;AACzF,MAAM,SAAS,EAAE,iBAAiB,CAAC,SAAS;AAC5C,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,oBAAoB,CAAC,eAAe,EAAE;AACxC,IAAI,OAAO,qBAAqB,CAAC,eAAe,EAAE,yBAAyB,CAAC,IAAI,qBAAqB,CAAC,eAAe,EAAE,wBAAwB,CAAC,CAAC;AACjJ,GAAG;AACH,EAAE,mBAAmB,CAAC,eAAe,EAAE;AACvC,IAAI,OAAO,qBAAqB,CAAC,eAAe,EAAE,qBAAqB,CAAC,IAAI,qBAAqB,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;AACzI,GAAG;AACH,EAAE,uBAAuB,CAAC,eAAe,EAAE;AAC3C,IAAI,OAAO,qBAAqB,CAAC,eAAe,EAAE,yBAAyB,CAAC,IAAI,qBAAqB,CAAC,eAAe,EAAE,wBAAwB,CAAC,CAAC;AACjJ,GAAG;AACH,EAAE,sBAAsB,CAAC,eAAe,EAAE;AAC1C,IAAI,OAAO,qBAAqB,CAAC,eAAe,EAAE,qBAAqB,CAAC,IAAI,qBAAqB,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;AACzI,GAAG;AACH,EAAE,wBAAwB,GAAG;AAC7B,IAAI,OAAO,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,qBAAqB,CAAC,EAAE,GAAG,qBAAqB,CAAC,EAAE,CAAC;AACzK,GAAG;AACH;;;;"}